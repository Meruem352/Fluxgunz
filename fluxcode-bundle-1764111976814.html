<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Flux GunZ Mobile</title>
    <style>:root {
    --bg-color: #111;
    --terminal-green: #0f0;
    --neon-blue: #00f3ff;
    --neon-pink: #ff0055;
    --neon-yellow: #ffcc00;
    --hud-bg: rgba(0, 0, 0, 0.6);
    --tech-font: 'Courier New', Courier, monospace;
}

* {
    box-sizing: border-box;
    user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
}

body {
    margin: 0;
    padding: 0;
    background-color: #000;
    color: white;
    font-family: var(--tech-font);
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    width: 100vw;
    position: fixed;
}

#game-container {
    position: relative;
    width: 100%;
    height: 100%;
    max-width: 100%;
    background-color: #111;
    overflow: hidden;
    touch-action: none;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
}

/* UI Layer - HIGHEST Z-INDEX TO ENSURE CLICKS */
#ui-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 40; /* CRITICAL FIX: Above controls */
    pointer-events: none; /* Allow clicks to pass through empty space */
    padding: 10px;
    padding-bottom: max(10px, env(safe-area-inset-bottom));
    transition: opacity 0.5s ease; 
}

/* CINEMATIC BARS */
.cinematic-bar {
    position: absolute;
    left: 0;
    width: 100%;
    height: 0;
    background: black;
    z-index: 500;
    transition: height 0.5s ease-in-out;
    pointer-events: none;
}
.cinematic-bar.top { top: 0; }
.cinematic-bar.bottom { bottom: 0; }

/* Cinematic Active State */
body.cinematic-active .cinematic-bar { height: 12%; }
body.cinematic-active #ui-layer { opacity: 0; }
body.cinematic-active #controls { opacity: 0; pointer-events: none; }

/* MENU BUTTON */
#btn-menu {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 40px;
    background: rgba(0,0,0,0.6);
    border: 1px solid var(--neon-blue);
    color: var(--neon-blue);
    font-size: 20px;
    pointer-events: auto; /* CRITICAL FIX: Capture clicks */
    z-index: 100; 
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 4px;
    cursor: pointer;
}

/* MODALS */
.modal {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9);
    backdrop-filter: blur(10px);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}
.modal.hidden { display: none; }

.modal-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 300px;
    text-align: center;
}

.menu-btn {
    background: rgba(0, 243, 255, 0.1);
    border: 1px solid var(--neon-blue);
    color: var(--neon-blue);
    padding: 15px;
    font-family: var(--tech-font);
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
}
.menu-btn:active { background: var(--neon-blue); color: black; }
.menu-btn.disabled { opacity: 0.5; border-color: #555; color: #555; pointer-events: none; }
.menu-btn.small { padding: 10px; font-size: 14px; margin-top: 20px; border-color: #aaa; color: #aaa; }

/* BESTIARY STYLES */
.bestiary-container {
    width: 90%;
    height: 90%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}
.bestiary-view {
    flex: 1;
    width: 100%;
    background: radial-gradient(circle, #222 0%, #000 100%);
    border: 1px solid #333;
    position: relative;
    overflow: hidden;
}
.bestiary-controls {
    display: flex;
    align-items: center;
    gap: 20px;
    width: 100%;
    justify-content: center;
}
.nav-btn {
    background: none; border: 1px solid var(--neon-blue); color: var(--neon-blue);
    width: 40px; height: 40px; font-size: 20px; cursor: pointer;
}
#bestiary-label {
    font-size: 24px; color: var(--neon-yellow); font-weight: bold; text-shadow: 0 0 10px var(--neon-yellow);
    width: 250px; text-align: center;
}
.bestiary-info {
    width: 100%;
    padding: 10px;
    background: rgba(0,0,0,0.5);
    border-top: 1px solid #333;
    color: #ccc;
    font-size: 14px;
    text-align: center;
    min-height: 60px;
}

/* HUD EDITOR */
#hud-editor {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 50, 0, 0.3); /* Green tint for "Positive" mode */
    z-index: 2000;
    pointer-events: none; /* Let clicks pass through to buttons, but capture toolbar */
}
#hud-editor.hidden { display: none; }

.editor-toolbar {
    position: absolute;
    top: 0; left: 0; width: 100%;
    background: #000;
    padding: 10px;
    display: flex;
    justify-content: center;
    gap: 10px;
    pointer-events: auto;
    border-bottom: 1px solid var(--terminal-green);
}
.editor-btn {
    background: #222; border: 1px solid #555; color: white;
    padding: 5px 10px; font-family: var(--tech-font);
}
.editor-btn.close { background: var(--terminal-green); color: black; border-color: var(--terminal-green); }

/* UI EDIT MODE OVERRIDES */
body.ui-edit-mode #controls {
    background: rgba(0, 255, 0, 0.1); /* Visual indicator */
}
body.ui-edit-mode .btn {
    border: 2px dashed var(--terminal-green);
    cursor: grab;
}
body.ui-edit-mode .btn:active {
    cursor: grabbing;
    background: rgba(0, 255, 0, 0.3);
}

/* CROSSHAIR */
#crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 40px;
    height: 40px;
    pointer-events: none;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0.8;
}

.ch-dot {
    width: 4px;
    height: 4px;
    background: var(--terminal-green);
    border-radius: 50%;
    position: absolute;
    box-shadow: 0 0 4px var(--terminal-green);
}

.ch-circle {
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    position: absolute;
    transition: width 0.1s, height 0.1s, border-color 0.1s;
}

/* LOCK-ON CURSOR */
#lock-cursor {
    position: absolute;
    width: 80px;
    height: 80px;
    pointer-events: none;
    transform: translate(-50%, -50%);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 100;
}

#lock-cursor.hidden { display: none; }

.lock-ring {
    position: absolute;
    width: 100%;
    height: 100%;
    border: 2px dashed #ff0055;
    border-radius: 50%;
    animation: spin 2s linear infinite;
    box-shadow: 0 0 10px #ff0055;
}

.lock-ring-inner {
    position: absolute;
    width: 60%;
    height: 60%;
    border: 2px solid #ff0055;
    border-radius: 50%;
    animation: pulseLock 0.5s infinite;
}

.lock-text {
    position: absolute;
    top: -20px;
    color: #ff0055;
    font-size: 10px;
    font-weight: bold;
    text-shadow: 0 0 5px #ff0055;
    letter-spacing: 2px;
}

@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
@keyframes pulseLock { 0% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); opacity: 0.8; } }

/* OFF-SCREEN INDICATORS */
#offscreen-indicators {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
    overflow: hidden;
}

.indicator-arrow {
    position: absolute;
    width: 0; 
    height: 0; 
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-bottom: 20px solid #ff0055;
    transform-origin: center bottom;
    filter: drop-shadow(0 0 5px #ff0055);
    opacity: 0.8;
}

/* HUD */
.hud-top-left {
    position: absolute;
    top: 20px;
    left: 20px;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.bar-container { display: flex; align-items: center; gap: 5px; }
.bar-label { font-weight: bold; font-size: 14px; width: 25px; text-shadow: 1px 1px 0 #000; }
.bar-bg {
    width: 150px; height: 12px; background: #333; border: 1px solid #555;
    position: relative; transform: skewX(-15deg);
}
.bar-fill { height: 100%; width: 100%; background: var(--terminal-green); transition: width 0.1s; }
#hp-bar { background: var(--neon-pink); box-shadow: 0 0 5px var(--neon-pink); }
#ap-bar { background: var(--neon-blue); box-shadow: 0 0 5px var(--neon-blue); }

/* SHIELD BAR (New) */
#shield-bar-container {
    position: absolute;
    top: -15px; /* Above HP */
    left: 0;
    width: 100%;
    height: 4px;
    background: #000;
    opacity: 0; /* Hidden by default */
    transition: opacity 0.2s;
}
#shield-bar-container.active { opacity: 1; }
#shield-bar {
    width: 100%; height: 100%;
    background: #00ffff;
    box-shadow: 0 0 5px #00ffff;
    transition: width 0.1s;
}

.ammo-container {
    margin-top: 10px; font-size: 18px; font-weight: bold; color: #fff;
    text-shadow: 1px 1px 0 #000; background: rgba(0,0,0,0.5); padding: 5px 10px;
    border-left: 3px solid var(--terminal-green); display: flex; flex-direction: column;
}
#weapon-name { font-size: 12px; color: #aaa; }
#ammo-count { color: var(--terminal-green); }
#reload-msg { color: #ffff00; font-weight: bold; font-size: 14px; animation: blink 0.2s infinite; margin-top: 5px; }
#reload-msg.hidden { display: none; }

.hud-top-right { position: absolute; top: 20px; right: 20px; text-align: right; }
.debug-info { background: var(--hud-bg); padding: 4px 8px; font-size: 12px; color: #aaa; border-radius: 4px; }

/* CONTROLS - CLEAN ERGONOMIC STYLE */
#controls {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 30; /* Below UI Layer */
    touch-action: none;
    transition: opacity 0.5s ease;
    pointer-events: auto; /* Capture Game Input */
}

/* Joysticks - Minimalist */
.joystick-zone {
    position: absolute;
    width: 140px; height: 140px;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0) 60%);
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.1);
    touch-action: none; pointer-events: none;
    transform: translate(-50%, -50%);
}
.joystick-zone.hidden { display: none; }
.joystick-knob {
    position: absolute; top: 50%; left: 50%;
    width: 40px; height: 40px;
    background: rgba(255, 255, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
}

/* ACTION BUTTONS CONTAINER - Ergonomic Arc */
#action-buttons {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 260px;
    height: 260px;
    pointer-events: auto;
    padding-bottom: env(safe-area-inset-bottom);
}

/* BASE BUTTON STYLE */
.btn {
    position: absolute;
    width: 60px; height: 60px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.3);
    color: white;
    font-weight: 900;
    font-size: 24px;
    display: flex; justify-content: center; align-items: center;
    touch-action: none;
    transition: transform 0.05s, background-color 0.1s, box-shadow 0.1s;
    font-family: var(--tech-font);
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    pointer-events: auto;
}

.btn:active {
    transform: scale(0.95);
    background: rgba(255, 255, 255, 0.2);
    box-shadow: 0 2px 3px rgba(0,0,0,0.3);
}

/* --- ERGONOMIC LAYOUT --- */

/* ATTACK: Center of the arc, largest */
#btn-attack {
    width: 85px; height: 85px;
    bottom: 40px; right: 40px; /* Anchor point */
    background: rgba(255, 0, 85, 0.2);
    border-color: var(--neon-pink);
    font-size: 32px;
    box-shadow: 0 0 15px rgba(255, 0, 85, 0.3);
}

/* JUMP: Directly Below/Left of Attack */
#btn-jump {
    bottom: 10px; right: 130px;
    background: rgba(0, 255, 136, 0.2);
    border-color: var(--terminal-green);
}

/* DASH: Directly Above/Right of Attack */
#btn-dash {
    bottom: 130px; right: 10px;
    background: rgba(0, 243, 255, 0.2);
    border-color: var(--neon-blue);
}

/* BLOCK: To the Left of Attack */
#btn-block {
    bottom: 90px; right: 140px;
    background: rgba(255, 204, 0, 0.2);
    border-color: var(--neon-yellow);
    width: 55px; height: 55px;
}

/* RELOAD: Top Left of cluster */
#btn-reload {
    bottom: 180px; right: 100px;
    background: rgba(255, 255, 255, 0.1);
    border-color: #aaa;
    width: 50px; height: 50px;
    font-size: 16px;
}

/* SWITCH: Bottom Left of cluster */
#btn-switch {
    bottom: 10px; right: 200px;
    background: rgba(255, 255, 255, 0.1);
    border-color: #fff;
    width: 50px; height: 50px;
    font-size: 18px;
}

/* TECHNIQUE: Central Modifier (Small, near thumb rest) */
#btn-tech {
    bottom: 140px; right: 80px; /* Nestled between Dash, Block, Reload */
    background: rgba(255, 0, 255, 0.2);
    border-color: #ff00ff;
    width: 45px; height: 45px;
    font-size: 14px;
    box-shadow: 0 0 10px rgba(255, 0, 255, 0.4);
}

/* LEFT SIDE TOGGLES - Stacked vertically */
#btn-lock, #btn-cam-switch, #btn-gyro {
    position: absolute;
    left: 20px;
    width: 50px; height: 50px;
    border-radius: 12px; /* Squircle */
    border: 1px solid rgba(255,255,255,0.3);
    background: rgba(0,0,0,0.6);
    color: white;
    font-size: 20px;
    z-index: 35;
    pointer-events: auto;
}

#btn-lock { bottom: 120px; border-color: var(--neon-pink); }
#btn-cam-switch { bottom: 180px; border-color: var(--neon-yellow); }
#btn-gyro { bottom: 240px; border-color: var(--neon-blue); }

#btn-gyro.active {
    background: var(--neon-blue);
    color: black;
    box-shadow: 0 0 10px var(--neon-blue);
}

/* FLOATING DAMAGE NUMBERS - UPDATED FOR RETRO FEEL */
.damage-number {
    position: absolute;
    color: white;
    font-weight: 900; /* Extra Bold */
    font-size: 48px; /* Huge */
    font-family: 'Courier New', Courier, monospace; /* Monospace for blocky feel */
    pointer-events: none;
    text-shadow: 3px 3px 0 #000; /* Hard shadow */
    animation: floatUp 0.8s ease-out forwards;
    z-index: 100;
    transform-origin: center;
    transform: scale(1.5); /* Scale up to match low-res feel */
    letter-spacing: -2px;
}

.damage-crit { 
    color: #ff0055; 
    font-size: 64px; 
    text-shadow: 4px 4px 0 #000, 0 0 10px #ff0055; 
    font-style: italic;
}

.damage-parry { 
    color: #00ffff; 
    font-size: 50px; 
    font-weight: 900; 
    font-style: italic; 
    text-shadow: 0 0 20px #00ffff; 
    animation: floatUp 1.0s ease-out forwards; 
}

@keyframes floatUp {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
    20% { transform: translate(-50%, -150%) scale(1.5); opacity: 1; } /* Pop up big */
    100% { transform: translate(-50%, -300%) scale(1.2); opacity: 0; }
}

/* STYLE RANK */
#combo-container {
    position: absolute; top: 20%; right: 20px; text-align: right;
    opacity: 0; transform: translateX(20px); transition: opacity 0.2s, transform 0.1s;
    display: flex; flex-direction: column; align-items: flex-end;
}
#combo-container.active { opacity: 1; transform: translateX(0); }
#style-rank { font-size: 64px; font-weight: 900; font-style: italic; line-height: 1; margin-bottom: 5px; text-shadow: 4px 4px 0 #000; }
#style-rank.rank-d { color: #888; }
#style-rank.rank-c { color: #fff; }
#style-rank.rank-b { color: #0f0; }
#style-rank.rank-a { color: #ff0; }
#style-rank.rank-s { color: #f00; animation: shake 0.5s infinite; }
#style-rank.rank-ss { color: #f0f; animation: glitch 0.2s infinite; }
#style-rank.rank-sss { 
    background: linear-gradient(to bottom, #fff, #0ff, #f0f); 
    -webkit-background-clip: text; 
    -webkit-text-fill-color: transparent; 
    font-size: 100px; 
    animation: pulse 0.1s infinite; 
    filter: drop-shadow(0 0 10px #fff);
}
#combo-count { font-size: 32px; font-weight: 900; color: var(--neon-blue); font-style: italic; line-height: 1; text-shadow: 2px 2px 0 #000; }
#combo-label { font-size: 16px; color: white; letter-spacing: 2px; font-weight: bold; }

@keyframes shake { 0% { transform: translate(0,0); } 25% { transform: translate(2px, -2px); } 50% { transform: translate(-2px, 2px); } 75% { transform: translate(2px, 2px); } 100% { transform: translate(0,0); } }
@keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
@keyframes glitch { 0% { transform: translate(0,0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0,0); } }

/* LOADING/GAME OVER */
#loading-screen, #game-over-screen {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: #000; z-index: 9999; display: flex; justify-content: center; align-items: center; flex-direction: column;
}
#game-over-screen { background: rgba(0,0,0,0.85); z-index: 9000; backdrop-filter: blur(5px); }
#game-over-screen.hidden { display: none; }
.glitch-text { font-size: 40px; font-weight: 900; color: #ff0055; text-shadow: 2px 2px 0px #00f3ff; animation: glitch 0.3s infinite; }
.sub-text { margin-top: 20px; color: white; font-size: 18px; animation: blink 1s infinite; }
.loading-text { color: var(--terminal-green); font-weight: bold; animation: blink 0.5s infinite; font-size: 24px; text-shadow: 0 0 10px var(--terminal-green); }
@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

/* SCANLINES */
.scanlines {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
    background-size: 100% 4px; pointer-events: none; z-index: 10; opacity: 0.4;
}
.vignette {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
    pointer-events: none; z-index: 11; transition: box-shadow 0.3s;
}
.vignette.danger { box-shadow: inset 0 0 100px rgba(255, 0, 0, 0.5); animation: pulseDanger 1s infinite; }
@keyframes pulseDanger { 0%, 100% { box-shadow: inset 0 0 100px rgba(255, 0, 0, 0.3); } 50% { box-shadow: inset 0 0 150px rgba(255, 0, 0, 0.6); } }</style>
    
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post Processing Imports -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/RGBShiftShader.js"></script>

</head>
<body>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-text">FLUX ENGINE READY</div>
        <div style="margin-top:20px; color:white; font-size:14px; animation:blink 1s infinite;">TAP SCREEN TO INITIALIZE AUDIO</div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden">
        <div class="glitch-text">SYSTEM FAILURE</div>
        <div class="sub-text">Tap to Reboot</div>
    </div>

    <!-- MAIN MENU MODAL -->
    <div id="main-menu" class="modal hidden">
        <div class="modal-content">
            <h1 class="glitch-text">SYSTEM MENU</h1>
            <button class="menu-btn" id="menu-mechs">MECHS (BESTIARY)</button>
            <button class="menu-btn disabled" id="menu-items">ITEMS [LOCKED]</button>
            <button class="menu-btn disabled" id="menu-arena">ARENA [LOCKED]</button>
            <button class="menu-btn" id="menu-options">OPTIONS</button>
            <button class="menu-btn" id="menu-quit">RESUME</button>
        </div>
    </div>

    <!-- BESTIARY MODAL -->
    <div id="bestiary-menu" class="modal hidden">
        <div class="bestiary-container">
            <div class="bestiary-view" id="bestiary-canvas-container">
                <!-- 3D View Rendered Here -->
            </div>
            <div class="bestiary-controls">
                <button class="nav-btn" id="bestiary-prev">&lt;</button>
                <div id="bestiary-label">DRONE: STANDARD</div>
                <button class="nav-btn" id="bestiary-next">&gt;</button>
            </div>
            <div class="bestiary-info">
                <p id="bestiary-desc">Standard combat drone equipped with laser weaponry. Common threat.</p>
            </div>
            <button class="menu-btn small" id="bestiary-back">BACK</button>
        </div>
    </div>

    <!-- OPTIONS MODAL -->
    <div id="options-menu" class="modal hidden">
        <div class="modal-content">
            <h1>OPTIONS</h1>
            <button class="menu-btn" id="opt-layout">BUTTON LAYOUT</button>
            <button class="menu-btn small" id="opt-back">BACK</button>
        </div>
    </div>

    <!-- HUD EDITOR OVERLAY -->
    <div id="hud-editor" class="hidden">
        <div class="editor-toolbar">
            <span>DRAG BUTTONS TO MOVE</span>
            <button class="editor-btn" id="editor-save">SAVE</button>
            <button class="editor-btn" id="editor-load">LOAD</button>
            <button class="editor-btn" id="editor-reset">RESET</button>
            <button class="editor-btn close" id="editor-close">DONE</button>
        </div>
        <input type="file" id="layout-file-input" style="display:none" accept=".json">
    </div>

    <!-- Cinematic Bars -->
    <div class="cinematic-bar top"></div>
    <div class="cinematic-bar bottom"></div>

    <!-- Game Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- Scanline Overlay & Vignette -->
        <div class="scanlines"></div>
        <div class="vignette"></div>

        <!-- UI / HUD -->
        <div id="ui-layer">
            <!-- Menu Toggle Button -->
            <button id="btn-menu" class="hud-btn">‚ò∞</button>

            <!-- Dynamic Crosshair -->
            <div id="crosshair">
                <div class="ch-dot"></div>
                <div class="ch-circle"></div>
            </div>

            <!-- Lock-On Cursor -->
            <div id="lock-cursor" class="hidden">
                <div class="lock-ring"></div>
                <div class="lock-ring-inner"></div>
                <div class="lock-text">LOCKED</div>
            </div>
            
            <!-- Off-Screen Indicators (Threat Halos) -->
            <div id="offscreen-indicators"></div>

            <div class="hud-top-left">
                <div class="bar-container">
                    <div class="bar-label">HP</div>
                    <div class="bar-bg"><div id="hp-bar" class="bar-fill"></div></div>
                </div>
                <div class="bar-container">
                    <div class="bar-label">AP</div>
                    <div class="bar-bg"><div id="ap-bar" class="bar-fill"></div></div>
                </div>
                <!-- Ammo Indicator -->
                <div class="ammo-container" id="ammo-display">
                    <span id="weapon-name">KATANA</span>
                    <span id="ammo-count">---</span>
                </div>
                <div id="reload-msg" class="hidden">RELOADING...</div>
            </div>

            <div class="hud-top-right">
                <div class="debug-info">FPS: <span id="fps-counter">60</span></div>
                <div class="debug-info" id="res-debug" style="margin-top:5px; font-size:10px;">RES: 50%</div>
            </div>

            <div id="combo-container">
                <div id="combo-count">0</div>
                <div id="combo-label">HITS</div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="controls">
            <!-- Left Joystick (Movement) -->
            <div id="joystick-zone-left" class="joystick-zone hidden">
                <div id="joystick-knob-left" class="joystick-knob"></div>
            </div>
            
            <!-- Right Joystick (Camera) -->
            <div id="joystick-zone-right" class="joystick-zone hidden">
                <div id="joystick-knob-right" class="joystick-knob"></div>
            </div>

            <!-- Left Side Toggles -->
            <button class="btn" id="btn-lock" data-action="lock">üéØ</button>
            <button class="btn" id="btn-cam-switch" data-action="cam-switch">üëÅ</button>
            <button class="btn" id="btn-gyro" data-action="gyro">üì±</button>

            <!-- Right Side Actions -->
            <div id="action-buttons">
                <button class="btn" id="btn-reload" data-action="reload">‚Üª</button>
                <button class="btn" id="btn-switch" data-action="switch">‚öî</button>
                <button class="btn" id="btn-block" data-action="block">üõ°</button>
                <button class="btn" id="btn-dash" data-action="dash">‚ö°</button>
                <button class="btn" id="btn-jump" data-action="jump">‚ñ≤</button>
                <button class="btn" id="btn-attack" data-action="attack">üí•</button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>/**
 * TEXTURE GENERATOR - HERCULEAN GRAPHICS UPDATE
 * High-fidelity procedural textures with multi-pass noise and blending.
 * UPDATED: Added Procedural MatCap for Anime-style lighting.
 * UPDATED: Vibrant Color Palette & Increased Brightness
 */
const TextureGen = {
    
    // Helper: Create Noise
    createNoise: function(ctx, width, height, alpha = 0.1) {
        const imgData = ctx.createImageData(width, height);
        const buffer = new Uint32Array(imgData.data.buffer);
        const len = buffer.length;
        for (let i = 0; i < len; i++) {
            if (Math.random() < 0.5) continue; // Optimization
            const val = Math.random() * 255;
            // ABGR format (little endian)
            buffer[i] = (Math.floor(val * alpha) << 24) | (val << 16) | (val << 8) | val;
        }
        // Draw noise onto a temp canvas then blend
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = width;
        tmpCanvas.height = height;
        tmpCanvas.getContext('2d').putImageData(imgData, 0, 0);
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(tmpCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    },

    // 1. PLASMA GRID (Floor) - Dynamic & Glowing
    // UPDATED: Brighter background, stronger glow
    createGrid: function(size = 1024, color = '#00f3ff', bg = '#101025') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // Deep Space Background (Lighter than pitch black)
        const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size);
        grad.addColorStop(0, '#2a2a4e'); // Center glow
        grad.addColorStop(1, '#050510'); // Edge dark
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, size, size);

        // Subtle Noise Texture
        this.createNoise(ctx, size, size, 0.08);

        // Grid Logic
        const divisions = 8;
        const step = size / divisions;

        ctx.lineWidth = 8; // Thicker lines
        ctx.shadowBlur = 25;
        ctx.shadowColor = color;
        ctx.strokeStyle = color;

        // Major Lines (Glowing)
        ctx.beginPath();
        for(let i=0; i<=size; i+=step) {
            ctx.moveTo(i, 0); ctx.lineTo(i, size);
            ctx.moveTo(0, i); ctx.lineTo(size, i);
        }
        ctx.stroke();

        // Minor Lines (Sub-grid, Fainter)
        ctx.lineWidth = 2;
        ctx.shadowBlur = 5;
        ctx.strokeStyle = 'rgba(0, 243, 255, 0.3)'; // More visible
        const subStep = step / 4;
        ctx.beginPath();
        for(let i=0; i<=size; i+=subStep) {
            if(i % step === 0) continue;
            ctx.moveTo(i, 0); ctx.lineTo(i, size);
            ctx.moveTo(0, i); ctx.lineTo(size, i);
        }
        ctx.stroke();

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = 16;
        return tex;
    },

    // 2. GRUNGE CONCRETE (Walls) - Dirty & Industrial
    // UPDATED: Lighter concrete base
    createBuildingTex: function(size = 512, baseColor = '#444') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // Base Concrete (Lighter)
        ctx.fillStyle = '#555555'; 
        ctx.fillRect(0,0,size,size);
        
        // Heavy Noise
        this.createNoise(ctx, size, size, 0.15);
        
        // Water Stains / Grime
        ctx.globalCompositeOperation = 'multiply';
        const grad = ctx.createLinearGradient(0, 0, 0, size);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, '#aaaaaa');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,size,size);
        ctx.globalCompositeOperation = 'source-over';

        // Windows (Cyberpunk Style)
        const cols = 4;
        const rows = 8;
        const padX = 20;
        const padY = 15;
        const w = (size / cols) - padX;
        const h = (size / rows) - padY;

        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                // More lit windows
                const isLit = Math.random() > 0.5; 
                if(isLit) {
                    // Neon Window
                    const hue = Math.random() > 0.5 ? 320 : 190; 
                    ctx.fillStyle = `hsla(${hue}, 100%, 75%, 0.95)`;
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = ctx.fillStyle;
                } else {
                    // Dark Glass (Reflective-ish)
                    ctx.fillStyle = '#111122';
                    ctx.shadowBlur = 0;
                }
                
                const x = c * (size/cols) + padX/2;
                const y = r * (size/rows) + padY/2;
                ctx.fillRect(x, y, w, h);
                
                // Window Frame
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, w, h);
            }
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    // 3. HEX METAL (Obstacles/Tech)
    // UPDATED: Brighter metal
    createHazard: function(size = 512, color1 = '#333', color2 = '#ffcc00') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // Dark Metal Base (Lighter)
        ctx.fillStyle = '#333333';
        ctx.fillRect(0, 0, size, size);
        this.createNoise(ctx, size, size, 0.1);

        // Hexagon Pattern Overlay
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        const r = 32;
        const w = Math.sqrt(3) * r;
        const h = 2 * r;
        
        for (let y = -h; y < size + h; y += h * 0.75) {
            for (let x = -w; x < size + w; x += w) {
                const cx = x + ((Math.floor(y / (h * 0.75)) % 2) * w / 2);
                const cy = y;
                
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    ctx.lineTo(cx + r * Math.cos(i * Math.PI / 3), cy + r * Math.sin(i * Math.PI / 3));
                }
                ctx.closePath();
                ctx.stroke();
                
                // Randomly fill hexes (Tech lights)
                if (Math.random() > 0.90) { // More lights
                    ctx.fillStyle = '#ffaa00';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffaa00';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        // Hazard Stripes (Overlay)
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = color2;
        const stripeWidth = 128;
        ctx.beginPath();
        for (let i = -size; i < size * 2; i += stripeWidth * 2) {
            ctx.moveTo(i, 0);
            ctx.lineTo(i + stripeWidth, 0);
            ctx.lineTo(i + stripeWidth - size, size);
            ctx.lineTo(i - size, size);
        }
        ctx.fill();
        ctx.globalAlpha = 1.0;
        
        // Border
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 15;
        ctx.strokeRect(0,0,size,size);

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    // 4. ADVANCED CARBON FIBER (Player Armor)
    createCarbonFiber: function(size = 512) {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#111111';
        ctx.fillRect(0, 0, size, size);

        const tile = size / 16; // Higher density
        
        for(let y=0; y<16; y++) {
            for(let x=0; x<16; x++) {
                const isVertical = (x+y)%2 === 0;
                const gx = x*tile;
                const gy = y*tile;
                
                const grad = isVertical 
                    ? ctx.createLinearGradient(gx, gy, gx+tile, gy)
                    : ctx.createLinearGradient(gx, gy, gx, gy+tile);
                
                grad.addColorStop(0, '#222');
                grad.addColorStop(0.5, '#444');
                grad.addColorStop(1, '#222');
                
                ctx.fillStyle = grad;
                ctx.fillRect(gx, gy, tile, tile);
            }
        }
        
        // Glossy coat noise
        this.createNoise(ctx, size, size, 0.03);

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(2, 2);
        return tex;
    },

    // 5. HOLOGRAPHIC AD (Neon Signs)
    createAd: function(size = 512, text = "FLUX") {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size / 2;
        const ctx = canvas.getContext('2d');

        // Transparent BG
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0,0,size,size/2);
        
        // Border Glow
        ctx.strokeStyle = '#ff0055';
        ctx.lineWidth = 10;
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#ff0055';
        ctx.strokeRect(10, 10, size-20, (size/2)-20);
        
        // Text
        ctx.fillStyle = '#ffffff';
        ctx.font = '900 80px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ffffff';
        ctx.fillText(text, size/2, size/4);
        
        // Scanlines
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        for(let i=0; i<size/2; i+=6) {
            ctx.fillRect(0, i, size, 3);
        }

        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    },

    // 6. NEON SIGN (Vertical)
    createNeonSign: function(size = 256, color = '#0f0', text = "BAR") {
        const canvas = document.createElement('canvas');
        canvas.width = size / 2;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#111';
        ctx.fillRect(0,0,size/2, size);
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center';
        
        // Vertical Text
        const chars = text.split('');
        const startY = (size - (chars.length * 60)) / 2 + 40;
        
        for(let i=0; i<chars.length; i++) {
            ctx.fillText(chars[i], size/4, startY + (i * 60));
        }
        
        // Border
        ctx.strokeStyle = color;
        ctx.lineWidth = 6;
        ctx.strokeRect(5, 5, (size/2)-10, size-10);
        
        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    },
    
    // 7. PROCEDURAL MATCAP (Anime Style)
    // Simulates a lit sphere to map normals to colors
    createMatCap: function(size = 256, color = '#ffffff', rimColor = '#000000') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const cx = size / 2;
        const cy = size / 2;
        const r = size / 2;
        
        // Background (Shadow)
        ctx.fillStyle = rimColor;
        ctx.fillRect(0, 0, size, size);
        
        // Main Lit Sphere (Offset slightly up-left to simulate studio light)
        const grad = ctx.createRadialGradient(cx - r*0.2, cy - r*0.2, r*0.1, cx, cy, r);
        grad.addColorStop(0, '#ffffff'); // Highlight
        grad.addColorStop(0.4, color);   // Midtone
        grad.addColorStop(0.9, rimColor); // Shadow/Rim
        grad.addColorStop(1, rimColor);
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, r - 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Hard Edge (Cel Shade effect)
        // We can draw a sharper arc to create a distinct band
        ctx.globalCompositeOperation = 'source-atop';
        const highlightGrad = ctx.createLinearGradient(0, 0, size, size);
        highlightGrad.addColorStop(0, 'rgba(255,255,255,0.8)');
        highlightGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
        ctx.fillStyle = highlightGrad;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();

        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    },
    
    // Helper for adding noise to existing context (legacy support)
    addNoise: function(ctx, size, alpha) {
        this.createNoise(ctx, size, size, alpha);
    }
};</script>
    <script>/**
 * VFX SYSTEM - HERCULEAN VISUALS
 * Handles Ribbon Trails, Procedural Meshes, and Complex Effects.
 * UPDATED: Added DeathRay for Boss Mechanics.
 */

class RibbonTrail {
    constructor(scene, maxPoints = 50, width = 0.5, color = 0x00ffff) {
        this.maxPoints = maxPoints;
        this.width = width;
        this.points = []; // Stores { pos: Vector3, normal: Vector3 }
        
        // Geometry
        this.geometry = new THREE.BufferGeometry();
        
        // 2 vertices per point (triangle strip)
        // Position buffer size: maxPoints * 2 vertices * 3 coordinates
        const positions = new Float32Array(maxPoints * 2 * 3);
        this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // UVs
        const uvs = new Float32Array(maxPoints * 2 * 2);
        this.geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        
        // Material (Additive Gradient)
        this.material = new THREE.MeshBasicMaterial({
            color: color,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.frustumCulled = false; // Always render
        scene.add(this.mesh);
        
        // Temp vars
        this.tempVec = new THREE.Vector3();
        this.tempDir = new THREE.Vector3();
    }
    
    update(targetPos, dt) {
        // Add new point
        // Only add if moved enough
        if (this.points.length > 0) {
            const last = this.points[0];
            if (last.distanceTo(targetPos) < 0.1) return;
        }
        
        this.points.unshift(targetPos.clone());
        if (this.points.length > this.maxPoints) {
            this.points.pop();
        }
        
        this.updateGeometry();
    }
    
    updateGeometry() {
        const posAttr = this.geometry.attributes.position;
        const uvAttr = this.geometry.attributes.uv;
        
        for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i+1];
            
            // Calculate direction
            this.tempDir.subVectors(p2, p1).normalize();
            
            // Calculate perpendicular (Ribbon width)
            // Assuming mostly vertical ribbon for now, cross with Y
            // Better: Cross with camera direction, but for now simple Y up cross
            const perp = new THREE.Vector3().crossVectors(this.tempDir, new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(this.width / 2);
            
            // Vertex 1 (Left)
            posAttr.setXYZ(i * 2, p1.x - perp.x, p1.y - perp.y, p1.z - perp.z);
            // Vertex 2 (Right)
            posAttr.setXYZ(i * 2 + 1, p1.x + perp.x, p1.y + perp.y, p1.z + perp.z);
            
            // UVs (Fade out along length)
            const uvX = i / this.points.length;
            uvAttr.setXY(i * 2, uvX, 0);
            uvAttr.setXY(i * 2 + 1, uvX, 1);
        }
        
        // Taper end
        const lastIdx = this.points.length - 1;
        if (lastIdx > 0) {
            const p = this.points[lastIdx];
            posAttr.setXYZ(lastIdx * 2, p.x, p.y, p.z);
            posAttr.setXYZ(lastIdx * 2 + 1, p.x, p.y, p.z);
        }
        
        // Reset remaining buffer
        for (let i = this.points.length * 2; i < this.maxPoints * 2; i++) {
            posAttr.setXYZ(i, 0, 0, 0);
        }
        
        posAttr.needsUpdate = true;
        uvAttr.needsUpdate = true;
        
        // Update draw range so we don't render empty triangles
        this.geometry.setDrawRange(0, (this.points.length - 1) * 2);
    }
}

class DeathRay {
    constructor(scene) {
        this.mesh = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 1, 8, 1, true),
            new THREE.MeshBasicMaterial({ 
                color: 0xff00ff, 
                transparent: true, 
                opacity: 0, 
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            })
        );
        this.mesh.rotation.x = -Math.PI / 2; // Point Z
        this.mesh.visible = false;
        scene.add(this.mesh);
        
        this.core = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.3, 1, 8, 1, true),
            new THREE.MeshBasicMaterial({ color: 0xffffff, blending: THREE.AdditiveBlending })
        );
        this.core.rotation.x = -Math.PI / 2;
        this.mesh.add(this.core);
        
        this.active = false;
        this.timer = 0;
        this.duration = 0;
        this.startPos = new THREE.Vector3();
        this.endPos = new THREE.Vector3();
        this.maxScale = 1;
    }
    
    fire(start, end, duration = 1.0, width = 2.0) {
        this.active = true;
        this.timer = 0;
        this.duration = duration;
        this.startPos.copy(start);
        this.endPos.copy(end);
        this.maxScale = width;
        
        this.mesh.visible = true;
        this.mesh.position.copy(start);
        this.mesh.lookAt(end);
        
        const dist = start.distanceTo(end);
        this.mesh.scale.set(0, 0, dist); // Z is length
        this.mesh.translateZ(dist / 2); // Center cylinder
    }
    
    update(dt) {
        if (!this.active) return;
        
        this.timer += dt;
        const progress = this.timer / this.duration;
        
        if (progress >= 1) {
            this.active = false;
            this.mesh.visible = false;
            return;
        }
        
        // Expand and contract
        const scale = Math.sin(progress * Math.PI) * this.maxScale;
        const dist = this.startPos.distanceTo(this.endPos);
        
        this.mesh.scale.set(scale, scale, dist);
        this.mesh.material.opacity = Math.sin(progress * Math.PI);
        
        // Jitter
        this.mesh.rotation.z += dt * 10;
    }
}</script> 
    <script>/**
 * HOMING LASER SYSTEM - ZOE STYLE
 * Uses InstancedMesh and Quadratic Bezier curves for "Swarm" missiles.
 * UPDATED: Now applies damage to target.
 */
class HomingLaserSystem {
    constructor(scene, maxLasers = 100) {
        this.maxLasers = maxLasers;
        this.lasers = []; // Active laser data: { t: 0..1, p0, p1, p2, speed, active, target }
        
        // Geometry: Thin elongated box
        const geo = new THREE.BoxGeometry(0.1, 0.1, 1.0);
        geo.translate(0, 0, 0.5); // Pivot at tail
        
        // Material: Glowing Green/Blue
        const mat = new THREE.MeshBasicMaterial({
            color: 0x00ffaa,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });
        
        this.mesh = new THREE.InstancedMesh(geo, mat, maxLasers);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(this.mesh);
        
        this.dummy = new THREE.Object3D();
        
        // Pre-fill pool
        for(let i=0; i<maxLasers; i++) {
            this.lasers.push({ active: false, t: 0, p0: new THREE.Vector3(), p1: new THREE.Vector3(), p2: new THREE.Vector3(), speed: 1, target: null });
            this.dummy.position.set(0, -500, 0);
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
        }
    }
    
    spawn(startPos, endPos, targetEnemy = null) {
        // Find inactive laser
        const laser = this.lasers.find(l => !l.active);
        if (!laser) return;
        
        laser.active = true;
        laser.t = 0;
        laser.p0.copy(startPos);
        laser.p2.copy(endPos);
        laser.target = targetEnemy; // Store target for damage application
        
        // Calculate Control Point (P1) for the Curve
        // Project outward from start, then add random offset
        // This creates the "Flare out" effect before homing in
        const dist = startPos.distanceTo(endPos);
        const mid = new THREE.Vector3().lerpVectors(startPos, endPos, 0.5);
        
        // Random flare direction
        const flare = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() + 0.5) * 1, // Bias upwards
            (Math.random() - 0.5) * 2
        ).normalize().multiplyScalar(dist * 0.8); // Flare magnitude
        
        laser.p1.copy(mid).add(flare);
        
        laser.speed = 1.5 + Math.random(); // Variation in speed
        
        if (window.flux && window.flux.audio) window.flux.audio.play('switch'); // Placeholder sound
    }
    
    update(dt) {
        let activeCount = 0;
        
        for (let i = 0; i < this.maxLasers; i++) {
            const laser = this.lasers[i];
            if (!laser.active) {
                // Hide
                this.dummy.position.set(0, -500, 0);
                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(i, this.dummy.matrix);
                continue;
            }
            
            activeCount++;
            laser.t += dt * laser.speed;
            
            // Update target position if it's moving
            if (laser.target && !laser.target.userData.isDead) {
                laser.p2.copy(laser.target.position);
            }
            
            if (laser.t >= 1.0) {
                // Hit!
                laser.active = false;
                
                if (window.flux && window.flux.spawnHitParticles) {
                    window.flux.spawnHitParticles(laser.p2, new THREE.Vector3(0, 1, 0));
                }
                
                // APPLY DAMAGE
                if (laser.target && !laser.target.userData.isDead) {
                    const dmg = 30;
                    laser.target.userData.hp -= dmg;
                    
                    // Apply Knockback / "Fall Damage" simulation
                    if (laser.target.userData.velocity) {
                        laser.target.userData.velocity.y -= 20; // Push down hard
                        laser.target.userData.onGround = false;
                    }
                    
                    if (window.flux && window.flux.showDamage) {
                        window.flux.showDamage(laser.p2, dmg, false);
                    }
                    
                    if (laser.target.userData.hp <= 0) {
                        if (window.flux && window.flux.killEnemy) {
                            window.flux.killEnemy(laser.target);
                        }
                    } else {
                        // Flash effect
                        if (laser.target.traverse) {
                            laser.target.traverse((child) => {
                                if (child.isMesh && child.material && child.material.emissive) {
                                    child.material.emissive.setHex(0xffffff);
                                    setTimeout(() => {
                                        if (child.material) child.material.emissive.setHex(child.userData.origEmissive || 0x000000);
                                    }, 100);
                                }
                            });
                        }
                    }
                }
                
                continue;
            }
            
            // Quadratic Bezier: B(t) = (1-t)^2 P0 + 2(1-t)t P1 + t^2 P2
            const t = laser.t;
            const it = 1 - t;
            
            const pos = new THREE.Vector3()
                .copy(laser.p0).multiplyScalar(it * it)
                .addScaledVector(laser.p1, 2 * it * t)
                .addScaledVector(laser.p2, t * t);
            
            // Calculate tangent for rotation (derivative)
            // B'(t) = 2(1-t)(P1 - P0) + 2t(P2 - P1)
            const tangent = new THREE.Vector3()
                .copy(laser.p1).sub(laser.p0).multiplyScalar(2 * it)
                .addScaledVector(new THREE.Vector3().copy(laser.p2).sub(laser.p1), 2 * t)
                .normalize();
                
            this.dummy.position.copy(pos);
            this.dummy.lookAt(pos.clone().add(tangent));
            this.dummy.scale.set(1, 1, 1 + (laser.speed * 2)); // Stretch based on speed
            
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
        }
        
        if (activeCount > 0) {
            this.mesh.instanceMatrix.needsUpdate = true;
        }
    }
}</script> 
    <script>/**
 * ASSET FACTORY - HERCULEAN ASSET UPDATE
 * Generates high-fidelity, complex 3D models using procedural composition.
 * Replaces simple primitives with detailed, multi-part meshes.
 * UPDATED: Added 'createAnubisBoss' with custom Flow Shader.
 * UPDATED: Exposed Anubis Staff for animation.
 */
class AssetFactory {
    
    static createEnergyBlade(matBlade, matFrame) {
        const group = new THREE.Group();
        
        // Blade Emitter Housing
        const housing = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.4, 0.15), matFrame);
        housing.position.y = 0.2;
        group.add(housing);
        
        // The Energy Blade itself
        const bladeShape = new THREE.Shape();
        bladeShape.moveTo(0, 0);
        bladeShape.lineTo(0.1, 0.2);
        bladeShape.lineTo(0.08, 1.8); // Long blade
        bladeShape.lineTo(0, 2.0);    // Tip
        bladeShape.lineTo(-0.05, 1.8);
        bladeShape.lineTo(-0.02, 0);
        
        const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, { depth: 0.02, bevelEnabled: false });
        const blade = new THREE.Mesh(bladeGeo, matBlade);
        blade.rotation.x = -Math.PI / 2;
        blade.position.set(0, 0.4, 0);
        group.add(blade);
        
        // Glow Sprite (Fake Volumetrics)
        // Using simple geometry for now
        const glow = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 2.2), matBlade);
        glow.rotation.x = -Math.PI/2;
        glow.rotation.y = Math.PI/2; // Perpendicular to blade
        glow.position.set(0, 0.4, 1.0);
        glow.material = matBlade.clone();
        glow.material.opacity = 0.3;
        glow.material.side = THREE.DoubleSide;
        group.add(glow);

        return group;
    }

    static createAvengerShotgun() {
        const group = new THREE.Group();

        // Main Body (Blocky, Industrial)
        const bodyGeo = new THREE.BoxGeometry(0.18, 0.25, 0.8);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.6, roughness: 0.4 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.z = 0.2;
        group.add(body);

        // Barrel (Twin, Heavy)
        const barrelGeo = new THREE.CylinderGeometry(0.06, 0.06, 1.0, 16);
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.3 });
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0, 0.05, 0.8);
        group.add(barrel);

        // Heat Shield
        const shieldGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8, 1, true);
        const shieldMat = new THREE.MeshStandardMaterial({ color: 0x444444, side: THREE.DoubleSide });
        const shield = new THREE.Mesh(shieldGeo, shieldMat);
        shield.rotation.x = Math.PI / 2;
        shield.position.set(0, 0.05, 0.8);
        group.add(shield);

        // Stock
        const stockGeo = new THREE.BoxGeometry(0.12, 0.18, 0.6);
        const stock = new THREE.Mesh(stockGeo, bodyMat);
        stock.position.set(0, -0.05, -0.5);
        group.add(stock);

        // Pump Grip
        const gripGeo = new THREE.BoxGeometry(0.2, 0.12, 0.3);
        const gripMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 1.0 });
        const grip = new THREE.Mesh(gripGeo, gripMat);
        grip.position.set(0, -0.08, 0.6);
        group.add(grip);

        // Ammo Counter (Holo)
        const holoGeo = new THREE.PlaneGeometry(0.1, 0.05);
        const holoMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
        const holo = new THREE.Mesh(holoGeo, holoMat);
        holo.position.set(-0.1, 0.15, 0.1);
        holo.rotation.y = -0.5;
        group.add(holo);

        return group;
    }

    static createCyberMonolith() {
        const group = new THREE.Group();

        // Core Obelisk
        const coreGeo = new THREE.BoxGeometry(8, 25, 8);
        const coreMat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, 
            roughness: 0.2, 
            metalness: 0.9 
        });
        const core = new THREE.Mesh(coreGeo, coreMat);
        core.position.y = 12.5;
        group.add(core);

        // Glowing Runes / Data Streams
        const runeGeo = new THREE.BoxGeometry(8.1, 20, 8.1);
        const runeTex = TextureGen.createAd(512, "SYSTEM_CORE");
        runeTex.wrapS = THREE.RepeatWrapping;
        runeTex.wrapT = THREE.RepeatWrapping;
        runeTex.repeat.set(1, 4);
        
        const runeMat = new THREE.MeshBasicMaterial({ 
            map: runeTex, 
            transparent: true, 
            opacity: 0.6,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const runes = new THREE.Mesh(runeGeo, runeMat);
        runes.position.y = 12.5;
        group.add(runes);

        // Antennae array
        for(let i=0; i<4; i++) {
            const antGeo = new THREE.CylinderGeometry(0.2, 0.5, 8);
            const ant = new THREE.Mesh(antGeo, new THREE.MeshStandardMaterial({color: 0x333}));
            ant.position.set(
                (i%2===0 ? 3 : -3),
                28,
                (i<2 ? 3 : -3)
            );
            group.add(ant);
            
            // Beacons
            const light = new THREE.PointLight(0xff0000, 2, 10);
            light.position.copy(ant.position);
            light.position.y += 4;
            group.add(light);
        }

        return group;
    }

    static createHoloTerminal() {
        const group = new THREE.Group();
        
        // Base
        const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.5, 1.2, 6),
            new THREE.MeshStandardMaterial({ color: 0x222, metalness: 0.8 })
        );
        base.position.y = 0.6;
        group.add(base);

        // Screen
        const screenGeo = new THREE.PlaneGeometry(1.5, 1.0);
        const screenTex = TextureGen.createAd(256, "ACCESS");
        const screenMat = new THREE.MeshBasicMaterial({ 
            map: screenTex, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const screen = new THREE.Mesh(screenGeo, screenMat);
        screen.position.set(0, 1.8, 0.3);
        screen.rotation.x = -0.2;
        group.add(screen);
        
        // Keyboard projection
        const keyGeo = new THREE.PlaneGeometry(1.0, 0.6);
        const keyMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, wireframe: true, transparent: true, opacity: 0.3 });
        const keys = new THREE.Mesh(keyGeo, keyMat);
        keys.position.set(0, 1.3, 0.6);
        keys.rotation.x = -0.8;
        group.add(keys);

        return group;
    }

    static createMechDrone() {
        const group = new THREE.Group();
        
        // Materials
        const matDark = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0.6 });
        const matPlate = new THREE.MeshStandardMaterial({ color: 0x555566, roughness: 0.3, metalness: 0.8 });
        const matGlow = new THREE.MeshBasicMaterial({ color: 0xff3300 }); // Red eye
        const matEngine = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent:true, opacity:0.8, blending: THREE.AdditiveBlending });

        // Core Body (Dodecahedron for tech look)
        const coreGeo = new THREE.DodecahedronGeometry(0.5);
        const core = new THREE.Mesh(coreGeo, matDark);
        group.add(core);

        // Armor Plates (Top/Bottom)
        const plateGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 6);
        const plateTop = new THREE.Mesh(plateGeo, matPlate);
        plateTop.position.y = 0.35;
        group.add(plateTop);
        
        const plateBot = new THREE.Mesh(plateGeo, matPlate);
        plateBot.position.y = -0.35;
        group.add(plateBot);

        // Mono-Eye Sensor
        const eyeGeo = new THREE.SphereGeometry(0.25, 16, 16);
        const eye = new THREE.Mesh(eyeGeo, matGlow);
        eye.position.z = 0.35;
        eye.scale.set(1, 0.4, 1); // Slit eye
        group.add(eye);
        
        // Eye Glow Shell
        const eyeShell = new THREE.Mesh(eyeGeo, matGlow.clone());
        eyeShell.material.transparent = true;
        eyeShell.material.opacity = 0.4;
        eyeShell.material.blending = THREE.AdditiveBlending;
        eyeShell.scale.set(1.2, 0.6, 1.2);
        eye.add(eyeShell);

        // Thruster Arms (Left/Right)
        const armGeo = new THREE.BoxGeometry(0.4, 0.1, 0.1);
        const thrusterGeo = new THREE.CylinderGeometry(0.15, 0.1, 0.6, 8);
        thrusterGeo.rotateX(Math.PI/2); // Point back

        const leftArm = new THREE.Group();
        leftArm.position.set(-0.6, 0, 0);
        
        const lArmMesh = new THREE.Mesh(armGeo, matDark);
        leftArm.add(lArmMesh);
        
        const lThruster = new THREE.Mesh(thrusterGeo, matPlate);
        lThruster.position.x = -0.2;
        leftArm.add(lThruster);
        
        // Engine Glow
        const engineGlow = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.4, 8), matEngine);
        engineGlow.rotation.x = Math.PI/2; // Point back
        engineGlow.position.set(-0.2, 0, 0.4); // Behind thruster
        leftArm.add(engineGlow);

        group.add(leftArm);

        const rightArm = leftArm.clone();
        rightArm.position.set(0.6, 0, 0);
        rightArm.rotation.z = Math.PI; // Flip
        group.add(rightArm);

        // Underslung Gun
        const gunGeo = new THREE.BoxGeometry(0.15, 0.15, 0.6);
        const gun = new THREE.Mesh(gunGeo, matDark);
        gun.position.set(0, -0.5, 0.2);
        group.add(gun);
        
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.8), matPlate);
        barrel.rotation.x = Math.PI/2;
        barrel.position.set(0, -0.5, 0.6);
        group.add(barrel);

        // Store for animation
        group.userData.rotors = [leftArm, rightArm]; 

        return group;
    }

    static createCyberSamurai() {
        const group = new THREE.Group();
        
        // Torso
        const torso = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.8, 0.4),
            new THREE.MeshStandardMaterial({ color: 0x550000, metalness: 0.5 })
        );
        torso.position.y = 0.4;
        group.add(torso);

        // Head
        const head = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x111 })
        );
        head.position.y = 1.0;
        group.add(head);

        // Visor
        const visor = new THREE.Mesh(
            new THREE.BoxGeometry(0.32, 0.05, 0.2),
            new THREE.MeshBasicMaterial({ color: 0xff0055 })
        );
        visor.position.set(0, 1.0, 0.1);
        group.add(visor);

        return group;
    }

    static createExplosiveBarrel() {
        const group = new THREE.Group();

        const barrelGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16);
        const barrelMat = new THREE.MeshStandardMaterial({ 
            color: 0xcc3300, 
            metalness: 0.3,
            roughness: 0.7
        });
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.position.y = 0.6;
        group.add(barrel);

        // Warning Stripes (Torus rings)
        const ringGeo = new THREE.TorusGeometry(0.41, 0.02, 8, 16);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        
        const ring1 = new THREE.Mesh(ringGeo, ringMat);
        ring1.rotation.x = Math.PI / 2;
        ring1.position.y = 0.9;
        group.add(ring1);

        const ring2 = new THREE.Mesh(ringGeo, ringMat);
        ring2.rotation.x = Math.PI / 2;
        ring2.position.y = 0.3;
        group.add(ring2);

        return group;
    }

    // --- NEW BOSS ASSET: ANUBIS ---
    static createAnubisBoss() {
        const group = new THREE.Group();

        // --- MATERIALS ---
        const matBlack = new THREE.MeshStandardMaterial({ 
            color: 0x050505, 
            roughness: 0.2, 
            metalness: 0.9 
        });
        
        const matGold = new THREE.MeshStandardMaterial({ 
            color: 0xffcc00, 
            roughness: 0.1, 
            metalness: 1.0,
            emissive: 0xaa8800,
            emissiveIntensity: 0.2
        });

        // Custom Flow Shader for "White lights racing up and down"
        const flowVert = `
            varying vec2 vUv;
            varying vec3 vNormal;
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const flowFrag = `
            uniform float uTime;
            uniform vec3 uColor;
            varying vec2 vUv;
            varying vec3 vNormal;

            void main() {
                // Racing light effect
                float flow = sin(vUv.y * 30.0 - uTime * 15.0);
                float intensity = smoothstep(0.8, 1.0, flow);
                
                vec3 baseColor = vec3(0.05, 0.05, 0.05); // Dark base
                vec3 lightColor = uColor * 2.0; // Bright light
                
                vec3 finalColor = mix(baseColor, lightColor, intensity);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        const matFlow = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0xffffff) }
            },
            vertexShader: flowVert,
            fragmentShader: flowFrag
        });

        // --- BODY CONSTRUCTION ---
        
        // 1. Torso (Sleek, Angular)
        const torsoGeo = new THREE.CylinderGeometry(0.4, 0.2, 1.2, 5);
        const torso = new THREE.Mesh(torsoGeo, matBlack);
        torso.position.y = 1.0;
        group.add(torso);
        
        // Chest Plate (Gold Trim)
        const chestGeo = new THREE.BoxGeometry(0.6, 0.5, 0.3);
        const chest = new THREE.Mesh(chestGeo, matGold);
        chest.position.set(0, 1.3, 0.15);
        group.add(chest);
        
        // Flow Lines on Torso
        const flowStrip = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.0, 0.45), matFlow);
        flowStrip.position.set(0, 1.0, 0);
        group.add(flowStrip);

        // 2. Head (Jackal Shape)
        const headGroup = new THREE.Group();
        headGroup.position.y = 1.7;
        group.add(headGroup);
        
        // Snout
        const snoutGeo = new THREE.ConeGeometry(0.15, 0.5, 4);
        const snout = new THREE.Mesh(snoutGeo, matBlack);
        snout.rotation.x = -Math.PI / 2;
        snout.position.z = 0.25;
        headGroup.add(snout);
        
        // Cranium
        const cranium = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.4), matBlack);
        headGroup.add(cranium);
        
        // Ears (Tall, Pointy)
        const earGeo = new THREE.ConeGeometry(0.08, 0.6, 4);
        const earL = new THREE.Mesh(earGeo, matGold);
        earL.position.set(0.15, 0.4, -0.1);
        earL.rotation.z = -0.2;
        earL.rotation.x = -0.2;
        headGroup.add(earL);
        
        const earR = new THREE.Mesh(earGeo, matGold);
        earR.position.set(-0.15, 0.4, -0.1);
        earR.rotation.z = 0.2;
        earR.rotation.x = -0.2;
        headGroup.add(earR);
        
        // Eyes (Glowing White)
        const eyeGeo = new THREE.BoxGeometry(0.05, 0.02, 0.1);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
        eyeL.position.set(0.1, 0.05, 0.2);
        eyeL.rotation.y = 0.2;
        headGroup.add(eyeL);
        
        const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
        eyeR.position.set(-0.1, 0.05, 0.2);
        eyeR.rotation.y = -0.2;
        headGroup.add(eyeR);

        // 3. Limbs (Long, Thin, Sharp)
        const limbGeo = new THREE.BoxGeometry(0.15, 1.2, 0.15);
        
        // Legs
        const legL = new THREE.Mesh(limbGeo, matBlack);
        legL.position.set(0.2, 0.0, 0);
        group.add(legL);
        
        const legR = new THREE.Mesh(limbGeo, matBlack);
        legR.position.set(-0.2, 0.0, 0);
        group.add(legR);
        
        // Arms
        const armL = new THREE.Mesh(limbGeo, matBlack);
        armL.position.set(0.5, 1.0, 0);
        armL.rotation.z = -0.2;
        group.add(armL);
        
        const armR = new THREE.Mesh(limbGeo, matBlack);
        armR.position.set(-0.5, 1.0, 0);
        armR.rotation.z = 0.2;
        group.add(armR);
        
        // Flow lines on limbs
        const limbFlow = new THREE.Mesh(new THREE.BoxGeometry(0.05, 1.0, 0.16), matFlow);
        legL.add(limbFlow.clone());
        legR.add(limbFlow.clone());
        armL.add(limbFlow.clone());
        armR.add(limbFlow.clone());

        // 4. TECH MECH ARCH ANGEL WINGS
        // Large, segmented, articulated binders
        const wingGroup = new THREE.Group();
        wingGroup.position.set(0, 1.4, -0.3);
        group.add(wingGroup);
        
        const createWing = (side, angle) => {
            const w = new THREE.Group();
            
            // Main blade
            const bladeGeo = new THREE.BoxGeometry(0.1, 2.5, 0.5);
            const blade = new THREE.Mesh(bladeGeo, matBlack);
            blade.position.y = 1.0;
            w.add(blade);
            
            // Gold Edge
            const edge = new THREE.Mesh(new THREE.BoxGeometry(0.12, 2.5, 0.1), matGold);
            edge.position.set(0, 1.0, 0.25);
            w.add(edge);
            
            // Flow Core
            const core = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.0, 0.3), matFlow);
            core.position.y = 1.0;
            w.add(core);
            
            w.rotation.z = angle * side;
            w.rotation.x = 0.3; // Tilt back
            return w;
        };
        
        // 4 Wings (X shape)
        const w1 = createWing(1, 0.5); // Upper Left
        w1.position.x = 0.2;
        wingGroup.add(w1);
        
        const w2 = createWing(-1, 0.5); // Upper Right
        w2.position.x = -0.2;
        wingGroup.add(w2);
        
        const w3 = createWing(1, 2.5); // Lower Left
        w3.position.x = 0.2;
        w3.scale.set(0.8, 0.8, 0.8);
        wingGroup.add(w3);
        
        const w4 = createWing(-1, 2.5); // Lower Right
        w4.position.x = -0.2;
        w4.scale.set(0.8, 0.8, 0.8);
        wingGroup.add(w4);
        
        // Store references for animation
        group.userData.wings = [w1, w2, w3, w4];
        group.userData.matFlow = matFlow; // Access to update time

        // 5. Weapon: Tech Staff
        const staffGeo = new THREE.CylinderGeometry(0.05, 0.05, 3.0);
        const staff = new THREE.Mesh(staffGeo, matGold);
        staff.rotation.z = Math.PI / 2;
        // Attach to right arm
        armR.add(staff);
        staff.position.set(0, -0.6, 0.5); // Hand position
        staff.rotation.x = Math.PI/2;
        
        // EXPOSE STAFF FOR ANIMATION
        group.userData.staff = staff;

        return group;
    }
}</script> 
    <script>/**
 * HIGH PERFORMANCE PARTICLE SYSTEM - HERCULEAN OPTIMIZATION
 * Uses GPU Instancing to render thousands of particles with 1 draw call.
 * Optimized with High-Water Mark to reduce CPU cycles on low particle counts.
 */
class InstancedParticleSystem {
    constructor(scene, maxParticles = 1000, geometry, material) {
        this.maxParticles = maxParticles;
        this.count = 0;
        this.highWaterMark = 0; // Optimization: Only iterate up to this index until wrap
        this.hasWrapped = false;
        
        // Arrays to store particle state CPU-side
        this.positions = new Float32Array(maxParticles * 3);
        this.velocities = new Float32Array(maxParticles * 3);
        
        // Rotation State (Euler)
        this.rotations = new Float32Array(maxParticles * 3);
        this.rotVelocities = new Float32Array(maxParticles * 3);
        
        this.lives = new Float32Array(maxParticles);
        this.gravities = new Float32Array(maxParticles);
        this.scales = new Float32Array(maxParticles);
        this.growRates = new Float32Array(maxParticles); 
        this.bounciness = new Float32Array(maxParticles); 
        this.drags = new Float32Array(maxParticles); // NEW: Air resistance

        // The Instanced Mesh
        this.mesh = new THREE.InstancedMesh(geometry, material, maxParticles);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        
        // Initialize off-screen
        this.dummy = new THREE.Object3D();
        for (let i = 0; i < maxParticles; i++) {
            this.dummy.position.set(0, -500, 0);
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
            this.lives[i] = 0;
        }
        
        scene.add(this.mesh);
    }

    spawn(pos, vel, colorHex, life, gravity = 0, size = 1.0, grow = 0, bounce = 0, rotVel = null, drag = 0) {
        let idx = this.count % this.maxParticles;
        
        // Update High Water Mark for loop optimization
        if (!this.hasWrapped) {
            this.highWaterMark = Math.max(this.highWaterMark, idx + 1);
            if (this.count >= this.maxParticles) this.hasWrapped = true;
        }

        this.count++;

        const i3 = idx * 3;
        this.positions[i3] = pos.x;
        this.positions[i3 + 1] = pos.y;
        this.positions[i3 + 2] = pos.z;

        this.velocities[i3] = vel.x;
        this.velocities[i3 + 1] = vel.y;
        this.velocities[i3 + 2] = vel.z;

        // Random initial rotation
        this.rotations[i3] = Math.random() * Math.PI * 2;
        this.rotations[i3 + 1] = Math.random() * Math.PI * 2;
        this.rotations[i3 + 2] = Math.random() * Math.PI * 2;

        if (rotVel) {
            this.rotVelocities[i3] = rotVel.x;
            this.rotVelocities[i3 + 1] = rotVel.y;
            this.rotVelocities[i3 + 2] = rotVel.z;
        } else {
            this.rotVelocities[i3] = 0;
            this.rotVelocities[i3 + 1] = 0;
            this.rotVelocities[i3 + 2] = 0;
        }

        this.lives[idx] = life;
        this.gravities[idx] = gravity;
        this.scales[idx] = size;
        this.growRates[idx] = grow;
        this.bounciness[idx] = bounce;
        this.drags[idx] = drag;

        // Set Color
        const col = new THREE.Color(colorHex);
        this.mesh.setColorAt(idx, col);
        this.mesh.instanceColor.needsUpdate = true;
        
        // Initial Matrix Update
        this.dummy.position.copy(pos);
        this.dummy.rotation.set(this.rotations[i3], this.rotations[i3+1], this.rotations[i3+2]);
        this.dummy.scale.set(size, size, size);
        this.dummy.updateMatrix();
        this.mesh.setMatrixAt(idx, this.dummy.matrix);
        this.mesh.instanceMatrix.needsUpdate = true;
    }

    update(dt) {
        let active = false;
        
        // Optimization: Only iterate up to the highest active particle index if we haven't wrapped buffer yet
        const limit = this.hasWrapped ? this.maxParticles : this.highWaterMark;

        for (let i = 0; i < limit; i++) {
            if (this.lives[i] > 0) {
                active = true;
                this.lives[i] -= dt;

                if (this.lives[i] <= 0) {
                    // Kill
                    this.dummy.position.set(0, -500, 0);
                    this.dummy.scale.set(0,0,0);
                    this.dummy.updateMatrix();
                    this.mesh.setMatrixAt(i, this.dummy.matrix);
                    continue;
                }

                // Physics
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // Gravity
                this.velocities[iy] -= this.gravities[i] * dt;
                
                // Drag
                if (this.drags[i] > 0) {
                    const dragFactor = 1.0 - (this.drags[i] * dt);
                    this.velocities[ix] *= dragFactor;
                    this.velocities[iy] *= dragFactor;
                    this.velocities[iz] *= dragFactor;
                }

                // Move
                this.positions[ix] += this.velocities[ix] * dt;
                this.positions[iy] += this.velocities[iy] * dt;
                this.positions[iz] += this.velocities[iz] * dt;

                // Floor Collision
                if (this.bounciness[i] > 0 && this.positions[iy] < 0.05) {
                    this.positions[iy] = 0.05;
                    this.velocities[iy] *= -this.bounciness[i]; // Reflect Y
                    
                    // Add some friction on bounce
                    this.velocities[ix] *= 0.6; 
                    this.velocities[iz] *= 0.6; 
                    
                    // Damping rotation on floor hit
                    this.rotVelocities[ix] *= 0.5;
                    this.rotVelocities[iz] *= 0.5;
                }

                // Rotation
                this.rotations[ix] += this.rotVelocities[ix] * dt;
                this.rotations[iy] += this.rotVelocities[iy] * dt;
                this.rotations[iz] += this.rotVelocities[iz] * dt;

                // Scale / Grow / Shrink
                if (this.growRates[i] !== 0) {
                    this.scales[i] += this.growRates[i] * dt;
                } else {
                    // Default shrink
                    this.scales[i] *= 0.95; 
                }

                // Update Matrix
                this.dummy.position.set(this.positions[ix], this.positions[iy], this.positions[iz]);
                this.dummy.rotation.set(this.rotations[ix], this.rotations[iy], this.rotations[iz]);
                this.dummy.scale.set(this.scales[i], this.scales[i], this.scales[i]);
                
                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(i, this.dummy.matrix);
            }
        }

        if (active) {
            this.mesh.instanceMatrix.needsUpdate = true;
        }
    }
}

/**
 * CYBERPUNK RAIN SYSTEM
 * Uses elongated geometry for speed streaks.
 */
class RainSystem {
    constructor(scene, count = 1000) {
        const geo = new THREE.BoxGeometry(0.05, 2.0, 0.05);
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0x00f3ff, 
            transparent: true, 
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        
        this.mesh = new THREE.InstancedMesh(geo, mat, count);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(this.mesh);
        
        this.count = count;
        this.dummy = new THREE.Object3D();
        this.positions = new Float32Array(count * 3);
        this.speeds = new Float32Array(count);
        
        for(let i=0; i<count; i++) {
            this.positions[i*3] = (Math.random() - 0.5) * 100;
            this.positions[i*3+1] = Math.random() * 60;
            this.positions[i*3+2] = (Math.random() - 0.5) * 100;
            this.speeds[i] = 40 + Math.random() * 20;
        }
    }
    
    update(dt) {
        for(let i=0; i<this.count; i++) {
            const ix = i*3;
            const iy = i*3+1;
            const iz = i*3+2;
            
            this.positions[iy] -= this.speeds[i] * dt;
            
            if (this.positions[iy] < 0) {
                // Splash!
                if (Math.random() > 0.9 && window.flux && window.flux.spawnParticles) {
                    // const splashPos = new THREE.Vector3(this.positions[ix], 0.1, this.positions[iz]);
                    // Reuse spark particles for splash, but blue
                    // We need to access the global particle system, which is tricky here without reference.
                    // For now, just reset.
                }
                
                this.positions[iy] = 60;
                this.positions[ix] = (Math.random() - 0.5) * 100; // Randomize X/Z on reset
                this.positions[iz] = (Math.random() - 0.5) * 100;
            }
            
            this.dummy.position.set(this.positions[ix], this.positions[iy], this.positions[iz]);
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
        }
        this.mesh.instanceMatrix.needsUpdate = true;
    }
}</script> 
    <script>/**
 * AUDIO SYSTEM - FILE BASED IMPLEMENTATION
 * Implements the complete sound manifest provided by the user.
 * Handles loading, decoding, and playback of external audio assets.
 * UPDATED: Added BGM Support with Crossfading.
 * UPDATED: Rebalanced Audio Mix (Louder Music, Softer SFX).
 * UPDATED: Added Anubis Theme.
 */

const SOUND_FILES = {
    // --- BGM ---
    "bgm_standard": "https://files.catbox.moe/soip1t.mp3",
    "bgm_boss": "https://files.catbox.moe/koldqe.mp3",
    "bgm_anubis": "https://files.catbox.moe/35oj1g.mp3", // NEW ANUBIS THEME

    // --- NEW USER ASSETS (FROM IMAGE) ---
    "Sabre1": "https://files.catbox.moe/49g9xj.mp3", // Sabre1.mp3
    "Sabre2": "https://files.catbox.moe/zsxozo.mp3", // Sabre2.mp3
    "Sabre3": "https://files.catbox.moe/mvuf6h.mp3", // Sabre3.mp3
    "Homing_travel": "https://files.catbox.moe/n9iqnk.mp3", // Homing_travel.mp3
    "lockon_set": "https://files.catbox.moe/fa7a8a.mp3", // lockon_set.mp3
    "Lockon_switch": "https://files.catbox.moe/xbmdc5.mp3", // Lockon_switch.mp3
    "missile_deploy": "https://files.catbox.moe/6il623.mp3", // missile_deploy.mp3
    "Slashclimb": "https://files.catbox.moe/mcjk87.mp3", // Slashclimb.mp3
    "Drone_explode": "https://files.catbox.moe/4fsb3d.mp3", // Drone_explode.mp3
    "dash_new": "https://files.catbox.moe/6eymr8.mp3", // dash.mp3
    "Tele_": "https://files.catbox.moe/yw0ngd.mp3", // Tele_.mp3
    "metal_scrape": "https://files.catbox.moe/idvqzl.mp3", // metal_scrape.mp3

    // --- LEGACY / UI ASSETS ---
    "Combat_MechDroneEnemy_OnEvent_PSMK": "https://files.catbox.moe/kkcg70.mp3", // Flesh hit
    "Physics_StaticGroup_OnEvent_RQK0": "https://files.catbox.moe/20wqm9.mp3", // Wall hit / Land
    "Physics_ExplosiveBarrel_OnEvent_DE9D": "https://files.catbox.moe/wdxmed.mp3", // Heavy Impact
    "Combat_PlayerWeapon_OnEvent_67DJ": "https://files.catbox.moe/ve3zlt.mp3", // Shotgun
    "Combat_PlayerWeapon_OnEvent_89PI": "https://files.catbox.moe/awsvoq.mp3", // Reload
    "UI_btnswitch_OnClick_BBEU": "https://files.catbox.moe/sojfe8.mp3", // Switch
    "UI_damageparry_OnMount_S6ST": "https://files.catbox.moe/n2lkxz.mp3", // Block/Parry
    "Flux_GameEngine_OnEffectSt_BA5Q": "https://files.catbox.moe/w5n8k9.mp3", // Charge
    "UI_loadingscreen_OnClick_7K2W": "https://files.catbox.moe/jgdsmh.mp3", // Startup
    "UI_gameoverscreen_OnMount_4U7H": "https://files.catbox.moe/uas5sx.mp3", // Death
    "UI_btnjump_OnClick_0GBP": "https://files.catbox.moe/fs2c1p.mp3", // UI Click
    "UI_FloatingText_OnMount_KUPV": "https://files.catbox.moe/tpzzgj.mp3", // UI Hover
    "Physics_Player_OnEvent_ZF5G": "https://files.catbox.moe/ko1klv.mp3" // Legacy Jump/Step
};

// Map logical game events to specific sound files
const SOUND_MAP = {
    'slash_light': 'Sabre1',
    'slash_heavy': 'Sabre2',
    'slash_finisher': 'Sabre3',
    'launcher': 'Slashclimb',
    'dash': 'dash_new',
    'teleport': 'Tele_',
    'lock': 'lockon_set',
    'lock_switch': 'Lockon_switch',
    'laser_fire': 'missile_deploy', // The "shoot out" sound
    'laser_travel': 'Homing_travel',
    'drone_death': 'Drone_explode',
    'run_loop': 'metal_scrape',
    'jump': 'Physics_Player_OnEvent_ZF5G', // RESTORED LEGACY JUMP
    
    // Legacy Mappings
    'shotgun': 'Combat_PlayerWeapon_OnEvent_67DJ',
    'wall_run': 'Physics_StaticGroup_OnEvent_RQK0',
    'land_heavy': 'Physics_ExplosiveBarrel_OnEvent_DE9D',
    'hit_flesh': 'Combat_MechDroneEnemy_OnEvent_PSMK',
    'hit_wall': 'Physics_StaticGroup_OnEvent_RQK0',
    'switch': 'UI_btnswitch_OnClick_BBEU',
    'reload': 'Combat_PlayerWeapon_OnEvent_89PI',
    'block': 'UI_damageparry_OnMount_S6ST',
    'charge': 'Flux_GameEngine_OnEffectSt_BA5Q',
    'massive_impact': 'Physics_ExplosiveBarrel_OnEvent_DE9D',
    'startup': 'UI_loadingscreen_OnClick_7K2W',
    'death': 'UI_gameoverscreen_OnMount_4U7H',
    'ui_hover': 'UI_FloatingText_OnMount_KUPV',
    'ui_click': 'UI_btnjump_OnClick_0GBP',
    'step': 'Physics_Player_OnEvent_ZF5G'
};

class AudioSystem {
    constructor() {
        const AudioCtor = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioCtor();
        
        // --- MASTER CHAIN ---
        this.out = this.ctx.destination;

        // 1. Master Compressor (Gentle)
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -20;
        this.compressor.knee.value = 40;
        this.compressor.ratio.value = 8;
        this.compressor.attack.value = 0.01;
        this.compressor.release.value = 0.25;
        
        // 2. Global Lowpass (Softener)
        this.globalFilter = this.ctx.createBiquadFilter();
        this.globalFilter.type = 'lowpass';
        this.globalFilter.frequency.value = 12000; // Cut extreme highs
        this.globalFilter.Q.value = 0.5;

        // 3. Master Gain
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.8; // Increased Master Volume slightly

        // Chain
        this.compressor.connect(this.globalFilter);
        this.globalFilter.connect(this.masterGain);
        this.masterGain.connect(this.out);

        this.enabled = false;
        this.isMuted = false;
        
        this.buffers = {};
        this.activeLoops = {}; // Store active loop nodes
        
        // BGM State
        this.currentBgmSource = null;
        this.currentBgmGain = null;
        this.currentBgmKey = null;
    }

    async init() {
        console.log("AudioSystem: Initializing...");
        if (this.ctx.state === 'suspended') {
            await this.ctx.resume();
        }
        
        await this.loadSounds();
        
        this.enabled = true;
        console.log(`AudioSystem: ONLINE (State: ${this.ctx.state})`);
        
        // Play initialization sound if available
        this.play('startup');
    }
    
    async loadSounds() {
        const keys = Object.keys(SOUND_FILES);
        const total = keys.length;
        console.log(`AudioSystem: Loading ${total} sound files...`);
        
        const promises = keys.map(async (key) => {
            try {
                const response = await fetch(SOUND_FILES[key]);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                this.buffers[key] = audioBuffer;
            } catch (e) {
                console.warn(`AudioSystem: Failed to load ${key}:`, e);
            }
        });
        
        await Promise.all(promises);
        console.log("AudioSystem: All sounds loaded.");
    }

    setSlowMo(scale) {
        if (!this.enabled || !this.globalFilter) return;
        // Muffle sound in slow mo
        const targetFreq = 200 + (Math.pow(scale, 2) * 11800);
        this.globalFilter.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1);
    }

    play(sfxName, variation = true) {
        if (!this.enabled || this.isMuted) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        // 1. Check if it's a mapped file sound
        const fileKey = SOUND_MAP[sfxName];
        if (fileKey && this.buffers[fileKey]) {
            this.playBuffer(this.buffers[fileKey], variation);
            return;
        }
        
        // 2. Fallback to direct key if passed
        if (this.buffers[sfxName]) {
            this.playBuffer(this.buffers[sfxName], variation);
            return;
        }

        // 3. Fallback to Synth (if file not found/loaded yet)
        this.playSynthFallback(sfxName, variation);
    }
    
    playBuffer(buffer, variation) {
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        
        // Variation (Pitch/Detune)
        if (variation) {
            const detune = (Math.random() * 200) - 100; // +/- 100 cents
            source.detune.value = detune;
        }
        
        // Gain Node for this specific sound
        const gain = this.ctx.createGain();
        // UPDATED: Lowered SFX volume base (was 0.8)
        gain.gain.value = 0.4 + (Math.random() * 0.2); 
        
        source.connect(gain);
        gain.connect(this.compressor);
        
        source.start(0);
    }

    // --- BGM SYSTEM ---
    playBGM(key, fadeTime = 1.0) {
        if (!this.enabled || this.isMuted) return;
        if (this.currentBgmKey === key) return; // Already playing this track

        console.log(`AudioSystem: Switching BGM to ${key}`);

        // 1. Fade out existing BGM
        if (this.currentBgmSource && this.currentBgmGain) {
            const oldGain = this.currentBgmGain;
            const oldSource = this.currentBgmSource;
            const t = this.ctx.currentTime;
            
            // Cancel any scheduled changes
            oldGain.gain.cancelScheduledValues(t);
            oldGain.gain.setValueAtTime(oldGain.gain.value, t);
            oldGain.gain.linearRampToValueAtTime(0, t + fadeTime);
            
            oldSource.stop(t + fadeTime);
        }

        // 2. Start new BGM
        const buffer = this.buffers[key];
        if (!buffer) {
            console.warn(`AudioSystem: BGM ${key} not found/loaded.`);
            this.currentBgmKey = null;
            this.currentBgmSource = null;
            this.currentBgmGain = null;
            return;
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;

        const gain = this.ctx.createGain();
        gain.gain.value = 0; // Start silent for fade-in

        source.connect(gain);
        // Connect BGM to master gain directly to avoid aggressive compression ducking from SFX
        gain.connect(this.masterGain); 

        source.start(0);

        // Fade In
        const t = this.ctx.currentTime;
        // UPDATED: Increased BGM Volume Target (was 0.4)
        gain.gain.linearRampToValueAtTime(0.8, t + fadeTime); 

        this.currentBgmSource = source;
        this.currentBgmGain = gain;
        this.currentBgmKey = key;
    }

    // --- LOOPING SOUNDS (e.g., Run) ---
    startLoop(sfxName) {
        if (!this.enabled || this.isMuted) return;
        if (this.activeLoops[sfxName]) return; // Already playing

        const fileKey = SOUND_MAP[sfxName];
        if (!fileKey || !this.buffers[fileKey]) return;

        const source = this.ctx.createBufferSource();
        source.buffer = this.buffers[fileKey];
        source.loop = true;

        const gain = this.ctx.createGain();
        // UPDATED: Lowered loop volume
        gain.gain.value = 0.2; 

        source.connect(gain);
        gain.connect(this.compressor);
        source.start(0);

        this.activeLoops[sfxName] = { source, gain };
    }

    stopLoop(sfxName) {
        if (this.activeLoops[sfxName]) {
            const { source, gain } = this.activeLoops[sfxName];
            
            // Fade out
            const t = this.ctx.currentTime;
            gain.gain.setValueAtTime(gain.gain.value, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            
            source.stop(t + 0.1);
            delete this.activeLoops[sfxName];
        }
    }

    // --- SYNTH FALLBACKS (Legacy support while loading) ---
    playSynthFallback(sfxName, variation) {
        const t = this.ctx.currentTime;
        try {
            switch (sfxName) {
                case 'shotgun': 
                case 'hit_wall':
                case 'hit_flesh':
                    this.synthNoise(t); 
                    break;
                case 'jump': 
                case 'dash':
                    this.synthTone(t, 150, 0.1); 
                    break;
                case 'switch': 
                case 'reload':
                    this.synthTone(t, 800, 0.05); 
                    break;
            }
        } catch (e) {
            // Ignore synth errors
        }
    }
    
    synthNoise(t) {
        const bufferSize = this.ctx.sampleRate * 0.2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.3, t); // Lowered synth volume
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
        src.connect(g);
        g.connect(this.compressor);
        src.start(t);
    }
    
    synthTone(t, freq, dur) {
        const osc = this.ctx.createOscillator();
        osc.frequency.setValueAtTime(freq, t);
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.1, t); // Lowered synth volume
        g.gain.linearRampToValueAtTime(0, t + dur);
        osc.connect(g);
        g.connect(this.compressor);
        osc.start(t);
        osc.stop(t + dur);
    }
}</script> 
    <script>/**
 * INPUT SYSTEM
 * Handles Virtual Joystick, Touch Buttons, and Gestures (K-Style)
 * UPDATED: Added Swipe Gestures (Up=Jump, Down=Reload) per Technical Report
 * UPDATED: Added 'tech' action support for Smart Macros
 * UPDATED: Respects UI Edit Mode (disables game input when editing)
 * UPDATED: Advanced Gyro Control (Ratcheting & LPF)
 * UPDATED: Added Drag & Drop support for UI Edit Mode
 */
class InputSystem {
    constructor() {
        this.moveVector = { x: 0, y: 0 }; // Left Stick
        this.lookVector = { x: 0, y: 0 }; // Right Stick
        this.gyroVector = { x: 0, y: 0 }; // Gyro Delta
        
        this.gyroEnabled = false;
        this.gyroRatcheting = false; // True when "lifting mouse" (holding ratchet button)
        
        // Gyro State & Filtering
        this.lastGyro = { alpha: 0, beta: 0, gamma: 0 };
        this.gyroFilter = { x: 0, y: 0 }; // LPF State
        this.gyroAlpha = 0.5; // LPF Strength (0.0 = infinite lag, 1.0 = raw input)
        
        this.actions = {
            jump: false,
            dash: false,
            attack: false,
            block: false,
            switch: false,
            reload: false,
            style: false,
            lock: false, 
            'cam-switch': false,
            gyro: false,
            tech: false // New Technique Modifier (Used for Ratcheting)
        };

        // DOM Elements
        this.controlsZone = document.getElementById('controls');
        
        // Left Joystick (Movement)
        this.joyLeft = {
            zone: document.getElementById('joystick-zone-left'),
            knob: document.getElementById('joystick-knob-left'),
            center: { x: 0, y: 0 },
            touchId: null,
            active: false
        };

        // Right Joystick (Camera)
        this.joyRight = {
            zone: document.getElementById('joystick-zone-right'),
            knob: document.getElementById('joystick-knob-right'),
            center: { x: 0, y: 0 },
            touchId: null,
            active: false
        };
        
        // Swipe Tracking
        this.swipeTracker = {
            active: false,
            touchId: null,
            startX: 0,
            startY: 0,
            startTime: 0
        };

        this.maxRadius = 40;
        this.swipeThreshold = 30; // Pixels
        this.swipeTimeLimit = 300; // ms

        // UI EDIT MODE STATE
        this.isEditMode = false;
        this.draggedElement = null;
        this.dragOffset = { x: 0, y: 0 };

        if (this.controlsZone) {
            this.initTouchControls();
        } else {
            console.warn("InputSystem: Controls DOM element not found.");
        }
        
        this.initButtons();
        this.initKeyboard();
        
        // Bind Gyro Handler
        this.handleOrientation = this.handleOrientation.bind(this);
    }

    setEditMode(enabled) {
        this.isEditMode = enabled;
        if (enabled) {
            document.body.classList.add('ui-edit-mode');
        } else {
            document.body.classList.remove('ui-edit-mode');
        }
    }

    initTouchControls() {
        this.controlsZone.addEventListener('touchstart', (e) => {
            if (this.isEditMode) return; // Handled by button listeners if dragging, or ignored
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                this.handleTouchStart(e.changedTouches[i]);
            }
        }, { passive: false });

        this.controlsZone.addEventListener('touchmove', (e) => {
            if (this.isEditMode) {
                e.preventDefault();
                if (this.draggedElement) {
                    const touch = e.changedTouches[0];
                    this.handleDragMove(touch.clientX, touch.clientY);
                }
                return;
            }
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                this.handleTouchMove(e.changedTouches[i]);
            }
        }, { passive: false });

        const endTouch = (e) => {
            if (this.isEditMode) {
                e.preventDefault();
                if (this.draggedElement) {
                    this.draggedElement = null;
                }
                return;
            }
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                this.handleTouchEnd(e.changedTouches[i]);
            }
        };

        this.controlsZone.addEventListener('touchend', endTouch);
        this.controlsZone.addEventListener('touchcancel', endTouch);
        
        // Mouse support for Dragging in Edit Mode
        window.addEventListener('mousemove', (e) => {
            if (this.isEditMode && this.draggedElement) {
                e.preventDefault();
                this.handleDragMove(e.clientX, e.clientY);
            }
        });
        
        window.addEventListener('mouseup', (e) => {
            if (this.isEditMode && this.draggedElement) {
                this.draggedElement = null;
            }
        });
    }

    handleDragMove(clientX, clientY) {
        if (!this.draggedElement) return;
        
        const x = clientX - this.dragOffset.x;
        const y = clientY - this.dragOffset.y;
        
        // Update position (convert to bottom/right or top/left depending on existing styles? 
        // Simplest is to set left/top and clear bottom/right)
        
        // However, the CSS uses bottom/right for action buttons. 
        // We need to respect the coordinate system or reset it.
        // Let's reset to top/left for simplicity during drag, 
        // but since the game uses bottom/right for layout, we should probably stick to that?
        // Actually, let's just use left/top absolute positioning for dragged elements.
        
        this.draggedElement.style.bottom = 'auto';
        this.draggedElement.style.right = 'auto';
        this.draggedElement.style.left = `${x}px`;
        this.draggedElement.style.top = `${y}px`;
    }

    handleTouchStart(touch) {
        // Ignore if touching a button
        if (touch.target && touch.target.classList.contains('btn')) return;

        const x = touch.clientX;
        const y = touch.clientY;
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left Joystick: Bottom-Left Quadrant
        if (x < width / 2 && y > height / 2) {
            if (!this.joyLeft.active) {
                this.joyLeft.active = true;
                this.joyLeft.touchId = touch.identifier;
                this.joyLeft.center = { x, y };
                
                // Show and position UI
                this.joyLeft.zone.style.left = `${x}px`;
                this.joyLeft.zone.style.top = `${y}px`;
                this.joyLeft.zone.classList.remove('hidden');
                this.joyLeft.knob.style.transform = `translate(-50%, -50%)`;
                
                this.moveVector = { x: 0, y: 0 };
            }
        } 
        // Right Joystick: Whole Right Half
        else if (x > width / 2) {
            // Check for Swipe Start (Gesture)
            // We track swipes on the right side even if joystick activates, 
            // but usually we want one or the other. 
            // Let's allow joystick to activate, but also track start pos for swipe detection on release.
            
            if (!this.joyRight.active) {
                this.joyRight.active = true;
                this.joyRight.touchId = touch.identifier;
                this.joyRight.center = { x, y };
                
                // Show and position UI
                this.joyRight.zone.style.left = `${x}px`;
                this.joyRight.zone.style.top = `${y}px`;
                this.joyRight.zone.classList.remove('hidden');
                this.joyRight.knob.style.transform = `translate(-50%, -50%)`;
                
                this.lookVector = { x: 0, y: 0 };
                
                // Init Swipe Data
                this.swipeTracker.active = true;
                this.swipeTracker.touchId = touch.identifier;
                this.swipeTracker.startX = x;
                this.swipeTracker.startY = y;
                this.swipeTracker.startTime = Date.now();
            }
        }
    }

    handleTouchMove(touch) {
        if (touch.identifier === this.joyLeft.touchId) {
            this.updateJoystick(touch, this.joyLeft, (vec) => { this.moveVector = vec; });
        } else if (touch.identifier === this.joyRight.touchId) {
            this.updateJoystick(touch, this.joyRight, (vec) => { this.lookVector = vec; });
        }
    }

    handleTouchEnd(touch) {
        if (touch.identifier === this.joyLeft.touchId) {
            this.joyLeft.active = false;
            this.joyLeft.touchId = null;
            this.joyLeft.zone.classList.add('hidden');
            this.moveVector = { x: 0, y: 0 };
        } else if (touch.identifier === this.joyRight.touchId) {
            // Check for Swipe Gesture before killing joystick
            if (this.swipeTracker.active && this.swipeTracker.touchId === touch.identifier) {
                const dt = Date.now() - this.swipeTracker.startTime;
                const dx = touch.clientX - this.swipeTracker.startX;
                const dy = touch.clientY - this.swipeTracker.startY;
                
                if (dt < this.swipeTimeLimit) {
                    // It was a quick flick
                    if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > this.swipeThreshold) {
                        if (dy < 0) {
                            // Swipe UP -> Jump / Wall Jump
                            this.actions.jump = true;
                            setTimeout(() => this.actions.jump = false, 100); // Pulse
                            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("GESTURE: JUMP");
                        } else {
                            // Swipe DOWN -> Reload / Switch
                            this.actions.reload = true;
                            setTimeout(() => this.actions.reload = false, 100);
                            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("GESTURE: RELOAD");
                        }
                    }
                }
                this.swipeTracker.active = false;
            }

            this.joyRight.active = false;
            this.joyRight.touchId = null;
            this.joyRight.zone.classList.add('hidden');
            this.lookVector = { x: 0, y: 0 };
        }
    }

    updateJoystick(touch, joy, callback) {
        let dx = touch.clientX - joy.center.x;
        let dy = touch.clientY - joy.center.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > this.maxRadius) {
            const angle = Math.atan2(dy, dx);
            dx = Math.cos(angle) * this.maxRadius;
            dy = Math.sin(angle) * this.maxRadius;
        }

        // Update Visuals (Visuals follow the finger, so +dy is down on screen)
        joy.knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

        // Update Vector (-1 to 1)
        // CRITICAL FIX: Invert Y so Up is Positive (+1) and Down is Negative (-1)
        callback({
            x: dx / this.maxRadius,
            y: -(dy / this.maxRadius) 
        });
    }

    initButtons() {
        const buttons = document.querySelectorAll('.btn');
        buttons.forEach(btn => {
            const action = btn.getAttribute('data-action');
            
            // Special Handler for Gyro Toggle
            if (action === 'gyro') {
                btn.addEventListener('click', (e) => {
                    if (this.isEditMode) return;
                    e.preventDefault();
                    e.stopPropagation();
                    this.toggleGyro(btn);
                });
            }
            
            // TOUCH EVENTS
            btn.addEventListener('touchstart', (e) => {
                if (this.isEditMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.draggedElement = btn;
                    const rect = btn.getBoundingClientRect();
                    this.dragOffset = {
                        x: e.touches[0].clientX - rect.left,
                        y: e.touches[0].clientY - rect.top
                    };
                    return;
                }
                
                if (action === 'gyro') return; // Handled by click
                
                e.preventDefault();
                e.stopPropagation(); // Don't trigger joystick
                this.actions[action] = true;
                btn.style.transform = 'scale(0.9)';
                
                // Ratcheting Logic: If TECH button held, pause gyro
                if (action === 'tech') {
                    this.gyroRatcheting = true;
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("GYRO PAUSED");
                }
            }, { passive: false });

            const release = (e) => {
                if (this.isEditMode) return;
                
                if (action === 'gyro') return;

                e.preventDefault();
                e.stopPropagation();
                this.actions[action] = false;
                btn.style.transform = 'scale(1)';
                
                if (action === 'tech') {
                    this.gyroRatcheting = false;
                }
            };

            btn.addEventListener('touchend', release);
            btn.addEventListener('touchcancel', release);
            
            // MOUSE EVENTS (FOR DESKTOP/HYBRID & EDIT MODE)
            btn.addEventListener('mousedown', (e) => {
                if (this.isEditMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.draggedElement = btn;
                    const rect = btn.getBoundingClientRect();
                    this.dragOffset = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    return;
                }
                
                if (action === 'gyro') return;

                e.stopPropagation();
                this.actions[action] = true;
                btn.style.transform = 'scale(0.9)';
                
                if (action === 'tech') {
                    this.gyroRatcheting = true;
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("GYRO PAUSED");
                }
            });
            
            btn.addEventListener('mouseup', (e) => {
                if (this.isEditMode) return;
                
                if (action === 'gyro') return;

                e.stopPropagation();
                this.actions[action] = false;
                btn.style.transform = 'scale(1)';
                
                if (action === 'tech') {
                    this.gyroRatcheting = false;
                }
            });
            
            btn.addEventListener('mouseleave', (e) => {
                if (this.isEditMode) return;
                
                if (this.actions[action]) {
                    this.actions[action] = false;
                    btn.style.transform = 'scale(1)';
                    
                    if (action === 'tech') {
                        this.gyroRatcheting = false;
                    }
                }
            });
        });
    }
    
    toggleGyro(btn) {
        if (!this.gyroEnabled) {
            // Request Permission (iOS 13+)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            this.enableGyro(btn);
                        } else {
                            console.warn("Gyro permission denied");
                        }
                    })
                    .catch(console.error);
            } else {
                // Non-iOS or older device
                this.enableGyro(btn);
            }
        } else {
            this.disableGyro(btn);
        }
    }
    
    enableGyro(btn) {
        this.gyroEnabled = true;
        btn.classList.add('active');
        window.addEventListener('deviceorientation', this.handleOrientation);
        if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("GYRO: ON");
    }
    
    disableGyro(btn) {
        this.gyroEnabled = false;
        btn.classList.remove('active');
        window.removeEventListener('deviceorientation', this.handleOrientation);
        if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("GYRO: OFF");
    }
    
    handleOrientation(event) {
        if (!this.gyroEnabled) return;
        
        // Ratcheting: If button held, ignore input (allows recentering)
        if (this.gyroRatcheting) {
            // Update lastGyro so we don't jump when releasing
            this.lastGyro = { 
                alpha: event.alpha || 0, 
                beta: event.beta || 0, 
                gamma: event.gamma || 0 
            };
            return;
        }
        
        const alpha = event.alpha || 0; // Z-axis rotation (0-360)
        const beta = event.beta || 0;   // X-axis tilt (-180 to 180)
        const gamma = event.gamma || 0; // Y-axis tilt (-90 to 90)
        
        // Initialize lastGyro on first event
        if (this.lastGyro.alpha === 0 && this.lastGyro.beta === 0 && this.lastGyro.gamma === 0) {
            this.lastGyro = { alpha, beta, gamma };
            return;
        }
        
        let dAlpha = alpha - this.lastGyro.alpha;
        let dBeta = beta - this.lastGyro.beta;
        let dGamma = gamma - this.lastGyro.gamma;
        
        // Handle Alpha wrap-around (0 <-> 360)
        if (dAlpha > 180) dAlpha -= 360;
        if (dAlpha < -180) dAlpha += 360;
        
        // Sensitivity tweak
        const sens = 1.5; // Increased sensitivity for snappier aim
        
        // Raw Delta
        const rawDX = dAlpha * sens; // Yaw
        const rawDY = dGamma * sens; // Pitch
        
        // Low-Pass Filter (Smoothing)
        // y[n] = alpha * x[n] + (1 - alpha) * y[n-1]
        this.gyroFilter.x = (this.gyroAlpha * rawDX) + ((1.0 - this.gyroAlpha) * this.gyroFilter.x);
        this.gyroFilter.y = (this.gyroAlpha * rawDY) + ((1.0 - this.gyroAlpha) * this.gyroFilter.y);
        
        // Accumulate filtered deltas
        this.gyroVector.x += this.gyroFilter.x;
        this.gyroVector.y += this.gyroFilter.y;
        
        this.lastGyro = { alpha, beta, gamma };
    }
    
    getGyroDelta() {
        const d = { x: this.gyroVector.x, y: this.gyroVector.y };
        this.gyroVector = { x: 0, y: 0 }; // Reset after reading
        return d;
    }

    initKeyboard() {
        const keyState = { w:0, a:0, s:0, d:0 };
        const arrowState = { up:0, down:0, left:0, right:0 };
        
        const updateKeys = () => {
            // CRITICAL FIX: W is +1 (Up), S is -1 (Down)
            this.moveVector.y = keyState.w - keyState.s;
            this.moveVector.x = keyState.d - keyState.a;
            
            // Arrow Keys for Look
            this.lookVector.y = arrowState.up - arrowState.down;
            this.lookVector.x = arrowState.right - arrowState.left;
        };

        window.addEventListener('keydown', (e) => {
            if (this.isEditMode) return;
            switch(e.code) {
                case 'KeyW': keyState.w = 1; break;
                case 'KeyS': keyState.s = 1; break;
                case 'KeyA': keyState.a = 1; break;
                case 'KeyD': keyState.d = 1; break;
                
                case 'ArrowUp': arrowState.up = 1; break;
                case 'ArrowDown': arrowState.down = 1; break;
                case 'ArrowLeft': arrowState.left = 1; break;
                case 'ArrowRight': arrowState.right = 1; break;

                case 'Space': this.actions.jump = true; break;
                case 'ShiftLeft': this.actions.dash = true; break;
                case 'KeyJ': this.actions.attack = true; break;
                case 'KeyK': this.actions.block = true; break;
                case 'KeyQ': this.actions.switch = true; break;
                case 'KeyE': this.actions.switch = true; break;
                case 'KeyR': this.actions.reload = true; break;
                case 'KeyT': this.actions.style = true; break; 
                case 'KeyL': this.actions.lock = true; break; 
                case 'KeyP': this.actions['cam-switch'] = true; break; 
                case 'KeyF': 
                    this.actions.tech = true; 
                    this.gyroRatcheting = true; // Keyboard ratchet support
                    break;
                case 'Escape':
                    // Toggle Menu via Keyboard (Optional)
                    const menuBtn = document.getElementById('btn-menu');
                    if (menuBtn) menuBtn.click();
                    break;
            }
            updateKeys();
        });

        window.addEventListener('keyup', (e) => {
            if (this.isEditMode) return;
            switch(e.code) {
                case 'KeyW': keyState.w = 0; break;
                case 'KeyS': keyState.s = 0; break;
                case 'KeyA': keyState.a = 0; break;
                case 'KeyD': keyState.d = 0; break;
                
                case 'ArrowUp': arrowState.up = 0; break;
                case 'ArrowDown': arrowState.down = 0; break;
                case 'ArrowLeft': arrowState.left = 0; break;
                case 'ArrowRight': arrowState.right = 0; break;

                case 'Space': this.actions.jump = false; break;
                case 'ShiftLeft': this.actions.dash = false; break;
                case 'KeyJ': this.actions.attack = false; break;
                case 'KeyK': this.actions.block = false; break;
                case 'KeyQ': this.actions.switch = false; break;
                case 'KeyE': this.actions.switch = false; break;
                case 'KeyR': this.actions.reload = false; break;
                case 'KeyT': this.actions.style = false; break;
                case 'KeyL': this.actions.lock = false; 
                case 'KeyP': this.actions['cam-switch'] = false; break; 
                case 'KeyF': 
                    this.actions.tech = false; 
                    this.gyroRatcheting = false;
                    break;
            }
            updateKeys();
        });
    }

    consumeAction(actionName) {
        if (this.actions[actionName]) {
            return true;
        }
        return false;
    }
}</script>
    <script>/**
 * PLAYER MESH GENERATOR - "ORBITAL FRAME: JEHUTY TYPE"
 * High-Fidelity Mecha Construction.
 * UPDATED: Implemented "Magic Neon Shell" Shader - Solid Transparent Neon
 * UPDATED: Added Persistent Energy Shield Mesh (Enlarged & Repositioned)
 * UPDATED: Added createStandalone for Bestiary
 */
class PlayerMesh {
    static build(player) {
        const scene = player.scene;
        
        // --- MAIN CONTAINER ---
        player.mesh = new THREE.Group();
        player.mesh.position.y = 5; 
        player.mesh.rotation.y = Math.PI; 
        scene.add(player.mesh);

        // --- VISUAL ROOT (For tilting/bobbing) ---
        player.visualGroup = new THREE.Group();
        player.mesh.add(player.visualGroup);

        // Create the actual mesh structure
        this.createMeshStructure(player, player.visualGroup);
    }

    // New helper to create the mesh without binding to a Player instance's physics properties
    // Used for both the main player and the Bestiary
    static createMeshStructure(context, rootGroup) {
        // --- MATERIALS (Magic Shell Shader) ---
        
        const matCapBlue = TextureGen.createMatCap(256, '#007799', '#001122');
        const matCapDark = TextureGen.createMatCap(256, '#222222', '#000000');
        const matCapFrame = TextureGen.createMatCap(256, '#444444', '#111111');
        
        const magicShellVert = `
            varying vec2 vUv;
            varying vec3 vViewPosition;
            varying vec3 vNormal;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const magicShellFrag = `
            uniform sampler2D tMatCap;
            uniform float uTime;
            uniform float uReveal; // 0.0 = Ghost/Faint, 1.0 = Solid Neon
            uniform vec3 uColor;
            uniform vec3 uGlowColor;
            
            varying vec2 vUv;
            varying vec3 vViewPosition;
            varying vec3 vNormal;
            
            void main() {
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = pow(1.0 - max(0.0, dot(viewDir, vNormal)), 2.0);
                
                vec3 baseColor = uColor * 0.4; 
                float baseAlpha = 0.3 + (uReveal * 0.5); 
                
                vec3 rimColor = uGlowColor * fresnel * 2.0;
                vec3 finalColor = baseColor + rimColor;
                
                float pulse = 0.9 + 0.1 * sin(uTime * 3.0);
                finalColor *= pulse;
                
                float finalAlpha = baseAlpha + (fresnel * 0.8);
                finalAlpha = clamp(finalAlpha, 0.0, 1.0);
                
                finalAlpha *= (0.2 + uReveal * 0.8);

                gl_FragColor = vec4(finalColor, finalAlpha);
            }
        `;

        context.matArmor = new THREE.ShaderMaterial({
            uniforms: {
                tMatCap: { value: matCapBlue },
                uTime: { value: 0 },
                uReveal: { value: 1.0 },
                uColor: { value: new THREE.Color(0x00ffff) },
                uGlowColor: { value: new THREE.Color(0x00aaff) }
            },
            vertexShader: magicShellVert,
            fragmentShader: magicShellFrag,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false, 
            blending: THREE.AdditiveBlending 
        });
        
        context.matArmorDark = new THREE.ShaderMaterial({
            uniforms: {
                tMatCap: { value: matCapDark },
                uTime: { value: 0 },
                uReveal: { value: 1.0 },
                uColor: { value: new THREE.Color(0x444444) },
                uGlowColor: { value: new THREE.Color(0xffaa00) }
            },
            vertexShader: magicShellVert,
            fragmentShader: magicShellFrag,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        
        context.matFrame = new THREE.MeshMatcapMaterial({
            color: 0xffffff,
            matcap: matCapFrame
        });

        context.matMetatron = new THREE.MeshStandardMaterial({
            color: 0xff4400,
            emissive: 0xff3300,
            emissiveIntensity: 4.0,
            roughness: 0.1,
            metalness: 1.0
        });

        context.matEnergy = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });

        context.matBlade = new THREE.MeshStandardMaterial({ 
            color: 0x00ffff, 
            emissive: 0x00ffff,
            emissiveIntensity: 2.0,
            transparent: true,
            opacity: 0.9,
            metalness: 0.1,
            roughness: 0.0
        });

        // --- HIPS ---
        context.hips = new THREE.Group();
        context.hips.position.y = 1.4; 
        rootGroup.add(context.hips);
        
        const hipGeo = new THREE.BoxGeometry(0.35, 0.5, 0.4);
        const hipMesh = new THREE.Mesh(hipGeo, context.matArmor);
        const pos = hipMesh.geometry.attributes.position;
        for(let i=0; i<pos.count; i++) {
            if(pos.getY(i) < 0) {
                pos.setX(i, pos.getX(i) * 0.4);
                pos.setZ(i, pos.getZ(i) * 0.4);
            }
        }
        hipMesh.geometry.computeVertexNormals();
        context.hips.add(hipMesh);
        
        const hipLine = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 0.42), context.matMetatron);
        hipLine.position.y = 0.05;
        context.hips.add(hipLine);
        PlayerMesh.addGlowShell(hipLine, 0.02, 0xff6600);

        const jointGeo = new THREE.CylinderGeometry(0.14, 0.14, 0.55, 8);
        const hipJoint = new THREE.Mesh(jointGeo, context.matFrame);
        hipJoint.rotation.z = Math.PI/2;
        context.hips.add(hipJoint);

        // --- TORSO ---
        context.spine = new THREE.Group();
        context.hips.add(context.spine);
        
        const spineLink = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.45, 8), context.matFrame);
        spineLink.position.y = 0.25;
        context.spine.add(spineLink);

        context.torso = new THREE.Group();
        context.torso.position.y = 0.5; 
        context.spine.add(context.torso);

        const chestGeo = new THREE.CylinderGeometry(0.4, 0.25, 0.6, 5);
        context.chestMesh = new THREE.Mesh(chestGeo, context.matArmor);
        context.chestMesh.position.y = 0.2;
        context.chestMesh.rotation.y = Math.PI; 
        context.chestMesh.scale.set(1, 1, 0.7);
        context.torso.add(context.chestMesh);
        
        const coreGeo = new THREE.SphereGeometry(0.12, 16, 16);
        const core = new THREE.Mesh(coreGeo, context.matMetatron);
        core.position.set(0, 0.2, 0.25);
        core.scale.set(1, 1.2, 0.5);
        context.torso.add(core);
        PlayerMesh.addGlowShell(core, 0.05, 0xff3300);
        
        const collar = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.15, 0.35), context.matArmorDark);
        collar.position.set(0, 0.55, -0.05);
        context.torso.add(collar);

        // --- HEAD ---
        context.head = new THREE.Group();
        context.head.position.y = 0.7; 
        context.torso.add(context.head);
        
        const helmGeo = new THREE.BoxGeometry(0.16, 0.2, 0.22);
        const helm = new THREE.Mesh(helmGeo, context.matArmor);
        context.head.add(helm);
        
        const chin = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.2, 4), context.matFrame);
        chin.rotation.x = Math.PI;
        chin.rotation.y = Math.PI/4;
        chin.position.set(0, -0.15, 0.05);
        context.head.add(chin);
        
        const finGeo = new THREE.BoxGeometry(0.02, 0.5, 0.4);
        const fin = new THREE.Mesh(finGeo, context.matArmor);
        fin.position.set(0, 0.25, -0.15);
        fin.rotation.x = -0.4;
        const finPos = fin.geometry.attributes.position;
        for(let i=0; i<finPos.count; i++) {
            if(finPos.getY(i) > 0) {
                finPos.setZ(i, finPos.getZ(i) * 0.1);
            }
        }
        fin.geometry.computeVertexNormals();
        context.head.add(fin);
        
        const visor = new THREE.Mesh(new THREE.BoxGeometry(0.17, 0.02, 0.16), context.matMetatron);
        visor.position.set(0, 0.02, 0.08);
        context.head.add(visor);
        PlayerMesh.addGlowShell(visor, 0.01, 0x00ff00);

        // --- BINDERS ---
        context.binderL = PlayerMesh.createBinder(context, 1);
        context.binderL.position.set(0.25, 0.3, -0.25);
        context.binderL.rotation.z = -0.3;
        context.binderL.rotation.y = 0.3;
        context.torso.add(context.binderL);

        context.binderR = PlayerMesh.createBinder(context, -1);
        context.binderR.position.set(-0.25, 0.3, -0.25);
        context.binderR.rotation.z = 0.3;
        context.binderR.rotation.y = -0.3;
        context.torso.add(context.binderR);

        // --- ARMS ---
        context.armL = new THREE.Group();
        context.armL.position.set(0.4, 0.35, 0);
        context.torso.add(context.armL);
        
        context.armR = new THREE.Group();
        context.armR.position.set(-0.4, 0.35, 0);
        context.torso.add(context.armR);
        
        PlayerMesh.buildArm(context, context.armL, 1);
        PlayerMesh.buildArm(context, context.armR, -1);

        // --- WEAPONS ---
        context.swordGroup = new THREE.Group();
        context.swordGroup.position.set(0, -0.35, 0); 
        context.armR.children[2].add(context.swordGroup); 
        
        const bladeModel = AssetFactory.createEnergyBlade(context.matBlade, context.matFrame);
        context.bladeMesh = bladeModel.children[0]; 
        context.swordGroup.add(bladeModel);

        context.handR = new THREE.Group();
        context.handR.position.set(0, -0.7, 0);
        context.armR.add(context.handR);
        
        if (typeof AssetFactory !== 'undefined') {
            context.gunGroup = AssetFactory.createAvengerShotgun(); 
            context.gunGroup.visible = false;
            context.gunGroup.scale.set(0.8, 0.8, 0.8);
            context.gunGroup.rotation.x = Math.PI/2;
            context.handR.add(context.gunGroup);
            
            context.muzzlePoint = new THREE.Object3D();
            context.muzzlePoint.position.set(0, 0.05, 1.2); 
            context.gunGroup.add(context.muzzlePoint);
        }

        // --- LEGS ---
        // Need to define thighLen/shinLen if they don't exist in context
        if (!context.thighLen) context.thighLen = 0.45;
        if (!context.shinLen) context.shinLen = 0.45;
        if (!context.hipWidth) context.hipWidth = 0.15;

        context.legL = PlayerMesh.createMechLeg(context, 1);
        context.legL.root.position.set(context.hipWidth, 0, 0);
        context.hips.add(context.legL.root);

        context.legR = PlayerMesh.createMechLeg(context, -1);
        context.legR.root.position.set(-context.hipWidth, 0, 0);
        context.hips.add(context.legR.root);

        // --- PERSISTENT SHIELD MESH ---
        PlayerMesh.createShield(context, rootGroup);

        // --- VFX ---
        PlayerMesh.createVFX(context);
    }

    // Creates a standalone mesh for Bestiary or other uses
    static createStandalone() {
        const dummyContext = {
            thighLen: 0.45,
            shinLen: 0.45,
            hipWidth: 0.15
        };
        const rootGroup = new THREE.Group();
        this.createMeshStructure(dummyContext, rootGroup);
        
        // Set default pose
        dummyContext.armL.rotation.z = 0.3;
        dummyContext.armR.rotation.z = -0.3;
        dummyContext.legL.root.rotation.x = 0.2;
        dummyContext.legR.root.rotation.x = -0.2;
        
        // Ensure shield is visible if desired, or hidden
        if (dummyContext.shieldMesh) dummyContext.shieldMesh.visible = false;
        
        return rootGroup;
    }

    static createShield(player, parentGroup) {
        const shieldGeo = new THREE.SphereGeometry(2.2, 32, 32);
        
        const shieldVert = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            varying vec2 vUv;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                vUv = uv;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const shieldFrag = `
            uniform float uTime;
            uniform float uDamage; 
            uniform vec3 uColor;
            
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            varying vec2 vUv;

            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            void main() {
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = pow(1.0 - max(0.0, dot(viewDir, vNormal)), 3.0);
                float ripple = sin(vUv.y * 20.0 - uTime * 8.0) * 0.1;
                float crack = 0.0;
                if (uDamage > 0.0) {
                    float noise = rand(vUv * 10.0);
                    if (noise < uDamage) {
                        crack = 1.0;
                    }
                }
                if (crack > 0.5) discard;
                vec3 finalColor = uColor + (fresnel * 2.0);
                finalColor += vec3(ripple);
                if (uDamage > 0.7) {
                    finalColor = mix(finalColor, vec3(1.0, 0.0, 0.0), sin(uTime * 20.0) * 0.5 + 0.5);
                }
                float alpha = 0.05 + (fresnel * 0.5);
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        player.matShield = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uDamage: { value: 0.0 },
                uColor: { value: new THREE.Color(0x00ffff) }
            },
            vertexShader: shieldVert,
            fragmentShader: shieldFrag,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });

        player.shieldMesh = new THREE.Mesh(shieldGeo, player.matShield);
        player.shieldMesh.position.y = 1.2; 
        player.shieldMesh.visible = false; 
        
        // Add to the visual group passed in (or player.visualGroup if legacy)
        if (parentGroup) {
            parentGroup.add(player.shieldMesh);
        } else if (player.visualGroup) {
            player.visualGroup.add(player.shieldMesh);
        }
    }

    static createBinder(player, side) {
        const group = new THREE.Group();
        const geo = new THREE.BoxGeometry(0.2, 1.4, 0.5);
        const housing = new THREE.Mesh(geo, player.matArmor);
        housing.position.y = 0.2;
        const pos = housing.geometry.attributes.position;
        for(let i=0; i<pos.count; i++) {
            if(pos.getY(i) > 0) {
                pos.setX(i, pos.getX(i) * 0.5);
                pos.setZ(i, pos.getZ(i) * 0.7);
            }
        }
        housing.geometry.computeVertexNormals();
        group.add(housing);
        
        const inner = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 0.4), player.matFrame);
        inner.position.y = 0.2;
        group.add(inner);
        
        const vent = new THREE.Mesh(new THREE.BoxGeometry(0.21, 0.8, 0.05), player.matMetatron);
        vent.position.set(0, 0.3, 0.25);
        group.add(vent);
        PlayerMesh.addGlowShell(vent, 0.02, 0xff3300);
        
        const flapGeo = new THREE.BoxGeometry(0.05, 0.6, 0.3);
        const flap = new THREE.Mesh(flapGeo, player.matArmor);
        flap.position.set(side * 0.15, 0, 0.1);
        group.add(flap);
        
        const nozzle = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.4, 16, 1, true), player.matFrame);
        nozzle.rotation.x = Math.PI;
        nozzle.position.y = -0.6;
        group.add(nozzle);
        
        const glow = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.6, 8), player.matEnergy);
        glow.rotation.x = Math.PI;
        glow.position.y = -0.7;
        group.add(glow);
        
        group.userData = { flap: flap };
        return group;
    }

    static buildArm(player, group, side) {
        const shoulderGeo = new THREE.SphereGeometry(0.25, 16, 16);
        const shoulder = new THREE.Mesh(shoulderGeo, player.matArmor);
        shoulder.scale.set(1, 0.8, 1);
        group.add(shoulder);
        
        const ringGeo = new THREE.TorusGeometry(0.2, 0.02, 8, 16);
        const ring = new THREE.Mesh(ringGeo, player.matMetatron);
        ring.rotation.x = Math.PI/2;
        group.add(ring);
        PlayerMesh.addGlowShell(ring, 0.02, 0xff3300);
        
        const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.06, 0.45), player.matFrame);
        upper.position.y = -0.25;
        group.add(upper);
        
        const foreGeo = new THREE.BoxGeometry(0.18, 0.45, 0.18);
        const forearm = new THREE.Mesh(foreGeo, player.matArmor);
        forearm.position.y = -0.65;
        const pos = forearm.geometry.attributes.position;
        for(let i=0; i<pos.count; i++) {
            if(pos.getY(i) < 0) {
                pos.setX(i, pos.getX(i) * 0.7);
                pos.setZ(i, pos.getZ(i) * 0.7);
            }
        }
        forearm.geometry.computeVertexNormals();
        group.add(forearm);
        
        const elbow = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.25, 4), player.matArmorDark);
        elbow.rotation.x = -Math.PI/2;
        elbow.position.set(0, -0.45, -0.12);
        group.add(elbow);
    }

    static createMechLeg(player, side) {
        const root = new THREE.Group();
        
        const thighGeo = new THREE.BoxGeometry(0.22, player.thighLen, 0.28);
        const thigh = new THREE.Mesh(thighGeo, player.matArmor);
        thigh.position.y = -player.thighLen / 2;
        root.add(thigh);
        
        const line = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.3), player.matMetatron);
        line.position.y = -player.thighLen / 2;
        root.add(line);
        PlayerMesh.addGlowShell(line, 0.02, 0xff3300);
        
        const knee = new THREE.Group();
        knee.position.y = -player.thighLen;
        root.add(knee);
        
        const kneeJoint = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.25, 12), player.matFrame);
        kneeJoint.rotation.z = Math.PI/2;
        knee.add(kneeJoint);
        
        const kneePlate = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.05), player.matArmorDark);
        kneePlate.position.set(0, 0.1, 0.15);
        knee.add(kneePlate);
        
        const shinGroup = new THREE.Group();
        knee.add(shinGroup);
        
        const shinGeo = new THREE.BoxGeometry(0.16, player.shinLen, 0.16);
        const shin = new THREE.Mesh(shinGeo, player.matArmor);
        shin.position.y = -player.shinLen / 2;
        shin.rotation.x = 0.4; 
        shin.position.z = -0.15;
        shinGroup.add(shin);
        
        const footGeo = new THREE.ConeGeometry(0.06, 0.4, 6);
        const foot = new THREE.Mesh(footGeo, player.matFrame);
        foot.rotation.x = Math.PI; 
        foot.position.set(0, -player.shinLen, 0);
        foot.position.z = -0.15 - (Math.sin(0.4) * player.shinLen); 
        foot.position.y = -player.shinLen * Math.cos(0.4);
        
        const heel = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.25, 0.04), player.matMetatron);
        heel.position.set(0, -0.1, 0.1);
        heel.rotation.x = -0.8;
        foot.add(heel);
        
        shinGroup.add(foot);

        return { root, knee, foot };
    }

    static createVFX(player) {
        const arcGeo = new THREE.RingGeometry(1.5, 3.0, 32, 1, 0, Math.PI);
        const arcMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0, 
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        player.slashTemplate = new THREE.Mesh(arcGeo, arcMat);
        player.slashTemplate.visible = false; 
        
        const coreArcGeo = new THREE.RingGeometry(1.8, 2.5, 32, 1, 0, Math.PI);
        const coreArcMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0, 
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        player.slashCoreTemplate = new THREE.Mesh(coreArcGeo, coreArcMat);
        player.slashTemplate.add(player.slashCoreTemplate);

        const spinGeo = new THREE.RingGeometry(1.5, 3.5, 32, 1, 0, Math.PI * 2);
        player.slashSpinTemplate = new THREE.Mesh(spinGeo, arcMat); 
        player.slashSpinTemplate.visible = false;
    }

    static updateWeaponVisuals(player) {
        if (!player.bladeMesh) return;
        let color = 0x00ffff;
        if (player.currentStyle === 1) color = 0x00ff00;
        if (player.currentStyle === 2) color = 0xffaa00;
        
        if (player.matBlade) player.matBlade.emissive.setHex(color);
        if (player.matBlade) player.matBlade.color.setHex(color);
    }
    
    static addGlowShell(mesh, offset, color) {
        const glowGeo = mesh.geometry.clone();
        const mat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            side: THREE.FrontSide,
            depthWrite: false
        });
        
        const glowMesh = new THREE.Mesh(glowGeo, mat);
        glowMesh.scale.multiplyScalar(1.1);
        mesh.add(glowMesh);
    }
}</script> 
    <script>/**
 * PLAYER CONTROLLER - HERCULEAN KINEMATICS UPDATE
 * Implements Physics-Based Procedural Animation & K-Style Mechanics
 * 
 * UPDATES:
 * - Added Shield Mechanics (HP, Shatter, Cooldown)
 * - Added FPS Auto-Aim (Camera lock-on)
 * - Doubled Saber Damage
 */
class Player {
    constructor(scene, staticGroup, enemyGroup) {
        this.scene = scene;
        this.staticGroup = staticGroup; 
        this.enemyGroup = enemyGroup;   
        
        // --- STATS ---
        this.maxHp = 100;
        this.hp = 100;
        this.ap = 50; 
        this.isDead = false;
        this.isFlashing = false; 
        this.isFirstPerson = false; 
        this.camPitch = 0; 
        
        // --- SHIELD SYSTEM ---
        this.shieldMaxHp = 100;
        this.shieldHp = 100;
        this.shieldCooldown = 0;
        this.shieldRegenDelay = 5.0;
        this.isShieldBroken = false;
        
        // --- MAGIC SHELL ANIMATION ---
        this.shellReveal = 1.0; // 0 = Faint, 1 = Solid Neon
        this.shellRevealSpeed = 0.5;
        
        // --- OVERDRIVE SYSTEM ---
        this.isOverdrive = false;
        this.overdriveTimer = 0;
        this.overdriveThreshold = 15; // Combo count needed

        // --- PHYSICS CONFIG (INERTIAL) ---
        this.gravity = -80; 
        this.gravityScale = 1.0; 
        
        this.acceleration = 120; 
        this.drag = 5.0;         
        this.brakingDrag = 10.0; 
        this.airDrag = 1.0;      
        
        this.moveSpeed = 24; 
        this.dashSpeed = 85; 
        this.jumpForce = 38; 
        this.wallJumpForce = 45;
        
        // Dimensions
        this.height = 2.0;
        this.radius = 0.5;
        
        // --- HOVER PID CONTROLLER ---
        this.hoverTargetHeight = 0; 
        this.hoverIntegral = 0;
        this.hoverErrorPrior = 0;
        this.hoverKP = 8.0;  
        this.hoverKI = 0.0;  
        this.hoverKD = 2.0;  
        
        // --- STATE MACHINE ---
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.onGround = false;
        this.isDashing = false;
        this.isAttacking = false;
        this.isBlocking = false;
        this.isWallRunning = false;
        this.isCharging = false;
        this.isKnockedDown = false; 
        this.landingLag = 0;
        
        // --- WEAPON STATE ---
        this.WEAPON_MELEE = 0;
        this.WEAPON_RANGED = 1; // Shotgun
        this.WEAPON_BEAM = 2;   // Beam Rifle
        this.currentWeapon = this.WEAPON_MELEE;
        this.ammo = 12; 
        this.maxAmmo = 12;
        this.fireRate = 0.5; 
        this.fireTimer = 0;
        this.isReloading = false;
        this.reloadTimer = 0;
        this.reloadDuration = 1.5;
        
        this.STYLE_KATANA = 0;
        this.STYLE_DAGGER = 1;
        this.STYLE_GREATSWORD = 2;
        this.currentStyle = this.STYLE_KATANA;
        
        // --- INPUT TRACKING & BUFFER ---
        this.inputBuffer = { action: null, time: 0 };
        this.BUFFER_WINDOW = 0.2; 
        
        this.wasJumpDown = false; 
        this.wasDashDown = false;
        this.wasAttackDown = false;
        this.wasBlockDown = false;
        this.wasSwitchDown = false;
        this.wasReloadDown = false;
        this.wasStyleDown = false;
        this.wasLockDown = false;
        this.wasCamSwitchDown = false;
        this.attackHoldTimer = 0;
        this.CHARGE_THRESHOLD = 0.35; 
        
        // --- TIMERS ---
        this.dashTime = 0;
        this.dashDuration = 0.08; 
        this.dashCooldown = 0;
        this.dashTrailTimer = 0;
        this.perfectDodgeWindow = 0; 
        
        this.jumpBufferTimer = 0;
        this.jumpBufferMax = 0.15; 
        this.coyoteTimer = 0;
        this.coyoteMax = 0.1; 
        this.wallRunSoundTimer = 0; 
        this.wasWallJump = false; 
        this.parryWindow = 0;
        
        // Wall Slash Logic
        this.canWallJump = false; 
        this.wallMagnetismTimer = 0; 
        this.lastWallNormal = new THREE.Vector3(); 
        
        // --- COMBO SYSTEM ---
        this.comboIndex = 0;
        this.comboTimer = 0;
        this.comboMaxTime = 0.8; 
        this.activeComboStep = 0;
        
        // --- ATTACK STATE ---
        this.attackTimer = 0;
        this.attackTotalDuration = 0;
        this.currentSwingId = 0;
        this.hitEnemies = new Set(); 
        this.attackType = 'GROUND'; 
        
        // --- KINEMATICS ---
        this.kinematics = {
            tiltX: { pos: 0, vel: 0, target: 0, k: 180, d: 15 }, 
            tiltZ: { pos: 0, vel: 0, target: 0, k: 180, d: 15 },
            crouch: { pos: 0, vel: 0, target: 0, k: 250, d: 20 }, 
            spineLean: { pos: 0, vel: 0, target: 0, k: 120, d: 12 },
            weaponSwayX: { pos: 0, vel: 0, target: 0, k: 100, d: 15 },
            weaponSwayY: { pos: 0, vel: 0, target: 0, k: 100, d: 15 },
            chestTwist: { pos: 0, vel: 0, target: 0, k: 150, d: 15 } 
        };

        this.animTime = 0;
        this.lastRotY = 0; 
        this.lastStepPhase = 0; 

        this.thighLen = 0.45;
        this.shinLen = 0.45;
        this.hipWidth = 0.15;
        
        // --- RAYCASTING ---
        this.raycaster = new THREE.Raycaster();
        this.downVector = new THREE.Vector3(0, -1, 0);
        this.upVector = new THREE.Vector3(0, 1, 0); 
        this.rayOrigin = new THREE.Vector3();
        this.tempVec = new THREE.Vector3();
        this.tempDir = new THREE.Vector3();
        this.tempOrigin = new THREE.Vector3();
        this.hitDirection = new THREE.Vector3();
        
        this.pelletOrigin = new THREE.Vector3();
        this.pelletDir = new THREE.Vector3();
        
        this.prevTipPos = new THREE.Vector3();
        
        // --- TARGETING ---
        this.targetEnemy = null;
        this.lockOnRange = 40;
        this.lockTimer = 0;
        
        this.currentTipPos = new THREE.Vector3();
        
        this.groundOffsets = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(this.radius * 0.8, 0, 0),
            new THREE.Vector3(-this.radius * 0.8, 0, 0),
            new THREE.Vector3(0, 0, this.radius * 0.8),
            new THREE.Vector3(0, 0, -this.radius * 0.8)
        ];
        
        this.touchingWall = false;
        this.wallNormal = new THREE.Vector3();

        this.activeSlashMesh = null;
        this.slashVelocity = new THREE.Vector3();

        if (typeof PlayerMesh !== 'undefined') {
            PlayerMesh.build(this);
        }
        
        if (typeof updateHUD === 'function') {
            updateHUD();
        }
    }

    updateSpring(spring, dt) {
        const diff = spring.target - spring.pos;
        const accel = (diff * spring.k) - (spring.vel * spring.d);
        spring.vel += accel * dt;
        spring.pos += spring.vel * dt;
    }

    checkOverdrive() {
        if (!window.flux) return;
        const combo = window.flux.comboCount || 0;
        
        if (combo >= this.overdriveThreshold && !this.isOverdrive) {
            this.isOverdrive = true;
            if (window.flux.spawnTechText) window.flux.spawnTechText("OVERDRIVE ENGAGED");
            if (window.flux.audio) window.flux.audio.play('charge');
            if (window.flux.shake) window.flux.shake(0.5);
            
            // Visuals
            if (this.matBlade) this.matBlade.emissive.setHex(0xff0055);
            if (this.matMetatron) this.matMetatron.emissive.setHex(0xff0055);
            
            // Pulse the shell
            this.shellReveal = 0.5; // Glitch effect
        } else if (combo < this.overdriveThreshold && this.isOverdrive) {
            this.isOverdrive = false;
            if (window.flux.spawnTechText) window.flux.spawnTechText("OVERDRIVE OFFLINE");
            
            // Reset Visuals
            if (this.matBlade) this.matBlade.emissive.setHex(0x00ffff);
            if (this.matMetatron) this.matMetatron.emissive.setHex(0xff3300);
        }
    }

    takeDamage(amount) {
        if (this.isDead) return;
        
        // --- PERFECT DODGE CHECK ---
        if (this.perfectDodgeWindow > 0) {
            if (window.flux && window.flux.slowMotion) window.flux.slowMotion(1.0, 0.05); // Extreme Slow Mo
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("TIME FRACTURE");
            if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 30, 0x00ffff, 30);
            if (window.flux && window.flux.spawnShockwave) window.flux.spawnShockwave(this.mesh.position);
            if (window.flux.audio) window.flux.audio.play('teleport'); 
            
            this.ap = Math.min(50, this.ap + 20); // Restore AP
            this.perfectDodgeWindow = 0; // Consume window
            
            // --- SWIVEL MECHANIC ---
            if (window.flux && window.flux.enemies) {
                let nearest = null;
                let minDist = 20.0;
                
                for (let e of window.flux.enemies) {
                    if (!e.userData.isDead) {
                        const d = e.position.distanceTo(this.mesh.position);
                        if (d < minDist) {
                            minDist = d;
                            nearest = e;
                        }
                    }
                }
                
                if (nearest) {
                    const toPlayer = new THREE.Vector3().subVectors(this.mesh.position, nearest.position).normalize();
                    const teleportDist = 5.0;
                    const targetPos = nearest.position.clone().sub(toPlayer.multiplyScalar(teleportDist));
                    targetPos.y = Math.max(1.0, nearest.position.y);
                    this.mesh.position.copy(targetPos);
                    this.mesh.lookAt(nearest.position);
                    this.velocity.set(0, 0, 0);
                    if (window.flux.spawnTrail) window.flux.spawnTrail(nearest.position, targetPos);
                    if (window.flux.spawnTechText) window.flux.spawnTechText("BLINDSIDE");
                }
            }
            return; // Negate damage
        }
        
        // Overdrive reduces damage
        if (this.isOverdrive) amount *= 0.5;
        
        // --- SHIELD LOGIC ---
        if (this.isBlocking && !this.isShieldBroken) {
            // Parry Check
            if (this.parryWindow > 0) {
                if (window.flux && window.flux.showParry) window.flux.showParry(this.mesh.position.clone().add(new THREE.Vector3(0,2,0)));
                if (window.flux && window.flux.spawnBlockParticles) window.flux.spawnBlockParticles(this.mesh.position);
                if (window.flux && window.flux.slowMotion) window.flux.slowMotion(0.5, 0.1); 
                if (window.flux.audio) window.flux.audio.play('block'); 
                this.ap = Math.min(50, this.ap + 5);
                this.updateHUD();
                return; 
            }
            
            // Shield takes damage
            this.shieldHp -= amount;
            if (window.flux && window.flux.spawnBlockParticles) window.flux.spawnBlockParticles(this.mesh.position);
            if (window.flux.audio) window.flux.audio.play('block');
            
            // Shield Break
            if (this.shieldHp <= 0) {
                this.shieldHp = 0;
                this.isShieldBroken = true;
                this.shieldCooldown = this.shieldRegenDelay;
                this.isBlocking = false; // Force guard break
                
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("SHIELD SHATTERED");
                if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 30, 0x00ffff, 20); // Blue glass shatter
                if (window.flux.audio) window.flux.audio.play('massive_impact'); // Shatter sound
                if (window.flux.shake) window.flux.shake(0.5);
                
                // Stun player briefly
                this.velocity.add(new THREE.Vector3(0, 0, 10).applyQuaternion(this.mesh.quaternion));
            } else {
                // Knockback on block
                const backward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.mesh.quaternion);
                this.velocity.add(backward.multiplyScalar(10));
            }
            this.updateHUD();
            return;
        }

        let finalDamage = amount;
        if (this.ap > 0) {
            const absorption = Math.min(this.ap, amount * 0.5); 
            this.ap -= absorption;
            finalDamage -= absorption;
            const apBar = document.getElementById('ap-bar');
            if (apBar) apBar.style.width = (this.ap / 50 * 100) + '%';
        }

        this.hp -= finalDamage;
        if (this.hp < 0) this.hp = 0;
        
        // Glitch the shell on damage
        this.shellReveal = 0.2; 
        
        const vig = document.querySelector('.vignette');
        if (vig) {
            if (this.hp < 30) vig.classList.add('danger');
            else vig.classList.remove('danger');
        }
        
        this.kinematics.tiltX.vel += 5.0; 
        this.kinematics.crouch.vel += 2.0; 
        
        if(window.flux.audio) window.flux.audio.play('hit_flesh');

        if (amount > 20 && !this.isOverdrive) { // No knockdown in Overdrive
            this.isKnockedDown = true;
            this.velocity.y = 15; 
            this.velocity.add(new THREE.Vector3(0, 0, 10).applyQuaternion(this.mesh.quaternion)); 
        }

        if (!this.isFlashing) {
            this.isFlashing = true;
            
            // Standard material flash logic
            this.mesh.traverse((child) => {
                if (child.isMesh && child.material.emissive) {
                    child.material.emissive.setHex(0xff0000);
                }
            });

            setTimeout(() => {
                if (!this.mesh) return; 
                if (this.matMetatron) this.matMetatron.emissive.setHex(this.isOverdrive ? 0xff0055 : 0xff3300);
                if (this.matBlade) this.matBlade.emissive.setHex(this.isOverdrive ? 0xff0055 : 0x00ffff);
                this.isFlashing = false;
            }, 100);
        }

        if (window.flux && window.flux.shake) window.flux.shake(0.4);
        
        const hpBar = document.getElementById('hp-bar');
        if (hpBar) {
            const pct = (this.hp / this.maxHp) * 100;
            hpBar.style.width = pct + '%';
        }
        if (this.hp <= 0) this.die();
    }

    die() {
        this.isDead = true;
        this.visible = false; 
        this.targetEnemy = null; 
        if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 50, 0x00f3ff, 20);
        if (window.flux && window.flux.onPlayerDeath) window.flux.onPlayerDeath();
        if (this.weaponContainer) this.weaponContainer.visible = false;
        if (window.flux.audio && window.flux.audio.stopLoop) window.flux.audio.stopLoop('run_loop');
    }

    reset() {
        this.hp = this.maxHp;
        this.ap = 50;
        this.shieldHp = this.shieldMaxHp;
        this.isShieldBroken = false;
        this.isDead = false;
        this.mesh.position.set(0, 5, 0);
        this.velocity.set(0,0,0);
        const hpBar = document.getElementById('hp-bar');
        if (hpBar) hpBar.style.width = '100%';
        const apBar = document.getElementById('ap-bar');
        if (apBar) apBar.style.width = '100%';
        if (this.weaponContainer) this.weaponContainer.visible = true;
        this.ammo = this.maxAmmo;
        this.landingLag = 0;
        this.isReloading = false;
        this.isKnockedDown = false;
        this.isOverdrive = false;
        this.shellReveal = 1.0; 
        const vig = document.querySelector('.vignette');
        if (vig) vig.classList.remove('danger');
        this.updateHUD();
    }

    update(dt, input, camera) {
        if (this.isDead || dt === 0) return; 

        this.checkOverdrive();
        this.gravityScale = 1.0;
        
        // --- SHIELD REGEN ---
        if (this.isShieldBroken) {
            this.shieldCooldown -= dt;
            if (this.shieldCooldown <= 0) {
                this.isShieldBroken = false;
                this.shieldHp = this.shieldMaxHp; // Full restore
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("SHIELD RESTORED");
                if (window.flux.audio) window.flux.audio.play('charge');
            }
        } else if (this.shieldHp < this.shieldMaxHp && !this.isBlocking) {
            // Slow passive regen if not broken and not blocking
            this.shieldHp += dt * 5;
            if (this.shieldHp > this.shieldMaxHp) this.shieldHp = this.shieldMaxHp;
        }
        this.updateHUD();
        
        // --- SHIELD ANIMATION UPDATE ---
        if (this.shieldMesh && this.matShield) {
            this.shieldMesh.visible = (this.isBlocking && !this.isShieldBroken);
            if (this.shieldMesh.visible) {
                this.matShield.uniforms.uTime.value += dt;
                // Map HP to damage (1.0 = broken, 0.0 = full)
                const damage = 1.0 - (this.shieldHp / this.shieldMaxHp);
                this.matShield.uniforms.uDamage.value = damage;
            }
        }

        // --- FPS AUTO-AIM ---
        if (this.isFirstPerson && this.targetEnemy && !this.targetEnemy.userData.isDead) {
            // Force rotation to target
            const targetPos = this.targetEnemy.position.clone();
            targetPos.y += 1.0; // Aim at center mass
            
            const toTarget = new THREE.Vector3().subVectors(targetPos, this.mesh.position);
            
            // Yaw
            const targetYaw = Math.atan2(toTarget.x, toTarget.z);
            
            // Pitch
            // Calculate vertical angle
            const targetPitch = Math.atan2(toTarget.y - 1.5, Math.sqrt(toTarget.x*toTarget.x + toTarget.z*toTarget.z));
            
            // Smoothly interpolate
            let yawDiff = targetYaw - this.mesh.rotation.y;
            while (yawDiff > Math.PI) yawDiff -= Math.PI * 2;
            while (yawDiff < -Math.PI) yawDiff += Math.PI * 2;
            
            this.mesh.rotation.y += yawDiff * 10.0 * dt;
            
            // Clamp pitch
            const clampedPitch = Math.max(-1.4, Math.min(1.4, targetPitch));
            this.camPitch += (clampedPitch - this.camPitch) * 10.0 * dt;
        }

        this.handleInput(dt, input, camera);
        
        if (this.inputBuffer.action) {
            this.inputBuffer.time -= dt;
            if (this.inputBuffer.time <= 0) {
                this.inputBuffer.action = null;
            }
        }
        
        if (this.parryWindow > 0) this.parryWindow -= dt;
        if (this.wallMagnetismTimer > 0) this.wallMagnetismTimer -= dt;
        if (this.perfectDodgeWindow > 0) this.perfectDodgeWindow -= dt;

        this.applyPhysics(dt);
        this.updateAnimations(dt);
        this.updateAttack(dt); 
        this.updateCrosshair();
        
        if (this.isReloading) {
            this.reloadTimer -= dt * (this.isOverdrive ? 2.0 : 1.0);
            if (this.reloadTimer <= 0) {
                this.finishReload();
            }
        }
        
        if (this.landingLag > 0) {
            this.landingLag -= dt;
        }
        
        if (this.isWallRunning) {
            this.wallRunSoundTimer -= dt;
            if (this.wallRunSoundTimer <= 0) {
                if(window.flux.audio) window.flux.audio.play('wall_run');
                this.wallRunSoundTimer = 0.15; 
            }
        }
        
        if (input && input.actions) {
            this.wasJumpDown = input.actions.jump;
            this.wasDashDown = input.actions.dash;
            this.wasAttackDown = input.actions.attack;
            this.wasBlockDown = input.actions.block;
            this.wasSwitchDown = input.actions.switch;
            this.wasReloadDown = input.actions.reload;
            this.wasStyleDown = input.actions.style;
            this.wasLockDown = input.actions.lock;
            this.wasCamSwitchDown = input.actions['cam-switch']; 
        }

        const isMoving = input && input.moveVector && (Math.abs(input.moveVector.x) > 0.1 || Math.abs(input.moveVector.y) > 0.1);
        if (this.onGround && isMoving && !this.isDashing && !this.isKnockedDown) {
            if (window.flux.audio && window.flux.audio.startLoop) window.flux.audio.startLoop('run_loop');
        } else {
            if (window.flux.audio && window.flux.audio.stopLoop) window.flux.audio.stopLoop('run_loop');
        }
        
        if (this.isOverdrive && (this.isDashing || isMoving) && frameCount % 5 === 0) {
            if (window.flux && window.flux.spawnGhost) {
                window.flux.spawnGhost(this.visualGroup, true); 
            }
        }
    }

    updateCrosshair() {
        const chCircle = document.querySelector('.ch-circle');
        if (!chCircle) return;

        let spread = 20; 
        const speed = this.velocity.length();
        
        if (speed > 1) spread += speed * 0.5;
        if (this.isAttacking || this.fireTimer > 0) spread += 20;
        if (this.currentWeapon !== this.WEAPON_MELEE) spread += 10;
        if (!this.onGround) spread += 15;
        
        // Beam Rifle tightens crosshair
        if (this.currentWeapon === this.WEAPON_BEAM) spread = 10;

        chCircle.style.width = `${spread}px`;
        chCircle.style.height = `${spread}px`;
        
        if (this.currentWeapon !== this.WEAPON_MELEE) {
            chCircle.style.borderColor = "rgba(255, 255, 255, 0.8)";
        } else {
            chCircle.style.borderColor = "rgba(255, 255, 255, 0.2)";
        }
    }

    bufferAction(actionName) {
        this.inputBuffer.action = actionName;
        this.inputBuffer.time = this.BUFFER_WINDOW;
    }

    handleInput(dt, input, camera) {
        if (!input || !input.actions) return;

        const jumpIntent = (this.inputBuffer.action === 'jump');
        const dashIntent = (this.inputBuffer.action === 'dash');
        const attackIntent = (this.inputBuffer.action === 'attack');

        const blockPressed = input.actions.block; 
        const switchPressed = input.actions.switch && !this.wasSwitchDown;
        const reloadPressed = input.actions.reload && !this.wasReloadDown;
        const stylePressed = input.actions.style && !this.wasStyleDown;
        const lockPressed = input.actions.lock && !this.wasLockDown; 
        const camSwitchPressed = input.actions['cam-switch'] && !this.wasCamSwitchDown; 
        const attackHeld = input.actions.attack; 
        const techHeld = input.actions.tech; 
        
        if (input.actions.jump && !this.wasJumpDown) this.bufferAction('jump');
        if (input.actions.dash && !this.wasDashDown) this.bufferAction('dash');
        if (input.actions.attack && !this.wasAttackDown) this.bufferAction('attack'); 
        
        if (this.jumpBufferTimer > 0) this.jumpBufferTimer -= dt;
        if (this.dashCooldown > 0) this.dashCooldown -= dt;
        if (this.comboTimer > 0) this.comboTimer -= dt;
        if (this.comboTimer <= 0) this.comboIndex = 0; 
        if (this.fireTimer > 0) this.fireTimer -= dt;

        if (stylePressed) {
            this.cycleStyle();
        }

        if (switchPressed) {
            this.switchWeapon();
        }
        
        if (camSwitchPressed) { 
            this.isFirstPerson = !this.isFirstPerson;
            if (window.flux && window.flux.spawnTechText) {
                 window.flux.spawnTechText(this.isFirstPerson ? "VIEW: FPS" : "VIEW: TPS");
            }
            if (window.flux.audio) window.flux.audio.play('switch');
        }
        
        if (reloadPressed) {
            this.fireTimer = 0;
            if (this.currentWeapon !== this.WEAPON_MELEE) {
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("R-SHOT");
                if (this.ammo < this.maxAmmo) {
                    this.startReload();
                }
            }
        }

        this.updateLockOn(lockPressed);
        
        if (this.currentWeapon !== this.WEAPON_MELEE) {
            if (this.isReloading) {
                // Do nothing
            } else if (attackHeld && this.currentWeapon === this.WEAPON_RANGED) {
                if (!this.isCharging) {
                    this.isCharging = true;
                    this.attackHoldTimer = 0;
                    if(window.flux.audio) window.flux.audio.play('charge');
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("ACQUIRING TARGETS");
                }
                this.attackHoldTimer += dt * (this.isOverdrive ? 2.0 : 1.0);
                
                if (this.attackHoldTimer > 1.0 && Math.random() > 0.9) {
                    if (window.flux.spawnTechText) window.flux.spawnTechText("MAX LOCK");
                }
                
            } else if (this.isCharging && !attackHeld && this.currentWeapon === this.WEAPON_RANGED) {
                this.isCharging = false;
                const chargeLevel = Math.min(2.0, this.attackHoldTimer);
                if (chargeLevel > 0.2) {
                    this.fireHomingLasers(chargeLevel);
                } else {
                    this.shoot(camera);
                }
                this.attackHoldTimer = 0;
                this.inputBuffer.action = null;
            } else if (attackIntent && !this.isCharging) {
                this.shoot(camera);
                this.inputBuffer.action = null;
            }
            
        } else {
            if (attackIntent && !this.isReloading && this.landingLag <= 0) {
                if (!this.isBlocking && !this.isAttacking) {
                    let triggeredLasers = false;
                    
                    if (window.flux && window.flux.enemies) {
                        let nearestDist = 999;
                        let enemyFound = false;
                        
                        for (let e of window.flux.enemies) {
                            if (!e.userData.isDead) {
                                const d = e.position.distanceTo(this.mesh.position);
                                if (d < nearestDist) nearestDist = d;
                                enemyFound = true;
                            }
                        }
                        
                        const isMoving = input.moveVector && (Math.abs(input.moveVector.x) > 0.1 || Math.abs(input.moveVector.y) > 0.1);
                        if (enemyFound && nearestDist > 30 && !isMoving) {
                            this.fireHomingLasers(1.0); 
                            triggeredLasers = true;
                        }
                    }

                    if (!triggeredLasers) {
                        this.performAttack(false);
                    }
                    this.inputBuffer.action = null; 
                }
            }
        }

        // Shield Block Input
        if (blockPressed && this.currentWeapon === this.WEAPON_MELEE && !this.isShieldBroken) {
            if (this.currentStyle === this.STYLE_DAGGER) return; 

            if (this.isAttacking) {
                const progress = 1.0 - (this.attackTimer / this.attackTotalDuration);
                
                if (progress > 0.2) { 
                    this.isAttacking = false; 
                    if(this.activeSlashMesh) {
                        this.scene.remove(this.activeSlashMesh);
                        this.activeSlashMesh = null;
                    }
                    this.attackTimer = 0;
                    if (window.flux && window.flux.spawnParticles) {
                        window.flux.spawnParticles(this.mesh.position, 5, 0xffff00, 10);
                    }
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("GUARD CANCEL");
                    
                    if (!this.isBlocking) {
                        if (window.flux.audio) window.flux.audio.play('block');
                        this.parryWindow = 0.2; 
                        if (window.flux.spawnVectorTrap) window.flux.spawnVectorTrap(this.mesh.position);
                    }
                    this.isBlocking = true;
                }
            } else if (!this.isBlocking) {
                if (window.flux.audio) window.flux.audio.play('block');
                this.parryWindow = 0.2; 
                if (window.flux.spawnVectorTrap) window.flux.spawnVectorTrap(this.mesh.position);
                this.isBlocking = true;
            } else {
                this.isBlocking = true; 
            }
            
            this.isCharging = false;
            this.checkBlockCollision();
        } else {
            this.isBlocking = false;
        }

        if (techHeld) {
            if (dashIntent && this.dashCooldown <= 0) {
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("BUTTERFLY");
                
                this.velocity.y = this.jumpForce;
                this.onGround = false;
                this.coyoteTimer = 0;
                
                this.startDash(input, camera, false);
                
                setTimeout(() => {
                    if (!this.isDead) this.performAttack(false);
                }, 50);
                
                setTimeout(() => {
                    if (!this.isDead && this.isAttacking) {
                        this.isAttacking = false;
                        this.isBlocking = true;
                        if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 5, 0xffff00, 10);
                    }
                }, 200); 
                
                this.inputBuffer.action = null;
                return; 
            }
            
            if (jumpIntent && this.touchingWall) {
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("WALL CLIMB");
                
                const normal = this.lastWallNormal.lengthSq() > 0 ? this.lastWallNormal : new THREE.Vector3(0,0,1);
                const horizontalPush = 25; 
                this.velocity.copy(normal).multiplyScalar(horizontalPush);
                this.velocity.y = this.jumpForce * 1.2; 
                
                const angle = Math.atan2(-normal.z, normal.x) + (Math.PI/2);
                this.mesh.rotation.y = angle;
                
                this.isWallRunning = false;
                this.wasWallJump = true;
                this.wallMagnetismTimer = 0;
                
                setTimeout(() => {
                    if (!this.isDead) this.performAttack(false);
                }, 50);
                
                setTimeout(() => {
                    if (!this.isDead) {
                        this.isAttacking = false; 
                        const dashDir = normal.clone().negate();
                        this.velocity.x = dashDir.x * 60;
                        this.velocity.z = dashDir.z * 60;
                        this.isDashing = true;
                        this.dashTime = this.dashDuration;
                    }
                }, 250);
                
                this.inputBuffer.action = null;
                return; 
            }
        }

        if (dashIntent && this.dashCooldown <= 0 && !this.isCharging) {
            if (this.isReloading) {
                this.isReloading = false;
                this.updateHUD();
            }
            
            let isSilent = false;
            if (this.isAttacking) {
                isSilent = true;
            }

            this.isAttacking = false;
            this.isBlocking = false;
            if(this.activeSlashMesh) {
                this.scene.remove(this.activeSlashMesh);
                this.activeSlashMesh = null;
            }
            
            this.startDash(input, camera, isSilent);
            this.inputBuffer.action = null; 
        }

        if (!this.isDashing && this.landingLag <= 0) {
            let speedMod = 1.0;
            if (this.currentStyle === this.STYLE_DAGGER) speedMod = 1.2;
            if (this.currentStyle === this.STYLE_GREATSWORD) speedMod = 0.8;
            if (this.isOverdrive) speedMod *= 1.3; 

            const lookX = input.lookVector ? input.lookVector.x : 0;
            const lookY = input.lookVector ? input.lookVector.y : 0;
            
            if (this.isFirstPerson) {
                // FPS Mode: Mouse/Stick controls rotation directly
                if (Math.abs(lookX) > 0.05) {
                    this.mesh.rotation.y -= lookX * 3.0 * dt;
                }
                if (Math.abs(lookY) > 0.05) {
                    this.camPitch += lookY * 2.0 * dt; 
                    this.camPitch = Math.max(-1.4, Math.min(1.4, this.camPitch));
                }
                
                if (input.gyroEnabled && input.getGyroDelta) {
                    const gyro = input.getGyroDelta();
                    const gyroSens = 0.05; 
                    if (Math.abs(gyro.x) > 0.01) this.mesh.rotation.y -= gyro.x * gyroSens;
                    if (Math.abs(gyro.y) > 0.01) {
                        this.camPitch -= gyro.y * gyroSens; 
                        this.camPitch = Math.max(-1.4, Math.min(1.4, this.camPitch));
                    }
                }
                
            } else {
                if (Math.abs(lookX) > 0.05) {
                    this.mesh.rotation.y -= lookX * 3.0 * dt;
                }
            }

            const moveVec = input.moveVector || { x: 0, y: 0 };
            const mx = moveVec.x || 0;
            const my = moveVec.y || 0;
            
            if (Math.abs(mx) > 0.1 || Math.abs(my) > 0.1) {
                let inputDir = new THREE.Vector3();
                
                if (this.isFirstPerson) {
                    const rotY = this.mesh.rotation.y;
                    const forward = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
                    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));
                    inputDir.addScaledVector(forward, my).addScaledVector(right, mx).normalize();
                } else {
                    const camForward = new THREE.Vector3();
                    camera.getWorldDirection(camForward);
                    camForward.y = 0;
                    camForward.normalize();
                    const camRight = new THREE.Vector3();
                    camRight.crossVectors(camForward, new THREE.Vector3(0, 1, 0));
                    inputDir.addScaledVector(camForward, my).addScaledVector(camRight, mx).normalize();
                            
                    if (Math.abs(lookX) < 0.1 && !this.targetEnemy) {
                        const targetAngle = Math.atan2(inputDir.x, inputDir.z);
                        let angleDiff = targetAngle - this.mesh.rotation.y;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        this.mesh.rotation.y += angleDiff * 10.0 * dt;
                    }
                }

                const force = inputDir.multiplyScalar(this.acceleration * speedMod * dt);
                this.velocity.x += force.x;
                this.velocity.z += force.z;

                const dragFactor = this.onGround ? this.drag : this.airDrag;
                this.velocity.x *= (1 - (dragFactor * dt));
                this.velocity.z *= (1 - (dragFactor * dt));

            } else {
                const friction = this.onGround ? this.brakingDrag : this.airDrag;
                this.velocity.x -= this.velocity.x * friction * dt;
                this.velocity.z -= this.velocity.z * friction * dt;
                this.kinematics.chestTwist.target = 0;
            }
        } else if (this.landingLag > 0) {
            this.velocity.x *= 0.8;
            this.velocity.z *= 0.8;
        }

        if (this.onGround && this.landingLag <= 0) {
            this.coyoteTimer = this.coyoteMax;
            this.isKnockedDown = false; 
            this.wasWallJump = false; 
            this.canWallJump = false; 
        } else {
            if (this.coyoteTimer > 0) this.coyoteTimer -= dt;
        }

        if (jumpIntent) this.jumpBufferTimer = this.jumpBufferMax;

        if (this.jumpBufferTimer > 0) {
            let jumped = false;
            
            if (this.isKnockedDown) {
                this.isKnockedDown = false;
                this.velocity.y = this.jumpForce * 0.8;
                this.kinematics.tiltX.vel = -20;
                if(window.flux.audio) window.flux.audio.play('jump');
                window.flux.spawnParticles(this.mesh.position, 10, 0x00ff00, 10);
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("SAFE FALL");
                jumped = true;
            }
            else if (this.canWallJump) { 
                const normal = this.lastWallNormal.lengthSq() > 0 ? this.lastWallNormal : new THREE.Vector3(0,0,1);
                
                const horizontalPush = 25; 
                this.velocity.copy(normal).multiplyScalar(horizontalPush);
                this.velocity.y = this.jumpForce * 1.2; 
                
                const angle = Math.atan2(normal.x, normal.z);
                this.mesh.rotation.y = angle;
                
                this.dashTime = 0;
                this.isDashing = false;
                this.isWallRunning = false;
                this.landingLag = 0;
                this.wasWallJump = true; 
                this.canWallJump = false; 
                this.wallMagnetismTimer = 0;
                
                this.dashCooldown = 0;
                
                this.isAttacking = false;
                if(this.activeSlashMesh) {
                    this.scene.remove(this.activeSlashMesh);
                    this.activeSlashMesh = null;
                }
                
                this.kinematics.crouch.vel = -10; 
                
                if(window.flux && window.flux.shake) window.flux.shake(0.5);
                if(window.flux.audio) window.flux.audio.play('jump');
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("WALL JUMP");
                jumped = true;
            } 
            else if (this.coyoteTimer > 0) {
                this.velocity.y = this.jumpForce;
                this.onGround = false;
                this.coyoteTimer = 0;
                
                if (this.isDashing) { 
                    this.isDashing = false; 
                    this.velocity.x *= 1.2; 
                    this.velocity.z *= 1.2;
                }
                
                this.kinematics.crouch.vel = -15;
                if(window.flux.audio) window.flux.audio.play('jump');
                jumped = true;
            }
            
            if (jumped) {
                this.jumpBufferTimer = 0; 
                this.inputBuffer.action = null; 
            }
        }
    }
    
    updateLockOn(lockPressed) {
        if (lockPressed) {
            if (window.flux.audio) window.flux.audio.play('lock');
            if (this.targetEnemy) {
                this.targetEnemy = null;
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("LOCK-OFF");
            } else {
                let nearestEnemy = null;
                let minDist = this.lockOnRange; 
                
                if (window.flux && window.flux.enemies) {
                    window.flux.enemies.forEach(e => {
                        if (!e.userData.isDead && e.visible) {
                            const dist = e.position.distanceTo(this.mesh.position);
                            if (dist < minDist) {
                                this.raycaster.set(this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0)), new THREE.Vector3().subVectors(e.position, this.mesh.position).normalize());
                                const intersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
                                if (intersects.length === 0 || intersects[0].distance > dist) {
                                    minDist = dist;
                                    nearestEnemy = e;
                                }
                            }
                        }
                    });
                }
                
                if (nearestEnemy) {
                    this.targetEnemy = nearestEnemy;
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("TARGET LOCKED");
                } else {
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("NO TARGET");
                }
            }
            return;
        }

        if (this.targetEnemy && this.targetEnemy.userData.isDead) {
            if (!this.isFirstPerson) {
                let nearestEnemy = null;
                let minDist = 15; 
                
                if (window.flux && window.flux.enemies) {
                    window.flux.enemies.forEach(e => {
                        if (!e.userData.isDead && e.visible) {
                            const dist = e.position.distanceTo(this.mesh.position);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestEnemy = e;
                            }
                        }
                    });
                }
                
                if (nearestEnemy) {
                    this.targetEnemy = nearestEnemy;
                    if (window.flux.audio) window.flux.audio.play('lock_switch');
                } else {
                    this.targetEnemy = null;
                }
            } else {
                this.targetEnemy = null;
            }
        }
    }
    
    cycleStyle() {
        this.currentStyle++;
        if (this.currentStyle > 2) this.currentStyle = 0;
        
        if (typeof PlayerMesh !== 'undefined') {
            PlayerMesh.updateWeaponVisuals(this);
        }
        
        const names = ["KATANA", "DAGGER", "GREATSWORD"];
        if (window.flux && window.flux.spawnTechText) {
            window.flux.spawnTechText("STYLE: " + names[this.currentStyle]);
        }
        this.updateHUD();
    }

    startReload() {
        this.isReloading = true;
        this.reloadTimer = this.reloadDuration;
        this.fireTimer = 0;
        if(window.flux.audio) window.flux.audio.play('reload');
        this.updateHUD();
    }
    
    finishReload() {
        this.isReloading = false;
        this.ammo = this.maxAmmo;
        this.updateHUD();
    }

    switchWeapon() {
        if (this.currentWeapon === this.WEAPON_MELEE) {
            this.currentWeapon = this.WEAPON_RANGED;
        } else if (this.currentWeapon === this.WEAPON_RANGED) {
            this.currentWeapon = this.WEAPON_BEAM;
        } else {
            this.currentWeapon = this.WEAPON_MELEE;
        }
        
        if(window.flux.audio) window.flux.audio.play('switch');
        
        if (this.isAttacking) {
            this.isAttacking = false;
            if(this.activeSlashMesh) {
                this.scene.remove(this.activeSlashMesh);
                this.activeSlashMesh = null;
            }
            this.attackTimer = 0;
            this.fireTimer = 0; 
        }
        
        if (this.isReloading) {
            this.isReloading = false;
        }
        
        if (this.landingLag > 0) {
            this.landingLag = 0;
        }

        if (!this.onGround) {
            this.velocity.x *= 0.8; 
            this.velocity.z *= 0.8;
        }

        if (!this.isFirstPerson) {
            if (this.swordGroup) this.swordGroup.visible = (this.currentWeapon === this.WEAPON_MELEE);
            if (this.gunGroup) this.gunGroup.visible = (this.currentWeapon !== this.WEAPON_MELEE);
        }
        
        this.updateHUD();
    }

    shoot(camera) {
        if (this.ammo <= 0) {
             if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("RELOAD");
             if (window.flux.audio) window.flux.audio.play('switch');
             return;
        }

        if (this.currentWeapon === this.WEAPON_BEAM) {
            this.ammo--;
            this.fireTimer = 0.8; 
            this.updateHUD();

            if (window.flux && window.flux.shake) window.flux.shake(1.2); 
            if (window.flux.audio) window.flux.audio.play('laser_fire'); 
            
            this.kinematics.weaponSwayX.vel += 5.0; 
            this.kinematics.tiltX.vel += 3.0;
            this.velocity.add(new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion).multiplyScalar(5.0));

            if (!this.muzzlePoint) return;
            
            const rayOrigin = this.muzzlePoint.position.clone();
            this.muzzlePoint.updateWorldMatrix(true, false);
            this.muzzlePoint.getWorldPosition(rayOrigin);

            let gunForward;
            if (this.isFirstPerson) {
                gunForward = new THREE.Vector3();
                camera.getWorldDirection(gunForward);
            } else {
                gunForward = new THREE.Vector3(Math.sin(this.mesh.rotation.y), 0, Math.cos(this.mesh.rotation.y));
            }

            this.raycaster.set(rayOrigin, gunForward);
            this.raycaster.far = 2000;
            
            let hitPoint = rayOrigin.clone().add(gunForward.clone().multiplyScalar(100));
            let hitEnemy = null;
            let minDist = 9999;

            if (this.enemyGroup && this.enemyGroup.children.length > 0) {
                const intersects = this.raycaster.intersectObjects(this.enemyGroup.children, true);
                if (intersects.length > 0) {
                    if (intersects[0].distance < minDist) {
                        minDist = intersects[0].distance;
                        hitPoint = intersects[0].point;
                        let obj = intersects[0].object;
                        while(obj.parent && !obj.userData.type) {
                            obj = obj.parent;
                        }
                        if (obj.userData.type === 'enemy') hitEnemy = obj;
                    }
                }
            }
            
            if (this.staticGroup && this.staticGroup.children.length > 0) {
                const worldIntersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
                if (worldIntersects.length > 0) {
                    if (worldIntersects[0].distance < minDist) {
                        minDist = worldIntersects[0].distance;
                        hitPoint = worldIntersects[0].point;
                        hitEnemy = null; 
                    }
                }
            }

            if (window.flux && window.flux.firePlayerBeam) {
                window.flux.firePlayerBeam(rayOrigin, hitPoint);
            }

            if (hitEnemy && !hitEnemy.userData.isDead) {
                let damage = 80; 
                if (this.isOverdrive) damage = 120;
                
                hitEnemy.userData.hp -= damage;
                
                if (window.flux && window.flux.showDamage) {
                    window.flux.showDamage(hitPoint, Math.floor(damage), true);
                }
                
                if (window.flux && window.flux.spawnHitParticles) window.flux.spawnHitParticles(hitPoint, gunForward.clone().multiplyScalar(-1));
                
                if (hitEnemy.userData.hp <= 0) {
                    if (window.flux && window.flux.killEnemy) window.flux.killEnemy(hitEnemy);
                } else {
                    this.flashEnemy(hitEnemy);
                }
            } else {
                if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(hitPoint, 10, 0x00ffff, 20);
            }

            return;
        }

        this.ammo--;
        this.fireTimer = this.fireRate;
        this.updateHUD();

        if (window.flux && window.flux.shake) window.flux.shake(0.8); 
        if (window.flux.audio) window.flux.audio.play('shotgun');
        
        if (window.flux && window.flux.flickerPlayerLight) {
            window.flux.flickerPlayerLight(0xffaa00, 0.1);
        }

        this.kinematics.weaponSwayX.vel += 2.0; 
        this.kinematics.tiltX.vel += 1.0;

        if (!this.muzzlePoint) return;
        
        const rayOrigin = this.muzzlePoint.position.clone();
        this.muzzlePoint.updateWorldMatrix(true, false);
        this.muzzlePoint.getWorldPosition(rayOrigin);

        let gunForward;
        if (this.isFirstPerson) {
            gunForward = new THREE.Vector3();
            camera.getWorldDirection(gunForward);
        } else {
            gunForward = new THREE.Vector3(Math.sin(this.mesh.rotation.y), 0, Math.cos(this.mesh.rotation.y));
        }

        if (window.flux && window.flux.spawnShell) {
            const shellDir = new THREE.Vector3(1, 0.5, 0).applyQuaternion(this.mesh.quaternion);
            window.flux.spawnShell(rayOrigin, shellDir);
        }

        if (window.flux && window.flux.spawnParticles) {
            window.flux.spawnParticles(rayOrigin, 15, 0xffffaa, 8); 
        }

        const pelletCount = 8; 
        const pelletDamage = 25; 
        
        for(let i=0; i<pelletCount; i++) {
            this.pelletOrigin.copy(rayOrigin);
            this.pelletDir.copy(gunForward);
            
            const spread = 0.08; 
            this.pelletDir.x += (Math.random() - 0.5) * spread;
            this.pelletDir.y += (Math.random() - 0.5) * spread;
            this.pelletDir.z += (Math.random() - 0.5) * spread;
            this.pelletDir.normalize();

            this.raycaster.set(this.pelletOrigin, this.pelletDir);
            this.raycaster.far = 1000;

            let hitEnemy = null;
            let hitPoint = null;
            let minDist = 999;

            if (this.enemyGroup && this.enemyGroup.children.length > 0) {
                const intersects = this.raycaster.intersectObjects(this.enemyGroup.children, true);
                if (intersects.length > 0) {
                    if (intersects[0].distance < minDist) {
                        minDist = intersects[0].distance;
                        hitPoint = intersects[0].point;
                        let obj = intersects[0].object;
                        while(obj.parent && !obj.userData.type) {
                            obj = obj.parent;
                        }
                        if (obj.userData.type === 'enemy') hitEnemy = obj;
                    }
                }
            }
            
            if (this.staticGroup && this.staticGroup.children.length > 0) {
                const worldIntersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
                if (worldIntersects.length > 0) {
                    if (worldIntersects[0].distance < minDist) {
                        minDist = worldIntersects[0].distance;
                        hitPoint = worldIntersects[0].point;
                        let obj = worldIntersects[0].object;
                        while(obj.parent && !obj.userData.type) {
                            obj = obj.parent;
                        }
                        if (obj.userData.type === 'barrel') {
                            if (window.flux && window.flux.explode) {
                                window.flux.explode(obj.position.clone());
                                obj.position.y = -500; 
                                obj.visible = false; 
                            }
                        }
                        hitEnemy = null; 
                    }
                }
            }

            if (window.flux && window.flux.spawnTrail && Math.random() > 0.3) {
                const endPos = hitPoint ? hitPoint : this.pelletOrigin.clone().add(this.pelletDir.clone().multiplyScalar(100));
                window.flux.spawnTrail(rayOrigin, endPos);
            }

            if (hitEnemy && !hitEnemy.userData.isDead) {
                let actualDamage = pelletDamage;
                if (hitEnemy.userData.enemyType === 'gargantua') {
                    actualDamage *= 0.5; 
                    if (Math.random() > 0.9 && window.flux && window.flux.showDamage) {
                        window.flux.showDamage(hitEnemy.position, "RESIST", false);
                    }
                }
                
                hitEnemy.userData.hp -= actualDamage;
                
                if (hitEnemy.userData.springs) {
                    hitEnemy.userData.springs.scale.vel = -5.0; 
                    hitEnemy.userData.springs.tiltX.vel = 5.0; 
                }

                if (window.flux && window.flux.showDamage) {
                    const dmgPos = hitPoint ? hitPoint.clone() : hitEnemy.position.clone();
                    dmgPos.x += (Math.random() - 0.5) * 0.5;
                    dmgPos.y += (Math.random() - 0.5) * 0.5;
                    window.flux.showDamage(dmgPos, Math.floor(actualDamage), false);
                }
                
                if (window.flux && window.flux.spawnHitParticles) window.flux.spawnHitParticles(hitPoint || hitEnemy.position, this.pelletDir.clone().multiplyScalar(-1));
                if (window.flux.audio) window.flux.audio.play('hit_flesh');
                
                if (hitEnemy.userData.hp <= 0) {
                    if (window.flux && window.flux.killEnemy) window.flux.killEnemy(hitEnemy);
                } else {
                    this.flashEnemy(hitEnemy);
                }
            } else if (hitPoint) {
                if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(hitPoint, 3, 0xcccccc, 10);
                if (window.flux && window.flux.spawnDebris) window.flux.spawnDebris(hitPoint, 2); 
                if (window.flux.audio) window.flux.audio.play('hit_wall');
            }
        }
    }
    
    flashEnemy(obj) {
        if (!obj) return;
        obj.traverse((child) => {
            if (child.isMesh) {
                if (child.material && child.material.emissive) {
                    if (!child.userData.origEmissive) child.userData.origEmissive = child.material.emissive.getHex();
                    child.material.emissive.setHex(0xffffff);
                    setTimeout(() => {
                        if (child.material) child.material.emissive.setHex(child.userData.origEmissive);
                    }, 100);
                } else if (child.material && child.material.color) {
                    if (!child.userData.origColor) child.userData.origColor = child.material.color.getHex();
                    child.material.color.setHex(0xffffff);
                    setTimeout(() => {
                        if (child.material) child.material.color.setHex(child.userData.origColor);
                    }, 100);
                }
            }
        });
    }
    
    fireHomingLasers(chargeRatio = 1.0) {
        if (!window.flux || !window.flux.spawnLaser) return;
        
        const targets = [];
        if (window.flux.enemies) {
            window.flux.enemies.forEach(e => {
                if (!e.userData.isDead && e.position.distanceTo(this.mesh.position) < 80) {
                    targets.push(e);
                }
            });
        }
        
        if (targets.length === 0) {
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("NO TARGETS");
            return;
        }
        
        const baseCount = 8;
        let count = Math.ceil(baseCount * chargeRatio); 
        if (this.isOverdrive) count *= 2; 
        
        if (window.flux.spawnTechText) window.flux.spawnTechText(`FIRE: ${count}`);
        
        for(let i=0; i<count; i++) {
            const target = targets[i % targets.length];
            const startPos = this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
            window.flux.spawnLaser(startPos, target.position, target); 
            if (window.flux.audio) window.flux.audio.play('laser_fire');
        }
        
        this.kinematics.tiltX.vel += 10 * chargeRatio;
        this.velocity.y += 5 * chargeRatio;
    }

    startDash(input, camera, isSilent = false) {
        this.isDashing = true;
        this.dashTime = this.dashDuration;
        this.dashCooldown = 0.2; 
        if (this.isOverdrive) this.dashCooldown = 0.1;
        
        this.perfectDodgeWindow = 0.15; 
        
        this.velocity.y = 0;
        
        if (!isSilent) {
            if(window.flux.audio) window.flux.audio.play('teleport'); 
        }

        if (window.flux && window.flux.spawnGhost) {
            window.flux.spawnGhost(this.visualGroup, isSilent);
        }

        this.kinematics.tiltX.vel += 5.0; 
        this.kinematics.crouch.vel += 3.0; 

        let dashDir = new THREE.Vector3();
        const moveVec = (input && input.moveVector) ? input.moveVector : { x: 0, y: 0 };
        const mx = moveVec.x || 0;
        const my = moveVec.y || 0;

        if (Math.abs(mx) > 0.1 || Math.abs(my) > 0.1) {
             if (this.isFirstPerson) {
                 const rotY = this.mesh.rotation.y;
                 const forward = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
                 const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));
                 dashDir.addScaledVector(forward, my).addScaledVector(right, mx).normalize();
             } else {
                 const camForward = new THREE.Vector3();
                 camera.getWorldDirection(camForward);
                 camForward.y = 0;
                 camForward.normalize();
                 const camRight = new THREE.Vector3();
                 camRight.crossVectors(camForward, new THREE.Vector3(0, 1, 0));
                 dashDir.addScaledVector(camForward, my).addScaledVector(camRight, mx).normalize();
             }
        } else {
            const rotY = this.mesh.rotation.y;
            dashDir.set(Math.sin(rotY), 0, Math.cos(rotY));
        }
        
        let dashDist = 12.0; 
        if (this.isOverdrive) dashDist = 18.0;

        let startPos = this.mesh.position.clone();
        let targetPos;

        if (this.targetEnemy && !this.targetEnemy.userData.isDead) {
            const toTarget = new THREE.Vector3().subVectors(this.targetEnemy.position, startPos);
            const distToTarget = toTarget.length();
            
            const travelDist = Math.min(distToTarget - 2.0, dashDist);
            
            if (travelDist > 0) {
                dashDir = toTarget.normalize();
                targetPos = startPos.clone().add(dashDir.clone().multiplyScalar(travelDist));
                
                if (this.targetEnemy.position.y > startPos.y + 2.0) {
                    this.velocity.y = 15; 
                }
            } else {
                targetPos = startPos.clone().add(dashDir.clone().multiplyScalar(dashDist));
            }
        } else {
            targetPos = startPos.clone().add(dashDir.clone().multiplyScalar(dashDist));
        }
        
        this.raycaster.set(startPos.clone().add(new THREE.Vector3(0,1.5,0)), dashDir);
        this.raycaster.far = dashDist;
        
        let finalPos = targetPos;
        
        if (this.staticGroup) {
            const intersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
            if (intersects.length > 0) {
                const hitDist = intersects[0].distance;
                finalPos = startPos.clone().add(dashDir.clone().multiplyScalar(hitDist - 1.5));
            }
        }
        
        this.mesh.position.copy(finalPos);
        
        this.velocity.x = dashDir.x * 20; 
        this.velocity.z = dashDir.z * 20;
        
        if (window.flux && window.flux.spawnGhost) {
            window.flux.spawnGhost(this.visualGroup, true);
        }
        
        if(window.flux && window.flux.shake) window.flux.shake(0.2);
    }

    checkWallProximity(distance) {
        const rotY = this.mesh.rotation.y;
        const forward = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
        
        this.raycaster.set(this.mesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)), forward);
        this.raycaster.far = distance;
        
        if (this.staticGroup && this.staticGroup.children.length > 0) {
            const intersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
            if (intersects.length > 0) {
                return { found: true, normal: intersects[0].face.normal.clone(), distance: intersects[0].distance };
            }
        }
        return { found: false, normal: new THREE.Vector3() };
    }

    performAttack(isMassive = false) {
        const wallCheck = this.checkWallProximity(3.5); 
        const isWallSlash = wallCheck.found;

        if (isWallSlash) {
            this.canWallJump = true; 
            this.velocity.set(0,0,0); 
            this.gravityScale = 0; 
            this.lastWallNormal.copy(wallCheck.normal);
            
            this.isDashing = false;
            this.dashTime = 0;
            
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("WALL SLASH");
        }

        if (this.isWallRunning || this.wasWallJump) {
            this.touchingWall = false;
            this.isWallRunning = false;
            this.wasWallJump = false; 
            this.velocity.x *= 0.1;
            this.velocity.z *= 0.1;
            if (this.velocity.y < 0) this.velocity.y = 0; 
            this.dashCooldown = 0; 
        }

        if (!this.onGround) {
            this.dashCooldown = 0; 
        }

        this.isAttacking = true;
        this.hitEnemies.clear();
        this.currentSwingId++; 
        
        if(this.activeSlashMesh) {
            this.scene.remove(this.activeSlashMesh);
            this.activeSlashMesh = null;
        }

        if (isWallSlash) {
            this.attackType = 'WALL'; 
            this.activeComboStep = 0;
        } else if (this.isDashing) {
            this.attackType = 'DASH';
            this.isDashing = false; 
            this.activeComboStep = 99; 
            this.comboIndex = 0; 
        } else if (isMassive) {
            this.attackType = 'MASSIVE';
            this.activeComboStep = 100;
        } else {
            this.attackType = this.onGround ? 'GROUND' : 'AIR';
            this.activeComboStep = this.onGround ? this.comboIndex : 88; 
            
            if (!this.onGround) {
                this.gravityScale = 0.0; 
                this.velocity.y *= 0.5; 
            }
        }
        
        let target = this.targetEnemy;
        let isMagnetized = false;
        
        if (!target && window.flux && window.flux.enemies) {
            let nearestEnemy = null;
            let minDist = 10.0; 
            window.flux.enemies.forEach(e => {
                if (!e.userData.isDead) {
                    const dist = e.position.distanceTo(this.mesh.position);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestEnemy = e;
                    }
                }
            });
            if (nearestEnemy) target = nearestEnemy;
        }
        
        if (target && !target.userData.isDead && !isWallSlash) {
            const dist = this.mesh.position.distanceTo(target.position);
            
            if (this.onGround && target.position.y > this.mesh.position.y + 2.0 && dist < 15.0) {
                this.attackType = 'LAUNCHER';
                this.activeComboStep = 77; 
                this.velocity.y = 45; 
                this.onGround = false;
                const dir = new THREE.Vector3().subVectors(target.position, this.mesh.position).normalize();
                this.velocity.x = dir.x * 40; 
                this.velocity.z = dir.z * 40;
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("RISING SLASH");
            }
            else if (dist < 30.0) {
                 const dir = new THREE.Vector3().subVectors(target.position, this.mesh.position).normalize();
                 const targetDist = dist - 1.5; 
                 
                 if (targetDist > 0) {
                     const speed = targetDist / 0.15; 
                     const maxSpeed = 120; 
                     const finalSpeed = Math.min(speed, maxSpeed);
                     
                     this.velocity.x = dir.x * finalSpeed;
                     this.velocity.z = dir.z * finalSpeed;
                     isMagnetized = true;
                     
                     if (target.position.y > this.mesh.position.y + 1.0) {
                         this.velocity.y += 15; 
                     }
                 }
            }
        }
        
        if (isMassive) {
            if(window.flux.audio) window.flux.audio.play('slash_heavy');
        } else if (this.attackType === 'LAUNCHER') {
            if(window.flux.audio) window.flux.audio.play('launcher');
        } else {
            if (this.comboIndex === 2) {
                if(window.flux.audio) window.flux.audio.play('slash_finisher');
            } else if (this.comboIndex === 1) {
                if(window.flux.audio) window.flux.audio.play('slash_heavy');
            } else {
                if(window.flux.audio) window.flux.audio.play('slash_light');
            }
        }

        if (this.comboIndex > 2) this.comboIndex = 0;
        if (this.activeComboStep > 2 && this.attackType === 'GROUND') this.activeComboStep = 0;
        
        let templateToClone = this.slashTemplate;
        if ((this.attackType === 'GROUND' && this.activeComboStep === 2) || isMassive) {
            templateToClone = this.slashSpinTemplate;
        }

        this.activeSlashMesh = templateToClone.clone(true);
        this.activeSlashMesh.visible = true;
        this.activeSlashMesh.material = this.slashTemplate.material.clone();
        this.activeSlashMesh.material.opacity = 1.0;
        this.activeSlashMesh.material.transparent = true;
        
        const pPos = this.mesh.position.clone();
        const pRot = this.mesh.rotation.y;
        
        this.activeSlashMesh.position.copy(pPos);
        this.activeSlashMesh.rotation.y = pRot; 
        
        this.slashVelocity.set(0,0,0);
        const forward = new THREE.Vector3(Math.sin(pRot), 0, Math.cos(pRot));

        let dmgMult = 1.0;
        let speedMult = 1.0;
        
        if (this.currentStyle === this.STYLE_DAGGER) {
            dmgMult = 0.6;
            speedMult = 1.5;
        } else if (this.currentStyle === this.STYLE_GREATSWORD) {
            dmgMult = 2.5;
            speedMult = 0.6;
        }
        
        if (this.isOverdrive) {
            speedMult *= 1.3;
            dmgMult *= 1.5;
        }

        if (this.attackType === 'MASSIVE') {
            this.attackTotalDuration = 0.6 * (1/speedMult);
            this.activeSlashMesh.position.y += 1.0;
            this.activeSlashMesh.rotateX(-Math.PI/2);
            this.activeSlashMesh.scale.set(3,3,3); 
            this.activeSlashMesh.material.color.setHex(0xffaa00); 
            this.velocity.addScaledVector(forward, 60);
            this.kinematics.crouch.vel += 10; 
            if (window.flux && window.flux.spawnMassiveImpact) {
                window.flux.spawnMassiveImpact(pPos.clone().addScaledVector(forward, 2));
            }
        }
        else if (this.attackType === 'LAUNCHER') {
             this.attackTotalDuration = 0.4 * (1/speedMult);
             this.activeSlashMesh.position.y += 2.0;
             this.activeSlashMesh.rotateX(-Math.PI/2); 
             this.activeSlashMesh.rotateZ(Math.PI/2); 
             this.activeSlashMesh.scale.set(2.5, 2.5, 2.5);
             this.activeSlashMesh.material.color.setHex(0xff00ff);
        }
        else if (this.attackType === 'DASH') {
            this.attackTotalDuration = 0.3 * (1/speedMult);
            const rotY = this.mesh.rotation.y;
            this.velocity.x = Math.sin(rotY) * 60;
            this.velocity.z = Math.cos(rotY) * 60;
            this.velocity.y = 5; 
            this.activeSlashMesh.position.y += 1.2;
            this.activeSlashMesh.rotateY(Math.PI/2);
            this.activeSlashMesh.rotateZ(Math.PI/2); 
            this.activeSlashMesh.translateZ(1.5); 
            this.slashVelocity.copy(forward).multiplyScalar(20); 
        } 
        else if (this.attackType === 'AIR' || this.attackType === 'WALL') {
            this.attackTotalDuration = 0.35 * (1/speedMult);
            const rotY = this.mesh.rotation.y;
            
            if (this.attackType !== 'WALL') {
                this.velocity.x += Math.sin(rotY) * 12;
                this.velocity.z += Math.cos(rotY) * 12;
            }
            
            this.activeSlashMesh.position.y += 1.0;
            this.activeSlashMesh.rotateY(-Math.PI/2); 
            this.activeSlashMesh.rotateZ(-Math.PI/4);
            this.activeSlashMesh.scale.set(2,2,2);
            this.activeSlashMesh.translateZ(1.0);
            this.slashVelocity.y = -2; 
        }
        else {
            const durationMap = [0.25, 0.25, 0.45];
            this.attackTotalDuration = durationMap[this.comboIndex] * (1/speedMult);
            const rotY = this.mesh.rotation.y;
            const lungeSpeed = (this.comboIndex === 2 ? 15 : 8); 
            
            if (!isMagnetized) { 
                this.velocity.x += Math.sin(rotY) * lungeSpeed;
                this.velocity.z += Math.cos(rotY) * lungeSpeed;
            }
            this.kinematics.tiltX.vel += 2.0; 
            
            const currentStep = this.comboIndex;

            if (currentStep === 0) {
                this.activeSlashMesh.position.y += 1.4;
                this.activeSlashMesh.rotateY(-Math.PI/2);
                this.activeSlashMesh.rotateZ(-Math.PI/3);
                this.activeSlashMesh.translateZ(1.0);
                this.activeSlashMesh.scale.set(1.5, 1.5, 1.5);
                this.slashVelocity.copy(forward).multiplyScalar(5);
            } else if (currentStep === 1) {
                this.activeSlashMesh.position.y += 1.2;
                this.activeSlashMesh.rotateX(-Math.PI/2);
                this.activeSlashMesh.rotateZ(Math.PI);
                this.activeSlashMesh.translateZ(1.0);
                this.activeSlashMesh.scale.set(1.5, 1.5, 1.5);
                this.slashVelocity.copy(forward).multiplyScalar(5);
            } else {
                this.activeSlashMesh.position.y += 1.0;
                this.activeSlashMesh.rotateX(-Math.PI/2); 
                this.activeSlashMesh.rotateZ(Math.PI);
                this.activeSlashMesh.scale.set(2.0, 2.0, 2.0);
            }
        }
        
        this.attackTimer = this.attackTotalDuration;
        
        if (this.attackType !== 'MASSIVE' && this.attackType !== 'LAUNCHER') {
            const isHeavy = (this.comboIndex === 2 || this.attackType === 'DASH');
            let slashColor = isHeavy ? 0xff0000 : 0x00ffff;
            if (this.isOverdrive) slashColor = 0xff0055; 
            this.activeSlashMesh.material.color.setHex(slashColor);
        }
        
        this.scene.add(this.activeSlashMesh);

        if (this.attackType === 'GROUND') this.comboIndex++;
        this.comboTimer = this.comboMaxTime;
    }

    updateAttack(dt) {
        if (!this.isAttacking) return;

        this.attackTimer -= dt;
        const progress = 1.0 - (this.attackTimer / this.attackTotalDuration);
        
        const tipLocal = new THREE.Vector3(0, 0, 3.5); 
        this.handR.updateMatrixWorld(true);
        const handWorld = this.handR.matrixWorld; 
        this.currentTipPos.copy(tipLocal).applyMatrix4(handWorld);
        
        if (this.activeSlashMesh) {
            if (progress > 0.5) {
                const fade = 1.0 - ((progress - 0.5) * 2);
                this.activeSlashMesh.material.opacity = fade;
            }
            this.activeSlashMesh.position.add(this.slashVelocity.clone().multiplyScalar(dt));
            const scaleUp = 1.0 + (dt * 2.0);
            this.activeSlashMesh.scale.multiplyScalar(scaleUp);
        }

        const hitStart = 0.05; 
        const hitEnd = 0.7;
        
        if (progress >= hitStart && progress <= hitEnd) {
            this.checkHitsSweeping();
            if (window.flux && window.flux.spawnTrail) {
                window.flux.spawnTrail(this.prevTipPos, this.currentTipPos);
            }
        }
        
        if (this.attackTimer <= 0) {
            this.isAttacking = false;
            this.gravityScale = 1.0; 
            if(this.activeSlashMesh) {
                this.scene.remove(this.activeSlashMesh);
                this.activeSlashMesh = null;
            }
        }
        
        this.prevTipPos.copy(this.currentTipPos);
    }

    checkHitsSweeping() {
        if (!window.flux || !window.flux.enemies) return;
        const enemies = window.flux.enemies;
        
        const playerPos = this.mesh.position;
        const lineStart = this.prevTipPos;
        const lineEnd = this.currentTipPos;
        const lineVec = new THREE.Vector3().subVectors(lineEnd, lineStart);
        const lineLen = lineVec.length();
        
        if (lineLen < 0.1) return; 

        if (this.staticGroup) {
             this.staticGroup.traverse(obj => {
                 if (obj.userData.type === 'barrel' && obj.visible) {
                     if (obj.position.distanceTo(playerPos) < 4.0) {
                         if (window.flux && window.flux.explode) {
                             window.flux.explode(obj.position.clone());
                             obj.position.y = -500;
                             obj.visible = false;
                         }
                     }
                 }
             });
        }

        for(let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            
            if (!enemy || !enemy.userData) continue;
            if (enemy.userData.isDead || (enemy.userData.lastHitBySwing === this.currentSwingId)) continue;

            const enemyPos = enemy.position.clone();
            enemyPos.y += 1.0; 
            
            const toEnemy = new THREE.Vector3().subVectors(enemyPos, lineStart);
            const t = Math.max(0, Math.min(1, toEnemy.dot(lineVec) / (lineLen * lineLen)));
            const closestPoint = new THREE.Vector3().copy(lineStart).add(lineVec.clone().multiplyScalar(t));
            
            const dist = closestPoint.distanceTo(enemyPos);
            
            const hitDist = (this.attackType === 'MASSIVE') ? 4.0 : 2.5;

            if (dist < hitDist) {
                enemy.userData.lastHitBySwing = this.currentSwingId;
                
                this.hitDirection.subVectors(enemy.position, playerPos).normalize();
                if (this.hitDirection.lengthSq() < 0.001) this.hitDirection.set(0, 0, 1);
                this.hitDirection.y = 0.2;
                this.hitDirection.normalize();

                let isCrit = (this.attackType === 'DASH' || this.comboIndex === 3 || this.attackType === 'MASSIVE');

                if (enemy.userData.hp !== undefined) {
                    // DOUBLE DAMAGE UPDATE
                    let dmg = 100; // Was 50
                    
                    if (this.currentStyle === this.STYLE_DAGGER) dmg = 60; // Was 30
                    if (this.currentStyle === this.STYLE_GREATSWORD) dmg = 240; // Was 120

                    if (this.attackType === 'DASH') { dmg *= 1.5; }
                    if (this.comboIndex === 3) { dmg *= 2.0; }
                    if (this.attackType === 'MASSIVE') { dmg *= 3.0; } 
                    
                    if (this.isOverdrive) dmg *= 1.5; 

                    if (enemy.userData.enemyType) {
                        if (enemy.userData.enemyType === 'standard') {
                             dmg = enemy.userData.maxHp + 1; 
                             isCrit = true;
                        } else if (enemy.userData.enemyType === 'gargantua') {
                             dmg *= 0.5; 
                             if (Math.random() > 0.8 && window.flux && window.flux.showDamage) {
                                 window.flux.showDamage(enemy.position, "RESIST", false);
                             }
                        }
                    }
                    
                    enemy.userData.hp -= dmg;
                    
                    if (enemy.userData.springs) {
                        enemy.userData.springs.scale.vel = -5.0; 
                        enemy.userData.springs.tiltX.vel = 5.0; 
                    }

                    if(window.flux && window.flux.showDamage) {
                        window.flux.showDamage(enemy.position, Math.floor(dmg), isCrit);
                    }
                    
                    if (enemy.userData.hp <= 0) {
                        if (window.flux && window.flux.killEnemy) {
                            window.flux.killEnemy(enemy);
                        }
                    } else {
                        this.flashEnemy(enemy);
                        if(window.flux.audio) window.flux.audio.play('hit_flesh');
                        if (window.flux.hitStop) window.flux.hitStop(0.08); 
                        if (window.flux.shake) window.flux.shake(0.3); 
                    }
                }
                
                let force = 0.5; 
                let upForce = 10;
                if (this.attackType === 'DASH') { force = 2.0; upForce = 10; }
                if (this.attackType === 'LAUNCHER') { force = 0.1; upForce = 40; } 
                if (this.attackType === 'MASSIVE') { force = 8.0; upForce = 50; } 
                
                if (enemy.userData.velocity) {
                    this.tempVec.copy(this.hitDirection).multiplyScalar(force * 25); 
                    enemy.userData.velocity.add(this.tempVec);
                    enemy.userData.velocity.y += upForce; 
                    enemy.userData.onGround = false; 
                }
                
                if (dist < 5.0) { 
                    const toEnemy = new THREE.Vector3().subVectors(enemyPos, playerPos).normalize();
                    this.velocity.x *= 0.1;
                    this.velocity.z *= 0.1;
                    
                    if (!this.onGround) {
                        this.velocity.y += 10; 
                    }
                }
                
                if (!this.onGround && this.velocity.y > -10.0 && enemy.userData.hp > 0) {
                    this.dashCooldown = 0;
                    this.jumpBufferTimer = this.jumpBufferMax; 
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("AIR JUGGLE");
                }

                if (window.flux && window.flux.spawnHitParticles) {
                    window.flux.spawnHitParticles(enemy.position, this.hitDirection);
                }
                if (window.flux && window.flux.addCombo) {
                    window.flux.addCombo();
                }
            }
        }
    }

    checkBlockCollision() {
        if (!window.flux || !window.flux.enemies) return;
        const enemies = window.flux.enemies;
        const playerPos = this.mesh.position;

        for(let i=0; i<enemies.length; i++) {
            const enemy = enemies[i];
            if(!enemy || enemy.userData.isDead) continue;
            
            this.tempVec.copy(enemy.position).sub(playerPos);
            const dist = this.tempVec.length();
            if (dist < 2.0) {
                this.tempVec.normalize().multiplyScalar(0.5);
                enemy.position.add(this.tempVec); 
                if (window.flux && window.flux.spawnBlockParticles) {
                    this.tempOrigin.copy(playerPos).add(this.tempVec); 
                    window.flux.spawnBlockParticles(this.tempOrigin);
                }
            }
        }
    }

    checkGround(dt) {
        let highestHit = null;
        let groundFound = false;
        const baseX = this.mesh.position.x;
        const baseY = this.mesh.position.y + 1.0;
        const baseZ = this.mesh.position.z;

        const fallDist = Math.abs(this.velocity.y * dt);
        const checkDist = Math.max(1.2, fallDist + 1.2); 

        this.raycaster.far = checkDist;

        for (let i = 0; i < this.groundOffsets.length; i++) {
            const off = this.groundOffsets[i];
            this.rayOrigin.set(baseX + off.x, baseY + off.y, baseZ + off.z);
            this.raycaster.set(this.rayOrigin, this.downVector);
            
            if (this.staticGroup && this.staticGroup.children.length > 0) {
                const intersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
                
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    if (hit.distance <= checkDist) {
                        if (!highestHit || hit.point.y > highestHit.point.y) {
                            highestHit = hit;
                            groundFound = true;
                        }
                    }
                }
            }
        }
        return groundFound ? highestHit : null;
    }

    checkCeiling(dt) {
        if (this.velocity.y <= 0) return null;

        const checkDist = Math.max(1.0, (this.velocity.y * dt) + 1.0); 
        this.rayOrigin.copy(this.mesh.position);
        this.rayOrigin.y += 1.0; 
        
        this.raycaster.set(this.rayOrigin, this.upVector);
        this.raycaster.far = checkDist;
        
        if (this.staticGroup && this.staticGroup.children.length > 0) {
            const intersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
            if (intersects.length > 0) {
                return intersects[0];
            }
        }
        return null;
    }

    applyPhysics(dt) {
        if (this.isDashing) {
            this.dashTime -= dt;
            this.dashTrailTimer -= dt;
            if (this.dashTrailTimer <= 0) {
                this.dashTrailTimer = 0.04; 
            }
            if (this.dashTime <= 0) {
                this.isDashing = false;
                this.velocity.x *= 0.5;
                this.velocity.z *= 0.5;
            }
        }

        if (!this.isDashing) {
            if (this.isAttacking && !this.onGround && this.velocity.y < 0) {
                this.velocity.y *= 0.1; 
            } else {
                this.velocity.y += this.gravity * this.gravityScale * dt;
            }
            
            if (!this.onGround && this.velocity.y < 0) {
                const groundHit = this.checkGround(dt);
                if (groundHit) {
                    const distToGround = this.mesh.position.y - groundHit.point.y;
                    const targetH = 2.0; 
                    
                    if (distToGround < 4.0) {
                        const error = targetH - distToGround;
                        this.hoverIntegral += error * dt;
                        const derivative = (error - this.hoverErrorPrior) / dt;
                        
                        const output = (this.hoverKP * error) + (this.hoverKI * this.hoverIntegral) + (this.hoverKD * derivative);
                        this.hoverErrorPrior = error;
                        
                        this.velocity.y += output * dt;
                    }
                }
            }
        }

        if (this.velocity.y > 0) {
            const ceilingHit = this.checkCeiling(dt);
            if (ceilingHit) {
                this.velocity.y = 0;
            }
        }

        if (this.velocity.lengthSq() > 10000) {
            this.velocity.set(0,0,0); 
        }

        const nextX = this.mesh.position.x + this.velocity.x * dt;
        const nextZ = this.mesh.position.z + this.velocity.z * dt;
        
        this.tempVec.set(nextX, this.mesh.position.y, nextZ);
        
        const wallHit = this.checkWallCollision(dt);
        
        if (this.wallMagnetismTimer > 0 && wallHit.normal) {
             const pushForce = wallHit.normal.clone().multiplyScalar(-250 * dt); 
             this.velocity.add(pushForce);
             
             const vDotN = this.velocity.dot(wallHit.normal);
             if (vDotN > 0) {
                 this.velocity.sub(wallHit.normal.clone().multiplyScalar(vDotN));
             }
        }
        
        if (wallHit.collision && wallHit.normal) {
            this.touchingWall = true;
            this.wallNormal.copy(wallHit.normal);
            const vDotN = this.velocity.dot(wallHit.normal);
            
            if (vDotN < 0) {
                const slideX = this.velocity.x - (vDotN * wallHit.normal.x);
                const slideZ = this.velocity.z - (vDotN * wallHit.normal.z);
                this.velocity.x = slideX;
                this.velocity.z = slideZ;
                this.mesh.position.x += this.velocity.x * dt;
                this.mesh.position.z += this.velocity.z * dt;
            } else {
                this.mesh.position.x += this.velocity.x * dt;
                this.mesh.position.z += this.velocity.z * dt;
            }
        } else {
            this.touchingWall = false;
            this.isWallRunning = false;
            this.mesh.position.x += this.velocity.x * dt;
            this.mesh.position.z += this.velocity.z * dt;
        }

        const nextY = this.mesh.position.y + this.velocity.y * dt;
        const groundHit = this.checkGround(dt);
        
        if (groundHit && this.velocity.y <= 0) {
            if (this.velocity.y < -15) {
                this.landingLag = 0.4; 
                this.kinematics.crouch.vel += Math.abs(this.velocity.y) * 1.5; 
                this.kinematics.tiltX.vel += 5.0;
                
                if (window.flux && window.flux.shake) window.flux.shake(0.2);
                if (window.flux.audio) window.flux.audio.play('land_heavy');
            } else if (this.velocity.y < -2) {
                this.kinematics.crouch.vel += 5.0; 
                if (window.flux.audio) window.flux.audio.play('step');
            }
            
            this.mesh.position.y = groundHit.point.y;
            this.velocity.y = 0;
            this.onGround = true;
            this.touchingWall = false;
            this.isWallRunning = false;
            
            this.hoverIntegral = 0;
            this.hoverErrorPrior = 0;
        } else {
            this.onGround = false;
            this.mesh.position.y = nextY;
            
            if (this.mesh.position.y < -20) {
                 this.mesh.position.set(0, 10, 0);
                 this.velocity.set(0,0,0);
            }
        }
    }

    updateAnimations(dt) {
        const localVel = this.velocity.clone().applyQuaternion(this.mesh.quaternion.clone().invert());
        const speed = Math.sqrt(this.velocity.x**2 + this.velocity.z**2);
        
        // --- MAGIC SHELL ANIMATION UPDATE ---
        // Animate the reveal uniform
        if (this.matArmor && this.matArmor.uniforms) {
            // Target reveal based on state
            const targetReveal = this.isDead ? 0.0 : 1.0;
            
            // Smoothly interpolate
            const diff = targetReveal - this.shellReveal;
            this.shellReveal += diff * this.shellRevealSpeed * dt * 5.0;
            
            // Apply to uniforms
            this.matArmor.uniforms.uReveal.value = this.shellReveal;
            this.matArmor.uniforms.uTime.value += dt;
            
            if (this.matArmorDark) {
                this.matArmorDark.uniforms.uReveal.value = this.shellReveal;
                this.matArmorDark.uniforms.uTime.value += dt;
            }
        }
        
        this.kinematics.tiltX.target = (localVel.z * 0.02); 
        this.kinematics.tiltZ.target = -(localVel.x * 0.02);
        
        if (!this.isAttacking) {
            this.kinematics.weaponSwayX.target = localVel.z * 0.01;
            this.kinematics.weaponSwayY.target = -localVel.x * 0.01;
        } else {
            this.kinematics.weaponSwayX.target = 0;
            this.kinematics.weaponSwayY.target = 0;
        }

        this.kinematics.crouch.target = 0; 

        const currentRotY = this.mesh.rotation.y;
        let deltaRot = currentRotY - this.lastRotY;
        while (deltaRot > Math.PI) deltaRot -= Math.PI * 2;
        while (deltaRot < -Math.PI) deltaRot += Math.PI * 2;
        this.lastRotY = currentRotY;
        this.kinematics.spineLean.target = -deltaRot * 10.0; 

        for(let k in this.kinematics) {
            this.updateSpring(this.kinematics[k], dt);
        }

        this.visualGroup.position.set(0, 0, 0);
        this.visualGroup.rotation.set(0, 0, 0);
        
        this.visualGroup.rotation.x = this.kinematics.tiltX.pos;
        this.visualGroup.rotation.z = this.kinematics.tiltZ.pos;
        
        const squash = Math.max(0, this.kinematics.crouch.pos * 0.01);
        const stretch = 1.0 - squash;
        const bulge = 1.0 + (squash * 0.5);
        this.visualGroup.scale.set(bulge, stretch, bulge);
        this.visualGroup.position.y -= squash; 

        if(this.spine) {
            this.spine.rotation.y = this.kinematics.spineLean.pos * 0.5 + this.kinematics.chestTwist.pos;
            this.spine.rotation.z = this.kinematics.tiltZ.pos * 0.3; 
        }
        
        if(this.head) {
            this.head.rotation.x = -this.kinematics.tiltX.pos * 0.8;
            this.head.rotation.z = -this.kinematics.tiltZ.pos * 0.8;
        }
        
        if (this.binderL && this.binderR) {
            const wingOpen = Math.min(1.0, speed / 15) + (this.isDashing ? 1.0 : 0);
            const targetRot = 0.2 + (wingOpen * 0.6);
            
            this.binderL.rotation.z = -targetRot;
            this.binderR.rotation.z = targetRot;
            
            if (this.binderL.userData.flap) this.binderL.userData.flap.rotation.z = -wingOpen * 0.8;
            if (this.binderR.userData.flap) this.binderR.userData.flap.rotation.z = wingOpen * 0.8;

            this.binderL.rotation.x = 0.2 + (localVel.z * 0.015);
            this.binderR.rotation.x = 0.2 + (localVel.z * 0.015);
        }

        this.animTime += dt * 2; 
        
        const bob = Math.sin(this.animTime * 3) * 0.15;
        this.visualGroup.position.y += bob;
        
        const airFactor = this.onGround ? 0 : 1;
        const dashFactor = this.isDashing ? 1 : 0;
        
        const tuckYAir = -0.5 + Math.sin(this.animTime * 5) * 0.1; 
        const tuckYGround = -1.2;
        let tuckY = tuckYGround + (tuckYAir - tuckYGround) * airFactor;
        
        const trailZ = -0.4 - (Math.min(speed, 20) * 0.03) + (airFactor * 0.3) + (dashFactor * -0.5); 
        const legSpread = 0.15 + (airFactor * 0.1); 
        
        const sway = Math.sin(this.animTime * 5) * 0.05;
        
        tuckY = this.isDashing ? -0.8 : tuckY;
        
        const targetL = new THREE.Vector3(this.hipWidth + legSpread, tuckY + sway, trailZ);
        const targetR = new THREE.Vector3(-this.hipWidth - legSpread, tuckY - sway, trailZ);
        
        this.solveIK(this.legL, targetL);
        this.solveIK(this.legR, targetR);
        
        if (!this.isAttacking && !this.isBlocking && !this.isCharging && this.currentWeapon === this.WEAPON_MELEE && !this.isReloading) {
            const flightFactor = Math.min(1.0, speed / 5);
            this.armL.rotation.x = -0.2 - (flightFactor * 0.5);
            this.armR.rotation.x = -0.2 - (flightFactor * 0.5);
            this.armL.rotation.z = 0.3 + (flightFactor * 0.2);
            this.armR.rotation.z = -0.3 - (flightFactor * 0.2);
        }

        if (this.isDashing) {
            this.visualGroup.rotation.x = 0.8; 
        } 

        if (!this.isAttacking && !this.isBlocking && !this.isCharging && !this.isReloading) {
            
            if (this.currentWeapon === this.WEAPON_MELEE) {
                this.handR.rotation.x = this.kinematics.weaponSwayX.pos;
                this.handR.rotation.z = this.kinematics.weaponSwayY.pos;
                
                if (this.currentStyle === this.STYLE_GREATSWORD) {
                    this.handR.rotation.x += 0.5;
                    this.handR.rotation.z += 0.5;
                }
            } else {
                this.armR.rotation.set(-1.5, 0, 0); 
                this.armL.rotation.set(-1.5, 0.5, 0); 
                this.handR.rotation.set(0, 0, 0);
                
                this.armR.rotation.x += this.kinematics.weaponSwayX.pos * 0.5;
                this.armR.rotation.y += this.kinematics.weaponSwayY.pos * 0.5;
                
                if (this.fireTimer > (this.fireRate - 0.1)) {
                    this.armR.rotation.x += 0.2; 
                }
            }
        }
        
        if (this.isReloading) {
            this.armR.rotation.set(-1.0, 0.5, 0);
            this.armL.rotation.set(-1.0, -0.5, 0);
            this.handR.rotation.set(0, 0, Math.PI/4);
            const cycle = (this.reloadTimer % 0.5) / 0.5;
            this.armL.position.z = cycle * 0.1; 
        } else {
            this.armL.position.z = 0;
        }

        if (this.isCharging) {
            this.armR.rotation.set(-1.0, 0, 0.5);
            this.handR.rotation.set(0, 0, Math.PI/2);
            this.visualGroup.position.x += (Math.random() - 0.5) * 0.05;
            this.visualGroup.position.z += (Math.random() - 0.5) * 0.05;
        }

        if (this.isBlocking) {
            this.armR.rotation.set(-0.5, 0.5, 0); 
            this.handR.rotation.set(0, 0, Math.PI/2); 
        } 

        if (this.isAttacking) {
            const progress = 1.0 - (this.attackTimer / this.attackTotalDuration);
            const p = 1 - (1 - progress) * (1 - progress); 
            
            if (this.attackType === 'MASSIVE') {
                const startX = -Math.PI; 
                const endX = 0.5;
                this.armR.rotation.set(startX + (endX - startX) * p, 0, 0);
                this.handR.rotation.set(0, 0, 0);
            }
            else if (this.attackType === 'LAUNCHER') {
                 const startX = -0.5;
                 const endX = -Math.PI;
                 this.armR.rotation.set(startX + (endX - startX) * p, 0, 0);
                 this.handR.rotation.set(0, 0, 0);
                 this.visualGroup.rotation.x = -0.5 * p; 
            }
            else if (this.attackType === 'DASH') {
                this.visualGroup.rotation.x = 0.5; 
                this.armR.rotation.x = -Math.PI/2; 
                this.handR.rotation.x = Math.PI/2; 
            }
            else if (this.attackType === 'AIR' || this.attackType === 'WALL') {
                const startRot = -Math.PI/4;
                const endRot = Math.PI * 3;
                this.visualGroup.rotation.y = startRot + (endRot - startRot) * p; 
                this.visualGroup.rotation.x = -0.5; 
                this.armR.rotation.x = -1.0; 
                this.armR.rotation.z = Math.sin(p * Math.PI * 4) * 0.5; 
                this.handR.rotation.x = 0;
            }
            else {
                const currentStep = this.activeComboStep;
                if (currentStep === 0) {
                    const startX = -Math.PI/2; 
                    const endX = 0.5;
                    this.armR.rotation.set(startX + (endX - startX) * p, 0, 0);
                    this.handR.rotation.set(0, 0, 0); 
                } 
                else if (currentStep === 1) {
                    const startY = -0.5; 
                    const endY = Math.PI;
                    this.armR.rotation.set(0, startY + (endY - startY) * p, 0);
                    this.handR.rotation.set(0, 0, -Math.PI/2); 
                } 
                else {
                    this.visualGroup.rotation.y += p * Math.PI * 2;
                    this.armR.rotation.set(0, 0, -Math.PI/2); 
                    this.handR.rotation.set(0, 0, 0); 
                }
            }
        } 
        else if (!this.isBlocking && !this.isCharging && this.currentWeapon === this.WEAPON_MELEE && !this.isReloading) {
            this.armR.rotation.z = 0.1;
        }
    }

    solveIK(leg, targetPos) {
        const l1 = this.thighLen;
        const l2 = this.shinLen;
        
        const dist = targetPos.length();
        const maxLen = l1 + l2 - 0.01;
        const clampedDist = Math.min(dist, maxLen);
        const validTarget = targetPos.clone().normalize().multiplyScalar(clampedDist);
        
        const cosKnee = (l1*l1 + l2*l2 - clampedDist*clampedDist) / (2 * l1 * l2);
        const kneeAngle = Math.acos(Math.max(-1, Math.min(1, cosKnee)));
        
        const cosAlpha = (l1*l1 + clampedDist*clampedDist - l2*l2) / (2 * l1 * clampedDist);
        const alpha = Math.acos(Math.max(-1, Math.min(1, cosAlpha)));
        
        const dy = validTarget.y;
        const dz = validTarget.z;
        const targetAngle = Math.atan2(dz, -dy); 
        
        const hipPitch = targetAngle + alpha;
        const kneeBend = Math.PI - kneeAngle;
        
        leg.root.rotation.x = hipPitch;
        leg.knee.rotation.x = -kneeBend; 
        leg.root.rotation.z = -validTarget.x * 1.5;
    }

    checkWallCollision(dt) {
        const checkDist = 1.5; 
        this.rayOrigin.copy(this.mesh.position);
        this.rayOrigin.y += 1.0; 
        
        const rotY = this.mesh.rotation.y;
        const forward = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
        const left45 = forward.clone().applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI/4);
        const right45 = forward.clone().applyAxisAngle(new THREE.Vector3(0,1,0), -Math.PI/4);
        
        const directions = [
            forward,
            left45,
            right45,
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 0, -1)
        ];

        for (let dir of directions) {
            this.raycaster.set(this.rayOrigin, dir);
            this.raycaster.far = checkDist;
            
            if (this.staticGroup && this.staticGroup.children.length > 0) {
                const intersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
                if (intersects.length > 0) {
                    return { collision: true, normal: intersects[0].face.normal.clone() };
                }
            }
        }
        return { collision: false, normal: null };
    }

    updateHUD() {
        const weaponName = document.getElementById('weapon-name');
        const ammoCount = document.getElementById('ammo-count');
        const reloadMsg = document.getElementById('reload-msg');
        
        if (weaponName && ammoCount) {
            if (this.currentWeapon === this.WEAPON_MELEE) {
                let styleName = "KATANA";
                if (this.currentStyle === this.STYLE_DAGGER) styleName = "DAGGER";
                if (this.currentStyle === this.STYLE_GREATSWORD) styleName = "GREATSWORD";
                weaponName.innerText = styleName;
                ammoCount.innerText = "---";
                ammoCount.style.color = "#aaa";
            } else if (this.currentWeapon === this.WEAPON_BEAM) {
                weaponName.innerText = "BEAM RIFLE";
                ammoCount.innerText = this.ammo;
                ammoCount.style.color = (this.ammo > 0) ? "#0ff" : "#f00";
            } else {
                weaponName.innerText = "AVENGER";
                ammoCount.innerText = this.ammo;
                ammoCount.style.color = (this.ammo > 0) ? "#0f0" : "#f00";
            }
        }
        
        if (reloadMsg) {
            if (this.isReloading) reloadMsg.classList.remove('hidden');
            else reloadMsg.classList.add('hidden');
        }
        
        // Shield Bar Logic (Dynamically created if missing)
        let shieldContainer = document.getElementById('shield-bar-container');
        if (!shieldContainer) {
            const hpContainer = document.querySelector('.hud-top-left');
            if (hpContainer) {
                shieldContainer = document.createElement('div');
                shieldContainer.id = 'shield-bar-container';
                shieldContainer.innerHTML = '<div id="shield-bar"></div>';
                hpContainer.prepend(shieldContainer);
            }
        }
        
        if (shieldContainer) {
            const shieldBar = document.getElementById('shield-bar');
            if (this.isShieldBroken) {
                shieldContainer.classList.remove('active');
            } else if (this.shieldHp < this.shieldMaxHp) {
                shieldContainer.classList.add('active');
                if(shieldBar) shieldBar.style.width = (this.shieldHp / this.shieldMaxHp * 100) + '%';
            } else {
                // Full shield, hide bar to reduce clutter? Or keep it?
                // Let's hide it when full to be clean
                shieldContainer.classList.remove('active');
            }
        }
    }
}</script>
    <script>/**
 * ADVANCED MECH DRONE ENEMY SYSTEM
 * Multiple drone types with unique behaviors, attacks, and movement patterns.
 * Designed to integrate with existing player.js collision logic.
 * UPDATED: Added GARGANTUA Boss Drone with Death Ray.
 * UPDATED: Added ANUBIS Boss (Wave 6) with Cinematic Entrance and Advanced AI.
 */

class MechDroneEnemy {
    constructor(scene, type = 'standard', position = new THREE.Vector3()) {
        this.scene = scene;
        this.type = type;
        this.group = new THREE.Group();
        
        // Base stats
        this.config = this.getDroneConfig(type);
        
        // Initialize UserData (Critical for Player.js compatibility)
        this.group.userData = {
            type: 'enemy',
            enemyType: type,
            hp: this.config.maxHp,
            maxHp: this.config.maxHp,
            velocity: new THREE.Vector3(),
            isDead: false,
            controller: this, // Link back to this class instance
            onGround: false, // Drones fly
            springs: { // For hit deformation
                scale: { pos: 1, vel: 0, target: 1, k: 200, d: 15 },
                tiltX: { pos: 0, vel: 0, target: 0, k: 150, d: 12 },
                tiltZ: { pos: 0, vel: 0, target: 0, k: 150, d: 12 }
            }
        };

        this.state = 'SPAWNING';
        this.attackCooldown = 0;
        
        // Movement
        this.targetPosition = position.clone();
        this.patrolPoints = [];
        this.currentPatrolIndex = 0;
        
        // Combat
        this.aggroRange = this.config.aggroRange;
        this.attackRange = this.config.attackRange;
        
        // Visual effects
        this.damageFlashTimer = 0;
        this.deathExplosion = false;
        
        this.initMesh();
        this.setPosition(position);
        this.initBehavior();
    }
    
    getDroneConfig(type) {
        const configs = {
            'standard': { maxHp: 80, speed: 8, aggroRange: 25, attackRange: 15, attackCooldown: 2.0, color: 0xff4444, size: 1.0 },
            'sniper': { maxHp: 60, speed: 6, aggroRange: 40, attackRange: 35, attackCooldown: 3.0, color: 0x4444ff, size: 0.8 },
            'assault': { maxHp: 120, speed: 12, aggroRange: 20, attackRange: 8, attackCooldown: 1.5, color: 0xffaa00, size: 1.2 },
            'support': { maxHp: 100, speed: 5, aggroRange: 30, attackRange: 20, attackCooldown: 4.0, color: 0x00ff44, size: 1.1 },
            'bomber': { maxHp: 150, speed: 4, aggroRange: 15, attackRange: 10, attackCooldown: 5.0, color: 0x880000, size: 1.5 },
            'gargantua': { maxHp: 2000, speed: 3, aggroRange: 60, attackRange: 40, attackCooldown: 6.0, color: 0xaa00aa, size: 4.0 } // BOSS
        };
        return configs[type] || configs['standard'];
    }
    
    initMesh() {
        let mesh;
        if (typeof AssetFactory !== 'undefined') {
            if (this.type === 'gargantua') {
                mesh = AssetFactory.createMechDrone(); // Reuse mesh but scale up
                mesh.scale.set(4, 4, 4);
            } else {
                mesh = AssetFactory.createMechDrone();
            }
        } else {
            // Fallback
            mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({color: this.config.color}));
        }
        
        this.group.add(mesh);
        
        // Customize Appearance based on type
        this.customizeAppearance();
        
        // Add health bar
        this.initHealthBar();
    }
    
    customizeAppearance() {
        // Apply type-specific color variations
        this.group.traverse((child) => {
            if (child.isMesh && child.material) {
                // Clone material to allow unique colors per instance
                if (!child.userData.matCloned) {
                    child.material = child.material.clone();
                    child.userData.matCloned = true;
                }
                
                if (child.material.emissive) {
                    child.material.emissive = new THREE.Color(this.config.color).multiplyScalar(0.5);
                }
            }
        });
    }
    
    initHealthBar() {
        const barWidth = this.config.size * 1.5;
        const barHeight = 0.1 * (this.type === 'gargantua' ? 3 : 1);
        
        this.healthBarBg = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth, barHeight),
            new THREE.MeshBasicMaterial({ color: 0x000000, depthTest: false })
        );
        this.healthBarBg.position.y = this.config.size + 0.5;
        
        this.healthBar = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth - 0.05, barHeight - 0.05),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false })
        );
        this.healthBar.position.y = this.config.size + 0.5;
        this.healthBar.position.z = 0.01;
        
        this.group.add(this.healthBarBg);
        this.group.add(this.healthBar);
    }
    
    initBehavior() {
        switch(this.type) {
            case 'sniper': this.patrolPoints = this.generateSniperPositions(); break;
            case 'assault': this.patrolPoints = this.generateAssaultPattern(); break;
            case 'support': this.patrolPoints = this.generateSupportPositions(); break;
            case 'bomber': this.patrolPoints = this.generateBomberPath(); break;
            case 'gargantua': this.patrolPoints = this.generateBossPath(); break;
            default: this.patrolPoints = this.generateStandardPatrol();
        }
    }
    
    update(dt, player) {
        // Sync local HP with UserData HP (Player.js modifies UserData directly)
        if (this.group.userData.hp <= 0 && !this.group.userData.isDead) {
            this.handleDeath();
            return;
        }
        
        if (this.group.userData.isDead) return;

        this.updateState(player);
        this.updateMovement(dt, player);
        this.updateCombat(dt, player); // Fixed: Method now exists
        this.updateVisuals(dt);
        this.updateHealthBar();
    }
    
    updateCombat(dt, player) {
        this.attackCooldown -= dt;
        this.damageFlashTimer -= dt;
    }
    
    updateState(player) {
        if (this.state === 'SPAWNING') {
            this.state = 'PATROLLING';
            return;
        }
        
        const distanceToPlayer = this.group.position.distanceTo(player.mesh.position);
        
        if (distanceToPlayer <= this.attackRange && this.attackCooldown <= 0) {
            this.state = 'ATTACKING';
        } else if (distanceToPlayer <= this.aggroRange) {
            this.state = 'CHASING';
        } else {
            this.state = 'PATROLLING';
        }
    }
    
    updateMovement(dt, player) {
        const currentPos = this.group.position;
        const velocity = this.group.userData.velocity;

        switch(this.state) {
            case 'PATROLLING': this.patrolBehavior(dt); break;
            case 'CHASING': this.chaseBehavior(dt, player); break;
            case 'ATTACKING': this.attackBehavior(dt, player); break;
        }
        
        // Apply velocity with damping
        velocity.multiplyScalar(0.9);
        
        // Apply physics movement
        this.group.position.add(velocity.clone().multiplyScalar(dt));
        
        // Keep above ground
        if (this.group.position.y < 2) {
            this.group.position.y += (2 - this.group.position.y) * 5 * dt;
            velocity.y *= 0.5;
        }
        
        // Look at target
        this.updateRotation(player);
    }
    
    patrolBehavior(dt) {
        if (this.patrolPoints.length === 0) return;
        const targetPoint = this.patrolPoints[this.currentPatrolIndex];
        const direction = new THREE.Vector3().subVectors(targetPoint, this.group.position);
        
        if (direction.length() < 2.0) {
            this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;
        } else {
            direction.normalize();
            this.group.userData.velocity.add(direction.multiplyScalar(this.config.speed * dt));
        }
    }
    
    chaseBehavior(dt, player) {
        const direction = new THREE.Vector3().subVectors(player.mesh.position, this.group.position);
        
        switch(this.type) {
            case 'sniper': // Maintain distance
                const idealDistance = this.attackRange * 0.8;
                if (direction.length() < idealDistance) direction.multiplyScalar(-1);
                break;
            case 'support': // Stay at medium range
                const supportDistance = this.attackRange * 0.6;
                if (direction.length() < supportDistance) direction.normalize().multiplyScalar(supportDistance - direction.length());
                break;
            case 'gargantua': // Slow relentless advance
                // Just keep moving towards player
                break;
        }
        
        direction.normalize();
        this.group.userData.velocity.add(direction.multiplyScalar(this.config.speed * 1.5 * dt));
    }
    
    attackBehavior(dt, player) {
        switch(this.type) {
            case 'sniper': this.group.userData.velocity.multiplyScalar(0.5); break;
            case 'assault': // Circle strafe
                const sideVector = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3().subVectors(player.mesh.position, this.group.position)).normalize();
                this.group.userData.velocity.add(sideVector.multiplyScalar(this.config.speed * dt));
                break;
            case 'bomber': // Charge
                const chargeDir = new THREE.Vector3().subVectors(player.mesh.position, this.group.position).normalize();
                this.group.userData.velocity.add(chargeDir.multiplyScalar(this.config.speed * 2 * dt));
                break;
            case 'gargantua':
                this.group.userData.velocity.multiplyScalar(0.1); // Stop to fire
                break;
        }
        this.executeAttack(player);
    }
    
    executeAttack(player) {
        if (this.attackCooldown > 0) return;
        
        switch(this.type) {
            case 'standard': this.standardAttack(player); break;
            case 'sniper': this.sniperAttack(player); break;
            case 'assault': this.assaultAttack(player); break;
            case 'support': this.supportAttack(player); break;
            case 'bomber': this.bomberAttack(player); break;
            case 'gargantua': this.gargantuaAttack(player); break;
        }
        this.attackCooldown = this.config.attackCooldown;
    }
    
    standardAttack(player) {
        const startPos = this.group.position.clone();
        const direction = new THREE.Vector3().subVectors(player.mesh.position, startPos).normalize();
        if (window.flux && window.flux.spawnEnemyProjectile) window.flux.spawnEnemyProjectile(startPos, direction);
        this.muzzleFlash();
    }
    
    sniperAttack(player) {
        const startPos = this.group.position.clone();
        const direction = new THREE.Vector3().subVectors(player.mesh.position, startPos).normalize();
        this.laserSight(player.mesh.position);
        setTimeout(() => {
            if (!this.group.userData.isDead && window.flux && window.flux.spawnEnemyProjectile) {
                window.flux.spawnEnemyProjectile(startPos, direction);
                window.flux.spawnEnemyProjectile(startPos, direction);
            }
        }, 500);
        this.muzzleFlash(0x4444ff);
    }
    
    assaultAttack(player) {
        const burstCount = 3;
        const burstDelay = 100;
        for (let i = 0; i < burstCount; i++) {
            setTimeout(() => {
                if (!this.group.userData.isDead) {
                    const startPos = this.group.position.clone();
                    const spread = new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2);
                    const direction = new THREE.Vector3().subVectors(player.mesh.position, startPos).add(spread).normalize();
                    if (window.flux && window.flux.spawnEnemyProjectile) window.flux.spawnEnemyProjectile(startPos, direction);
                    if (i === burstCount - 1) this.muzzleFlash(0xffaa00);
                }
            }, i * burstDelay);
        }
    }
    
    supportAttack(player) {
        // Heal allies
        if (window.flux && window.flux.enemies) {
            window.flux.enemies.forEach(enemyGroup => {
                const enemy = enemyGroup.userData.controller;
                if (enemy && enemy !== this && !enemyGroup.userData.isDead && enemyGroup.userData.hp < enemy.config.maxHp) {
                    const distance = this.group.position.distanceTo(enemyGroup.position);
                    if (distance < 15) {
                        enemyGroup.userData.hp = Math.min(enemy.config.maxHp, enemyGroup.userData.hp + 10);
                        if (window.flux.spawnParticles) window.flux.spawnParticles(enemyGroup.position, 5, 0x00ff44, 3);
                    }
                }
            });
        }
        this.supportBeam();
    }
    
    bomberAttack(player) {
        const bombPos = player.mesh.position.clone();
        bombPos.y = 0;
        const bombGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const bombMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bomb = new THREE.Mesh(bombGeo, bombMat);
        bomb.position.copy(this.group.position);
        bomb.userData = { type: 'bomb', life: 3.0, velocity: new THREE.Vector3(0, 10, 0) };
        this.scene.add(bomb);
        
        const arcDirection = new THREE.Vector3().subVectors(bombPos, this.group.position).normalize();
        bomb.userData.velocity.x = arcDirection.x * 8;
        bomb.userData.velocity.z = arcDirection.z * 8;
        
        const bombUpdate = () => {
            if (bomb.userData.life > 0) {
                bomb.userData.life -= 0.016;
                bomb.userData.velocity.y -= 0.5; 
                bomb.position.add(bomb.userData.velocity.clone().multiplyScalar(0.016));
                if (bomb.position.y <= 0.5) {
                    if(window.flux.explode) window.flux.explode(bomb.position);
                    this.scene.remove(bomb);
                    return;
                }
                requestAnimationFrame(bombUpdate);
            } else {
                if(window.flux.explode) window.flux.explode(bomb.position);
                this.scene.remove(bomb);
            }
        };
        bombUpdate();
    }
    
    gargantuaAttack(player) {
        // 1. Charge Up
        if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("ENERGY SURGE DETECTED");
        if (window.flux && window.flux.audio) window.flux.audio.play('charge');
        
        // Visual Charge
        if (window.flux.spawnChargeParticles) window.flux.spawnChargeParticles(this.group.position);
        
        // 2. Fire Beam after delay
        setTimeout(() => {
            if (this.group.userData.isDead) return;
            
            const start = this.group.position.clone();
            const end = player.mesh.position.clone();
            
            // Overshoot the beam
            const dir = new THREE.Vector3().subVectors(end, start).normalize();
            const farEnd = start.clone().add(dir.multiplyScalar(100));
            
            if (window.flux && window.flux.fireBossBeam) {
                window.flux.fireBossBeam(start, farEnd, 1.5, 4.0); // 1.5s duration, 4.0 width
            }
            
            if (window.flux && window.flux.audio) window.flux.audio.play('laser_fire');
            if (window.flux && window.flux.shake) window.flux.shake(2.0);
            
        }, 1000);
        
        // 3. Carpet Bomb follow up
        setTimeout(() => {
             if (this.group.userData.isDead) return;
             this.carpetBomb(player);
        }, 2000);
    }
    
    carpetBomb(player) {
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                if (!this.group.userData.isDead) {
                    const bombPos = player.mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10));
                    const bombGeo = new THREE.SphereGeometry(0.6, 8, 8);
                    const bombMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                    const bomb = new THREE.Mesh(bombGeo, bombMat);
                    bomb.position.copy(this.group.position);
                    bomb.userData = { type: 'bomb', life: 3.0, velocity: new THREE.Vector3(0, 15, 0) };
                    this.scene.add(bomb);
                    
                    const arcDirection = new THREE.Vector3().subVectors(bombPos, this.group.position).normalize();
                    bomb.userData.velocity.x = arcDirection.x * 12;
                    bomb.userData.velocity.z = arcDirection.z * 12;
                    
                    const bombUpdate = () => {
                        if (bomb.userData.life > 0) {
                            bomb.userData.life -= 0.016;
                            bomb.userData.velocity.y -= 0.5; 
                            bomb.position.add(bomb.userData.velocity.clone().multiplyScalar(0.016));
                            if (bomb.position.y <= 0.5) {
                                if(window.flux.explode) window.flux.explode(bomb.position);
                                this.scene.remove(bomb);
                                return;
                            }
                            requestAnimationFrame(bombUpdate);
                        } else {
                            if(window.flux.explode) window.flux.explode(bomb.position);
                            this.scene.remove(bomb);
                        }
                    };
                    bombUpdate();
                }
            }, i * 300);
        }
    }

    laserSight(targetPos) {
        const startPos = this.group.position.clone();
        const direction = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
        const endPos = startPos.clone().add(direction.multiplyScalar(50));
        if (window.flux && window.flux.spawnTrail) window.flux.spawnTrail(startPos, endPos);
    }

    supportBeam() {
        if (window.flux && window.flux.enemies) {
            window.flux.enemies.forEach(enemyGroup => {
                if (enemyGroup !== this.group && !enemyGroup.userData.isDead && enemyGroup.userData.hp < enemyGroup.userData.maxHp) {
                    if (this.group.position.distanceTo(enemyGroup.position) < 15) {
                         if (window.flux.spawnTrail) window.flux.spawnTrail(this.group.position, enemyGroup.position);
                    }
                }
            });
        }
    }

    muzzleFlash(color = 0xffffff) {
        const flashGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const flashMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const flash = new THREE.Mesh(flashGeo, flashMat);
        flash.position.copy(this.group.position);
        this.scene.add(flash);
        let scale = 1.0;
        const animateFlash = () => {
            scale += 0.2;
            flash.scale.set(scale, scale, scale);
            flashMat.opacity -= 0.1;
            if (flashMat.opacity > 0) requestAnimationFrame(animateFlash);
            else this.scene.remove(flash);
        };
        animateFlash();
    }

    updateRotation(player) {
        const targetPos = this.state === 'PATROLLING' && this.patrolPoints.length > 0 ? this.patrolPoints[this.currentPatrolIndex] : player.mesh.position;
        const direction = new THREE.Vector3().subVectors(targetPos, this.group.position);
        direction.y = 0;
        if (direction.length() > 0.1) {
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction.normalize());
            this.group.quaternion.slerp(targetQuat, 0.1);
        }
    }

    updateVisuals(dt) {
        if (this.damageFlashTimer > 0) {
            const flashIntensity = this.damageFlashTimer * 5;
            this.group.traverse(child => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(0xff0000).multiplyScalar(flashIntensity);
                }
            });
        }
        this.group.position.y += Math.sin(Date.now() * 0.005) * 0.02;
    }

    updateHealthBar() {
        if (!this.healthBar) return;
        const healthPercent = this.group.userData.hp / this.config.maxHp;
        this.healthBar.scale.x = Math.max(0, healthPercent);
        if (healthPercent > 0.6) this.healthBar.material.color.setHex(0x00ff00);
        else if (healthPercent > 0.3) this.healthBar.material.color.setHex(0xffff00);
        else this.healthBar.material.color.setHex(0xff0000);
        
        if (window.camera) {
            this.healthBar.lookAt(window.camera.position);
            this.healthBarBg.lookAt(window.camera.position);
        }
    }

    handleDeath() {
        if (this.group.userData.isDead) return;
        this.group.userData.isDead = true;
        
        // Trigger Spectacle
        if (window.flux && window.flux.killEnemy) {
            window.flux.killEnemy(this.group);
        } else {
            // Fallback
            this.group.visible = false;
            this.group.position.y = -500;
        }
    }
    
    // Patrol generators
    generateStandardPatrol() {
        const points = [];
        const basePos = this.group.position.clone();
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            points.push(new THREE.Vector3(basePos.x + Math.cos(angle) * 10, basePos.y + Math.random() * 3, basePos.z + Math.sin(angle) * 10));
        }
        return points;
    }
    generateSniperPositions() {
        const basePos = this.group.position.clone();
        return [
            new THREE.Vector3(basePos.x + 8, 12, basePos.z),
            new THREE.Vector3(basePos.x - 8, 15, basePos.z + 5),
            new THREE.Vector3(basePos.x + 5, 10, basePos.z - 8)
        ];
    }
    generateAssaultPattern() {
        const points = [];
        const basePos = this.group.position.clone();
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            points.push(new THREE.Vector3(basePos.x + Math.cos(angle) * 6, basePos.y + 3, basePos.z + Math.sin(angle) * 6));
        }
        return points;
    }
    generateSupportPositions() {
        const basePos = this.group.position.clone();
        return [
            new THREE.Vector3(basePos.x + 6, 8, basePos.z + 6),
            new THREE.Vector3(basePos.x - 6, 7, basePos.z - 6)
        ];
    }
    generateBomberPath() {
        const points = [];
        const basePos = this.group.position.clone();
        for (let i = 0; i < 4; i++) {
            points.push(new THREE.Vector3(basePos.x + (i - 2) * 8, 20, basePos.z + (i % 2) * 10 - 5));
        }
        return points;
    }
    generateBossPath() {
        const points = [];
        // Boss moves in a large figure 8
        for (let i = 0; i < 8; i++) {
            const t = (i / 8) * Math.PI * 2;
            points.push(new THREE.Vector3(Math.sin(t) * 20, 15, Math.sin(t * 2) * 10));
        }
        return points;
    }
    
    setPosition(position) {
        this.group.position.copy(position);
        this.targetPosition.copy(position);
    }
}

/**
 * ANUBIS BOSS CLASS
 * Sleek, Fast, Stronger than player.
 * Implements cinematic entrance and high-speed combat.
 */
class AnubisBoss {
    constructor(scene, position = new THREE.Vector3()) {
        this.scene = scene;
        this.group = new THREE.Group();
        
        // Stats
        this.maxHp = 5000; // Tanky
        this.speed = 35; // Faster than player (24)
        this.phase = 1;
        
        // Initialize UserData
        this.group.userData = {
            type: 'enemy',
            enemyType: 'anubis',
            hp: this.maxHp,
            maxHp: this.maxHp,
            velocity: new THREE.Vector3(),
            isDead: false,
            controller: this,
            onGround: false,
            springs: { 
                scale: { pos: 1, vel: 0, target: 1, k: 200, d: 15 },
                tiltX: { pos: 0, vel: 0, target: 0, k: 150, d: 12 },
                tiltZ: { pos: 0, vel: 0, target: 0, k: 150, d: 12 }
            }
        };

        this.state = 'ENTRANCE'; // Start with cinematic
        this.stateTimer = 0;
        this.entrancePhase = 0;
        
        this.initMesh();
        this.group.position.copy(position);
        
        // Animation vars
        this.wingFlapSpeed = 5.0;
        this.hoverTime = 0;
    }
    
    initMesh() {
        if (typeof AssetFactory !== 'undefined') {
            const mesh = AssetFactory.createAnubisBoss();
            mesh.scale.set(2.5, 2.5, 2.5); // Imposing but sleek
            this.group.add(mesh);
            this.mesh = mesh; // Reference for animation
        } else {
            // Fallback
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 3, 1), new THREE.MeshBasicMaterial({color: 0x000000}));
            this.group.add(mesh);
        }
        
        // Health Bar
        this.initHealthBar();
    }
    
    initHealthBar() {
        const barWidth = 4.0;
        const barHeight = 0.3;
        
        this.healthBarBg = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth, barHeight),
            new THREE.MeshBasicMaterial({ color: 0x000000, depthTest: false })
        );
        this.healthBarBg.position.y = 4.5;
        
        this.healthBar = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth - 0.05, barHeight - 0.05),
            new THREE.MeshBasicMaterial({ color: 0xffd700, depthTest: false }) // Gold bar
        );
        this.healthBar.position.y = 4.5;
        this.healthBar.position.z = 0.01;
        
        this.group.add(this.healthBarBg);
        this.group.add(this.healthBar);
    }
    
    update(dt, player) {
        if (this.group.userData.hp <= 0 && !this.group.userData.isDead) {
            this.handleDeath();
            return;
        }
        if (this.group.userData.isDead) return;
        
        // Update Shader Time
        if (this.mesh && this.mesh.userData.matFlow) {
            this.mesh.userData.matFlow.uniforms.uTime.value += dt;
        }
        
        // Phase Transition
        if (this.phase === 1 && this.group.userData.hp < this.maxHp * 0.5) {
            this.phase = 2;
            if (window.flux.spawnTechText) window.flux.spawnTechText("PHASE 2: LIMITER RELEASED");
            if (window.flux.shake) window.flux.shake(1.5);
            if (window.flux.audio) window.flux.audio.play('charge');
            this.speed = 45; // Faster
        }
        
        // State Machine
        switch(this.state) {
            case 'ENTRANCE': this.updateEntrance(dt, player); break;
            case 'IDLE': this.updateIdle(dt, player); break;
            case 'CHASE': this.updateChase(dt, player); break;
            case 'ATTACK': this.updateAttack(dt, player); break;
        }
        
        // Physics & Visuals
        this.updatePhysics(dt);
        this.updateAnimation(dt);
        this.updateHealthBar();
    }
    
    updateEntrance(dt, player) {
        this.stateTimer += dt;
        
        // Phase 0: Initial Spawn (Hidden/High up)
        if (this.entrancePhase === 0) {
            if (window.flux && window.flux.spawnTechText) {
                window.flux.spawnTechText("WARNING: CLASS S THREAT");
            }
            // Hijack Camera
            if (window.flux.setCameraFocus) {
                window.flux.setCameraFocus(this.group.position, 1.0);
            }
            this.entrancePhase = 1;
            this.stateTimer = 0;
        }
        
        // Phase 1: Descend slowly with flair
        if (this.entrancePhase === 1) {
            this.group.position.y -= 15.0 * dt; // Slam down faster
            if (this.group.position.y <= 5.0) {
                this.entrancePhase = 2;
                this.stateTimer = 0;
                if (window.flux.shake) window.flux.shake(2.0);
                if (window.flux.audio) window.flux.audio.play('massive_impact');
                // Shockwave on landing
                if (window.flux.spawnShockwave) window.flux.spawnShockwave(this.group.position);
                if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(this.group.position);
            }
        }
        
        // Phase 2: Roar / Pose
        if (this.entrancePhase === 2) {
            if (this.stateTimer > 2.0) {
                this.state = 'CHASE';
                if (window.flux.spawnTechText) window.flux.spawnTechText("TARGET ACQUIRED");
                // Release Camera
                if (window.flux.clearCameraFocus) window.flux.clearCameraFocus();
            }
        }
    }
    
    updateIdle(dt, player) {
        this.state = 'CHASE'; // Aggressive
    }
    
    updateChase(dt, player) {
        const dist = this.group.position.distanceTo(player.mesh.position);
        
        // Teleport logic if far away
        if (dist > 40 && Math.random() > 0.98) {
            this.teleportNear(player);
            return;
        }
        
        // Move towards player
        const dir = new THREE.Vector3().subVectors(player.mesh.position, this.group.position).normalize();
        this.group.userData.velocity.add(dir.multiplyScalar(this.speed * 2 * dt));
        
        // Face player
        const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);
        this.group.quaternion.slerp(targetQuat, 0.1);
        
        // Attack Range logic
        if (dist < 8.0) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
            this.attackType = 'MELEE';
        } else if (this.phase === 2 && dist > 20.0 && Math.random() > 0.99) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
            this.attackType = 'BEAM';
        }
    }
    
    updateAttack(dt, player) {
        this.stateTimer += dt;
        
        // Attack Pattern Randomizer for Melee
        if (this.stateTimer === dt && this.attackType === 'MELEE') { 
             this.subAttackType = Math.random() > 0.5 ? 'SPIN' : 'LUNGE';
             if (window.flux.audio) window.flux.audio.play('charge');
        }
        
        if (this.attackType === 'BEAM') {
            // Wing Beam Attack (Phase 2)
            if (this.stateTimer < 1.0) {
                // Charge
                this.group.userData.velocity.multiplyScalar(0.1); // Stop
                if (Math.random() > 0.8 && window.flux.spawnChargeParticles) {
                    window.flux.spawnChargeParticles(this.group.position);
                }
            } else if (this.stateTimer < 1.1) {
                // Fire
                if (window.flux.spawnAnubisBeam) {
                    window.flux.spawnAnubisBeam(this.group.position, player.mesh.position);
                }
                if (window.flux.audio) window.flux.audio.play('laser_fire');
            } else if (this.stateTimer > 2.0) {
                this.state = 'CHASE';
            }
            
        } else if (this.subAttackType === 'SPIN') {
            // Staff Spin Attack
            if (this.mesh && this.mesh.userData.staff) {
                this.mesh.userData.staff.rotation.z += 20 * dt; // Spin fast
            }
            
            if (this.stateTimer > 1.0 && this.stateTimer < 1.2) {
                // Damage tick area
                if (this.group.position.distanceTo(player.mesh.position) < 10.0) {
                    player.takeDamage(25);
                    if (window.flux.spawnParticles) window.flux.spawnParticles(player.mesh.position, 10, 0xff0000, 10);
                    if (window.flux.shake) window.flux.shake(0.3);
                }
            }
            
            if (this.stateTimer > 2.0) this.state = 'CHASE';
            
        } else {
            // Lunge
            if (this.stateTimer < 0.5) {
                // Wind up
                this.group.userData.velocity.multiplyScalar(0.5);
            } else if (this.stateTimer < 1.0) {
                // Dash
                const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.group.quaternion);
                this.group.userData.velocity.add(dir.multiplyScalar(150 * dt));
                
                // Hit check
                if (this.group.position.distanceTo(player.mesh.position) < 5.0) {
                    player.takeDamage(40);
                    if (window.flux.shake) window.flux.shake(0.8);
                    if (window.flux.audio) window.flux.audio.play('massive_impact');
                    this.state = 'CHASE'; // Hit and run
                }
            } else {
                this.state = 'CHASE';
            }
        }
    }
    
    teleportNear(player) {
        if (window.flux.spawnParticles) window.flux.spawnParticles(this.group.position, 20, 0x000000, 10);
        if (window.flux.audio) window.flux.audio.play('teleport');
        
        // Flank position
        const offset = new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10);
        const target = player.mesh.position.clone().add(offset);
        target.y = Math.max(2.0, target.y);
        
        this.group.position.copy(target);
        this.group.lookAt(player.mesh.position);
        
        if (window.flux.spawnParticles) window.flux.spawnParticles(this.group.position, 20, 0xffd700, 10);
    }
    
    updatePhysics(dt) {
        const vel = this.group.userData.velocity;
        vel.multiplyScalar(0.9); // Drag
        this.group.position.add(vel.clone().multiplyScalar(dt));
        
        // Float logic
        if (this.group.position.y < 2.0) {
            this.group.position.y += (2.0 - this.group.position.y) * 5 * dt;
        }
    }
    
    updateAnimation(dt) {
        this.hoverTime += dt;
        
        // Bobbing
        this.mesh.position.y = Math.sin(this.hoverTime * 2.0) * 0.2;
        
        // Wing Animation
        if (this.mesh && this.mesh.userData.wings) {
            const wings = this.mesh.userData.wings;
            // Faster flap when attacking
            const speed = (this.state === 'ATTACK' || this.state === 'CHASE') ? 15.0 : 5.0;
            const flap = Math.sin(this.hoverTime * speed) * 0.2;
            
            // Upper wings
            wings[0].rotation.z = 0.5 + flap;
            wings[1].rotation.z = -0.5 - flap;
            
            // Lower wings
            wings[2].rotation.z = 2.5 + (flap * 0.5);
            wings[3].rotation.z = -2.5 - (flap * 0.5);
        }
    }
    
    updateHealthBar() {
        if (!this.healthBar) return;
        const pct = this.group.userData.hp / this.maxHp;
        this.healthBar.scale.x = Math.max(0, pct);
        if (window.camera) {
            this.healthBar.lookAt(window.camera.position);
            this.healthBarBg.lookAt(window.camera.position);
        }
    }
    
    handleDeath() {
        this.group.userData.isDead = true;
        if (window.flux.killEnemy) window.flux.killEnemy(this.group);
        if (window.flux.spawnTechText) window.flux.spawnTechText("ANUBIS DEFEATED");
        if (window.flux.clearCameraFocus) window.flux.clearCameraFocus();
    }
}

/**
 * GRADUAL PROGRESSION WAVE SYSTEM
 * Implements a structured difficulty curve for demo purposes.
 */
class DroneSpawnSystem {
    constructor(scene, enemyGroup) {
        this.scene = scene;
        this.enemyGroup = enemyGroup;
        this.spawnPoints = [];
        this.spawnTimer = 0;
        this.currentWave = 1;
        this.waveProgress = 0;
        this.generateSpawnPoints();
        
        // Initial text
        if (window.flux && window.flux.spawnTechText) {
            setTimeout(() => window.flux.spawnTechText("WAVE 1: INITIATED"), 2000);
        }
    }
    
    generateSpawnPoints() {
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const radius = 25 + Math.random() * 15;
            this.spawnPoints.push(new THREE.Vector3(Math.cos(angle) * radius, 5 + Math.random() * 10, Math.sin(angle) * radius));
        }
    }
    
    update(dt, player) {
        this.spawnTimer -= dt;
        
        // Count active enemies
        let activeEnemies = 0;
        if (window.flux && window.flux.enemies) {
            activeEnemies = window.flux.enemies.filter(e => !e.userData.isDead).length;
        }

        if (this.spawnTimer <= 0) {
            this.handleWaveLogic(activeEnemies);
        }
    }
    
    handleWaveLogic(activeCount) {
        // Wave Progression Logic
        // Wave 1: Tutorial (2 Standard Drones)
        // Wave 2: Escalation (3 Standard + 1 Sniper)
        // Wave 3: Assault (2 Assault + 2 Standard)
        // Wave 4: Swarm (6 Standard + 2 Bomber)
        // Wave 5: BOSS (Gargantua)
        // Wave 6: TRUE BOSS (Anubis)
        
        if (activeCount === 0) {
            // Wave Cleared?
            if (this.waveProgress >= this.getWaveTotal(this.currentWave)) {
                this.currentWave++;
                this.waveProgress = 0;
                this.spawnTimer = 3.0; // Rest period
                if (window.flux && window.flux.spawnTechText) {
                    window.flux.spawnTechText(`WAVE ${this.currentWave} INCOMING`);
                    if (window.flux.audio) window.flux.audio.play('charge');
                }
                return;
            }
        }
        
        // Spawn cap per wave
        const maxActive = this.getMaxActive(this.currentWave);
        if (activeCount < maxActive && this.waveProgress < this.getWaveTotal(this.currentWave)) {
            this.spawnNextEnemy();
            this.spawnTimer = 2.0; // Delay between spawns
        }
    }
    
    getWaveTotal(wave) {
        switch(wave) {
            case 1: return 3;
            case 2: return 5;
            case 3: return 6;
            case 4: return 10;
            case 5: return 1; // Boss 1
            case 6: return 1; // Boss 2 (Anubis)
            default: return 5 + wave; // Endless
        }
    }
    
    getMaxActive(wave) {
        switch(wave) {
            case 1: return 2;
            case 2: return 3;
            case 3: return 4;
            case 4: return 6;
            case 5: return 1;
            case 6: return 1;
            default: return 8;
        }
    }
    
    spawnNextEnemy() {
        const spawnPoint = this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)];
        let type = 'standard';
        
        // Wave Composition
        switch(this.currentWave) {
            case 1: 
                type = 'standard'; 
                break;
            case 2: 
                type = (this.waveProgress % 2 === 0) ? 'standard' : 'sniper'; 
                break;
            case 3: 
                type = (this.waveProgress % 3 === 0) ? 'assault' : 'standard'; 
                break;
            case 4: 
                type = (this.waveProgress % 4 === 0) ? 'bomber' : 'standard'; 
                break;
            case 5: 
                type = 'gargantua'; 
                spawnPoint.set(0, 30, 0); // Sky spawn
                if (window.flux.spawnTechText) window.flux.spawnTechText("WARNING: GARGANTUA DETECTED");
                if (window.flux.shake) window.flux.shake(1.0);
                // Switch BGM to Boss Theme
                if (window.flux.audio) window.flux.audio.playBGM('bgm_boss', 2.0);
                break;
            case 6:
                // ANUBIS SPAWN
                const anubis = new AnubisBoss(this.scene, new THREE.Vector3(0, 20, 0));
                this.enemyGroup.add(anubis.group);
                window.flux.enemies.push(anubis.group);
                this.waveProgress++;
                
                // Cinematic Flair
                if (window.flux.spawnTechText) window.flux.spawnTechText("ALERT: ANUBIS PROTOCOL ENGAGED");
                if (window.flux.audio) {
                    window.flux.audio.play('teleport');
                    // TRIGGER NEW ANUBIS BGM
                    window.flux.audio.playBGM('bgm_anubis', 2.0);
                }
                return; // Special return since we manually added
                
            default:
                // Random mix for endless
                const r = Math.random();
                if (r > 0.9) type = 'bomber';
                else if (r > 0.7) type = 'assault';
                else if (r > 0.5) type = 'sniper';
                else type = 'standard';
        }
        
        const drone = new MechDroneEnemy(this.scene, type, spawnPoint);
        this.enemyGroup.add(drone.group);
        window.flux.enemies.push(drone.group);
        
        // Spawn FX
        if (window.flux.spawnParticles) window.flux.spawnParticles(spawnPoint, 20, 0x00ffff, 5);
        if (window.flux.audio) window.flux.audio.play('teleport');
        
        this.waveProgress++;
    }
}</script> 
    <script>/**
 * MAIN GAME LOOP - OPTIMIZED & KINEMATIC
 * Implements Dynamic Resolution Scaling, Instanced Particles, and Herculean Camera
 * UPDATED: Strategic Lighting Architecture (Todo II.B) - High Contrast, Neon Pop.
 * UPDATED: Fixed Particle Updates (No more persistent litter).
 * UPDATED: Added Wing/Foot Trails, Removed Scarf.
 * UPDATED: Added Menu System, Bestiary, and HUD Editor.
 * UPDATED: Added Cinematic Mode support.
 */

window.addEventListener('DOMContentLoaded', () => {
    try {
        const loader = document.getElementById('loading-screen');
        const startHandler = async () => {
            console.log("User interaction detected. Starting Engine.");
            if (loader) loader.style.display = 'none';
            
            if (typeof AudioSystem !== 'undefined') {
                window.flux.audio = new AudioSystem();
                await window.flux.audio.init();
                // Start Standard BGM
                window.flux.audio.playBGM('bgm_standard', 2.0);
            }

            initGame();
            
            document.removeEventListener('touchstart', startHandler);
            document.removeEventListener('click', startHandler);
            document.removeEventListener('keydown', startHandler);
        };

        document.addEventListener('touchstart', startHandler, {once:true});
        document.addEventListener('click', startHandler, {once:true});
        document.addEventListener('keydown', startHandler, {once:true});

    } catch (e) {
        console.error("CRITICAL INIT FAILURE:", e);
    }
});

window.flux = window.flux || {};

// GLOBAL STATE
window.flux.cinematicActive = false;

let scene, camera, renderer, composer;
let player;
let input;
let clock;
let debugText;
let resDebugText;

// GAME STATES
let isPaused = false;
let isBestiaryOpen = false;
let bestiaryScene, bestiaryCamera, bestiaryModel, bestiaryRenderer;
let bestiaryModels = [];
let currentBestiaryIndex = 0;

// OPTIMIZATION: Split World into Static and Dynamic for faster Raycasting
let staticGroup; 
let enemyGroup;  
let vfxGroup;    

let particleGroup; 
let trailGroup;
let dustGroup; 
let rainGroup; 
let ghostGroup; 
let projectileGroup; 
let vectorTrapGroup; 

// Instanced Systems
let cubeParticles;
let sparkParticles;
let debrisSystem;
let shellSystem;
let laserSystem; // NEW: Homing Lasers
let spawnSystem; // NEW: Drone Spawn System
let deathRay; // NEW: Boss Death Ray
let playerBeam; // NEW: Player Beam Rifle Effect

// Post Processing
let bloomPass, rgbShiftPass;

// Optimization Vars
let pixelRatio = 0.4; // LOWERED for PS1/Retro aesthetic per user request
let frameCount = 0;
let lastTime = 0;

// Juice Globals
let shakeIntensity = 0;
const SHAKE_DECAY = 0.9;
let chromaticAberrationIntensity = 0;
let timeScale = 1.0;
let slowMoTimer = 0;
let targetTimeScale = 1.0;

// Camera Kinematics
let cameraProxyTarget = new THREE.Vector3(0, 10, 0); 
let camPosSpring = new THREE.Vector3(0, 10, 10);
let camVelSpring = new THREE.Vector3(0, 0, 0);
const TARGET_HORIZONTAL_FOV = 90; 

// Transparency System
let fadedObjects = [];
let camRaycaster = new THREE.Raycaster();

// Combo & Style Globals
let comboCount = 0;
let comboTimeout = 0;
const COMBO_RESET_TIME = 2.5; 
const styleRanks = ["D", "C", "B", "A", "S", "SS", "SSS"];

let lastWidth = window.innerWidth;
const enemies = []; 
const enemyProjectiles = []; 

// POOLS
const shockwaveGeo = new THREE.RingGeometry(0.5, 1.0, 16);
// FIXED: Reduced opacity to prevent "White Ball" blinding effect
const shockwaveMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff, 
    transparent: true, 
    opacity: 0.4, // Increased slightly for impact visibility
    side: THREE.DoubleSide,
    depthWrite: false, 
    blending: THREE.AdditiveBlending
});
const shockwavePool = [];
const SHOCKWAVE_POOL_SIZE = 20; // Increased pool size for massive explosions
for(let i=0; i<SHOCKWAVE_POOL_SIZE; i++) shockwavePool.push(shockwaveMat.clone());
let shockwavePoolIdx = 0;

const flashGeo = new THREE.PlaneGeometry(4, 4); // Bigger flash
const flashMat = new THREE.MeshBasicMaterial({
    color: 0xffaa00,
    transparent: true,
    opacity: 0.6, 
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    side: THREE.DoubleSide
});

// Temporary Vectors
const aiTempVec = new THREE.Vector3();
const aiForwardVec = new THREE.Vector3();
const tempDirToCam = new THREE.Vector3();
const tempCamTarget = new THREE.Vector3();
const tempLookTarget = new THREE.Vector3();

// Indicator Pool
const indicatorPool = [];
const MAX_INDICATORS = 10;

function initGame() {
    console.log("Flux Engine: Initializing Optimized Core...");
    
    const canvas = document.getElementById('game-canvas');
    debugText = document.getElementById('fps-counter');
    resDebugText = document.getElementById('res-debug');

    scene = new THREE.Scene();
    // Brighter background for visibility
    scene.background = new THREE.Color(0x050510); // Deep space blue/black
    scene.fog = new THREE.FogExp2(0x050510, 0.015); // Fog matches bg

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500); 
    camera.position.set(0, 10, 10);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ 
        canvas: canvas, 
        antialias: false, 
        powerPreference: "high-performance",
        stencil: false,
        depth: true
    });
    
    // Adjust pixel ratio based on device capability but cap it for performance
    const deviceRatio = window.devicePixelRatio || 1;
    // Cap pixel ratio to user setting if lower, otherwise use device but clamp
    const targetRatio = Math.min(deviceRatio, pixelRatio); 
    
    renderer.setPixelRatio(targetRatio);
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFShadowMap; 
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 2.0; 

    initPostProcessing(window.innerWidth, window.innerHeight);

    // --- LIGHTING REVAMP V3 (Strategic High Contrast) ---
    const hemiLight = new THREE.HemisphereLight(0x111122, 0x000000, 0.2); 
    hemiLight.position.set(0, 50, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 2.0); 
    dirLight.position.set(20, 40, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048); 
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 100;
    dirLight.shadow.camera.left = -40;
    dirLight.shadow.camera.right = 40;
    dirLight.shadow.camera.top = 40;
    dirLight.shadow.camera.bottom = -40;
    scene.add(dirLight);
    
    const rimLight = new THREE.DirectionalLight(0x00f3ff, 3.0);
    rimLight.position.set(-10, 20, -30); // Behind and left
    scene.add(rimLight);
    
    const fillLight = new THREE.DirectionalLight(0xff0055, 0.5);
    fillLight.position.set(-20, 10, 20);
    scene.add(fillLight);
    
    // GROUPS
    staticGroup = new THREE.Group();
    staticGroup.matrixAutoUpdate = false; 
    scene.add(staticGroup);

    enemyGroup = new THREE.Group();
    scene.add(enemyGroup);

    vfxGroup = new THREE.Group();
    scene.add(vfxGroup);

    particleGroup = new THREE.Group(); 
    vfxGroup.add(particleGroup);
    trailGroup = new THREE.Group();
    vfxGroup.add(trailGroup);
    dustGroup = new THREE.Group();
    vfxGroup.add(dustGroup);
    rainGroup = new THREE.Group();
    vfxGroup.add(rainGroup);
    ghostGroup = new THREE.Group();
    vfxGroup.add(ghostGroup);
    projectileGroup = new THREE.Group();
    vfxGroup.add(projectileGroup);
    vectorTrapGroup = new THREE.Group();
    vfxGroup.add(vectorTrapGroup);

    // --- INSTANCED PARTICLE SYSTEMS ---
    const cubeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
    const cubeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    cubeParticles = new InstancedParticleSystem(scene, 1500, cubeGeo, cubeMat); // Increased count
    cubeParticles.mesh.frustumCulled = false;

    // UPDATED: Spark Geometry slightly larger for visibility
    const sparkGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8); // Longer sparks
    const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    sparkParticles = new InstancedParticleSystem(scene, 2000, sparkGeo, sparkMat); // Doubled count
    sparkParticles.mesh.frustumCulled = false;

    const debrisGeo = new THREE.DodecahedronGeometry(0.15, 0); // Bigger debris
    const debrisMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.5 });
    debrisSystem = new InstancedParticleSystem(scene, 800, debrisGeo, debrisMat);
    debrisSystem.mesh.frustumCulled = false;

    const shellGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8);
    shellGeo.rotateX(Math.PI/2); 
    const shellMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
    shellSystem = new InstancedParticleSystem(scene, 200, shellGeo, shellMat);
    shellSystem.mesh.frustumCulled = false;
    
    // --- NEW SYSTEMS ---
    if (typeof HomingLaserSystem !== 'undefined') {
        laserSystem = new HomingLaserSystem(scene, 100);
    }
    
    // --- TRAIL SYSTEM (Wings & Feet) ---
    if (typeof RibbonTrail !== 'undefined') {
        window.flux.trails = {
            wingL: new RibbonTrail(scene, 20, 0.15, 0x00ffff), // Cyan
            wingR: new RibbonTrail(scene, 20, 0.15, 0x00ffff), // Cyan
            footL: new RibbonTrail(scene, 15, 0.15, 0xff0055), // Pink
            footR: new RibbonTrail(scene, 15, 0.15, 0xff0055)  // Pink
        };
    }
    
    if (typeof DeathRay !== 'undefined') {
        deathRay = new DeathRay(scene); // Boss Beam
        playerBeam = new DeathRay(scene); // Player Beam
        playerBeam.mesh.material.color.setHex(0x00ffff);
    }
    
    // Initialize Drone Spawn System
    if (typeof DroneSpawnSystem !== 'undefined') {
        spawnSystem = new DroneSpawnSystem(scene, enemyGroup);
    }

    buildWorld(staticGroup); 
    initDust();
    initRain();
    initIndicators();

    input = new InputSystem();
    initFluxHelpers(); 
    initUI(); // NEW: Initialize Menu UI
    
    player = new Player(scene, staticGroup, enemyGroup);
    clock = new THREE.Clock();

    const gameOverScreen = document.getElementById('game-over-screen');
    if(gameOverScreen) {
        gameOverScreen.addEventListener('click', () => {
            if(player && player.isDead) {
                player.reset();
                gameOverScreen.classList.add('hidden');
                if (window.flux.audio) window.flux.audio.play('startup');
            }
        });
    }

    onWindowResize();
    window.addEventListener('resize', onWindowResize, false);
    
    animate();
}

function initUI() {
    // Menu Button
    const btnMenu = document.getElementById('btn-menu');
    const mainMenu = document.getElementById('main-menu');
    const btnQuit = document.getElementById('menu-quit');
    const btnMechs = document.getElementById('menu-mechs');
    const btnOptions = document.getElementById('menu-options');
    
    // Bestiary UI
    const bestiaryMenu = document.getElementById('bestiary-menu');
    const btnBestiaryBack = document.getElementById('bestiary-back');
    const btnBestiaryNext = document.getElementById('bestiary-next');
    const btnBestiaryPrev = document.getElementById('bestiary-prev');
    
    // Options UI
    const optionsMenu = document.getElementById('options-menu');
    const btnOptBack = document.getElementById('opt-back');
    const btnOptLayout = document.getElementById('opt-layout');
    
    // HUD Editor
    const hudEditor = document.getElementById('hud-editor');
    const btnEditorClose = document.getElementById('editor-close');
    const btnEditorSave = document.getElementById('editor-save');
    const btnEditorLoad = document.getElementById('editor-load');
    const btnEditorReset = document.getElementById('editor-reset');
    const fileInput = document.getElementById('layout-file-input');
    
    // Scale Slider
    const scaleSlider = document.getElementById('editor-scale-slider');
    if (scaleSlider) {
        scaleSlider.addEventListener('input', (e) => {
            if (input && input.lastTouchedButton) {
                const scale = parseFloat(e.target.value);
                input.lastTouchedButton.style.transform = `scale(${scale})`;
                input.lastTouchedButton.dataset.scale = scale;
            }
        });
    }

    // --- MENU HANDLERS ---
    btnMenu.addEventListener('click', () => {
        isPaused = true;
        mainMenu.classList.remove('hidden');
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    btnQuit.addEventListener('click', () => {
        isPaused = false;
        mainMenu.classList.add('hidden');
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    // --- BESTIARY HANDLERS ---
    btnMechs.addEventListener('click', () => {
        mainMenu.classList.add('hidden');
        bestiaryMenu.classList.remove('hidden');
        openBestiary();
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    btnBestiaryBack.addEventListener('click', () => {
        bestiaryMenu.classList.add('hidden');
        mainMenu.classList.remove('hidden');
        closeBestiary();
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    btnBestiaryNext.addEventListener('click', () => {
        currentBestiaryIndex = (currentBestiaryIndex + 1) % bestiaryModels.length;
        updateBestiaryModel();
        if (window.flux.audio) window.flux.audio.play('ui_hover');
    });

    btnBestiaryPrev.addEventListener('click', () => {
        currentBestiaryIndex = (currentBestiaryIndex - 1 + bestiaryModels.length) % bestiaryModels.length;
        updateBestiaryModel();
        if (window.flux.audio) window.flux.audio.play('ui_hover');
    });

    // --- OPTIONS HANDLERS ---
    btnOptions.addEventListener('click', () => {
        mainMenu.classList.add('hidden');
        optionsMenu.classList.remove('hidden');
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    btnOptBack.addEventListener('click', () => {
        optionsMenu.classList.add('hidden');
        mainMenu.classList.remove('hidden');
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    btnOptLayout.addEventListener('click', () => {
        optionsMenu.classList.add('hidden');
        hudEditor.classList.remove('hidden');
        input.setEditMode(true);
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    // --- HUD EDITOR HANDLERS ---
    btnEditorClose.addEventListener('click', () => {
        hudEditor.classList.add('hidden');
        optionsMenu.classList.remove('hidden');
        input.setEditMode(false);
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });
    
    btnEditorSave.addEventListener('click', () => {
        saveButtonLayout();
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });
    
    btnEditorReset.addEventListener('click', () => {
        resetButtonLayout();
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });
    
    btnEditorLoad.addEventListener('click', () => {
        fileInput.click();
    });
    
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const layout = JSON.parse(e.target.result);
                loadButtonLayout(layout);
                if (window.flux.audio) window.flux.audio.play('ui_click');
            } catch (err) {
                console.error("Failed to load layout", err);
            }
        };
        reader.readAsText(file);
    });
}

// --- BESTIARY LOGIC ---
function openBestiary() {
    isBestiaryOpen = true;
    
    // Create separate scene if not exists
    if (!bestiaryScene) {
        bestiaryScene = new THREE.Scene();
        bestiaryScene.background = new THREE.Color(0x050510); // Match game BG
        
        // Lighting
        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        bestiaryScene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 2.0);
        dir.position.set(5, 5, 5);
        bestiaryScene.add(dir);
        
        bestiaryCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
        bestiaryCamera.position.set(0, 1, 4);
        bestiaryCamera.lookAt(0, 0, 0);
        
        // Populate Models
        bestiaryModels = [
            { name: "JEHUTY (ORBITAL FRAME)", desc: "Advanced tactical suit. High mobility.", type: 'jehuty' },
            { name: "ANUBIS", desc: "Class S Threat. Unknown capabilities.", type: 'anubis' },
            { name: "GARGANTUA", desc: "Class A Threat. Massive firepower.", type: 'gargantua' },
            { name: "STANDARD DRONE", desc: "Common combat unit. Laser weaponry.", type: 'standard' },
            { name: "SNIPER DRONE", desc: "Long range unit. High damage railgun.", type: 'sniper' },
            { name: "ASSAULT DRONE", desc: "Aggressive close-range unit. Burst fire.", type: 'assault' },
            { name: "BOMBER DRONE", desc: "Heavy unit. Deploys explosive ordinance.", type: 'bomber' }
        ];
    }
    
    // Create dedicated renderer if needed
    if (!bestiaryRenderer) {
        const container = document.getElementById('bestiary-canvas-container');
        if (container) {
            bestiaryRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            bestiaryRenderer.setSize(container.clientWidth, container.clientHeight);
            bestiaryRenderer.setPixelRatio(window.devicePixelRatio);
            container.innerHTML = ''; // Clear previous
            container.appendChild(bestiaryRenderer.domElement);
            
            // Handle resize
            const resizeObserver = new ResizeObserver(() => {
                if (bestiaryRenderer && container) {
                    bestiaryRenderer.setSize(container.clientWidth, container.clientHeight);
                    if (bestiaryCamera) {
                        bestiaryCamera.aspect = container.clientWidth / container.clientHeight;
                        bestiaryCamera.updateProjectionMatrix();
                    }
                }
            });
            resizeObserver.observe(container);
        }
    }
    
    updateBestiaryModel();
}

function closeBestiary() {
    isBestiaryOpen = false;
    if (bestiaryModel) {
        bestiaryScene.remove(bestiaryModel);
        bestiaryModel = null;
    }
    // Note: We keep the renderer alive for performance re-opening
}

function updateBestiaryModel() {
    if (bestiaryModel) bestiaryScene.remove(bestiaryModel);
    
    const data = bestiaryModels[currentBestiaryIndex];
    document.getElementById('bestiary-label').innerText = data.name;
    document.getElementById('bestiary-desc').innerText = data.desc;
    
    if (typeof AssetFactory !== 'undefined') {
        if (data.type === 'jehuty') {
            if (typeof PlayerMesh !== 'undefined' && PlayerMesh.createStandalone) {
                bestiaryModel = PlayerMesh.createStandalone();
                bestiaryModel.scale.set(1, 1, 1);
            } else {
                bestiaryModel = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshBasicMaterial({color:0x00ffff}));
            }
        } else if (data.type === 'anubis') {
            bestiaryModel = AssetFactory.createAnubisBoss();
            bestiaryModel.scale.set(0.8, 0.8, 0.8);
        } else if (data.type === 'gargantua') {
            bestiaryModel = AssetFactory.createMechDrone();
            bestiaryModel.scale.set(2, 2, 2);
             bestiaryModel.traverse((child) => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(0xaa00aa);
                }
            });
        } else {
            bestiaryModel = AssetFactory.createMechDrone();
            let color = 0xffffff;
            if (data.type === 'standard') color = 0xff4444;
            if (data.type === 'sniper') color = 0x4444ff;
            if (data.type === 'assault') color = 0xffaa00;
            if (data.type === 'bomber') color = 0x880000;
            
            bestiaryModel.traverse((child) => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(color);
                }
            });
        }
    } else {
        bestiaryModel = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color:0xff0000}));
    }
    
    if (bestiaryModel) {
        bestiaryModel.position.set(0, -0.5, 0);
        bestiaryScene.add(bestiaryModel);
    }
}

// --- HUD EDITOR LOGIC ---
function saveButtonLayout() {
    const buttons = document.querySelectorAll('.btn');
    const layout = {};
    buttons.forEach(btn => {
        layout[btn.id] = {
            left: btn.style.left,
            top: btn.style.top,
            right: btn.style.right,
            bottom: btn.style.bottom,
            scale: btn.dataset.scale || 1.0
        };
    });
    
    const blob = new Blob([JSON.stringify(layout)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "flux_layout.json";
    a.click();
}

function loadButtonLayout(layout) {
    for (const id in layout) {
        const btn = document.getElementById(id);
        if (btn) {
            const pos = layout[id];
            btn.style.left = pos.left;
            btn.style.top = pos.top;
            btn.style.right = pos.right;
            btn.style.bottom = pos.bottom;
            if (pos.scale) {
                btn.style.transform = `scale(${pos.scale})`;
                btn.dataset.scale = pos.scale;
            }
        }
    }
}

function resetButtonLayout() {
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(btn => {
        btn.style.left = '';
        btn.style.top = '';
        btn.style.right = '';
        btn.style.bottom = '';
        btn.style.transform = '';
        btn.dataset.scale = 1.0;
    });
}

function initIndicators() {
    const container = document.getElementById('offscreen-indicators');
    if (!container) return;
    
    for (let i = 0; i < MAX_INDICATORS; i++) {
        const el = document.createElement('div');
        el.className = 'indicator-arrow';
        el.style.display = 'none';
        container.appendChild(el);
        indicatorPool.push(el);
    }
}

function updateOffscreenIndicators() {
    if (!player || !camera || !enemies) return;
    
    // Reset all indicators
    indicatorPool.forEach(el => el.style.display = 'none');
    
    let activeIdx = 0;
    const width = window.innerWidth;
    const height = window.innerHeight;
    const center = new THREE.Vector2(width / 2, height / 2);
    
    enemies.forEach(enemy => {
        if (enemy.userData.isDead || activeIdx >= MAX_INDICATORS) return;
        
        // Project enemy position to screen space
        const pos = enemy.position.clone().add(new THREE.Vector3(0, 1, 0));
        pos.project(camera);
        
        const isOffScreen = (pos.x < -1 || pos.x > 1 || pos.y < -1 || pos.y > 1 || pos.z > 1);
        
        if (isOffScreen) {
            const el = indicatorPool[activeIdx];
            el.style.display = 'block';
            
            // Calculate angle to enemy from center of screen
            // If z > 1, it's behind the camera, invert coordinates
            let screenX = pos.x;
            let screenY = pos.y;
            
            if (pos.z > 1) {
                screenX = -screenX;
                screenY = -screenY;
            }
            
            const angle = Math.atan2(screenY, screenX);
            const deg = -angle * (180 / Math.PI) + 90; // Convert to CSS rotation (0 is up)
            
            // Position on edge of ellipse (screen bounds)
            // Simple box clamping for now
            const padding = 30;
            const w = width / 2 - padding;
            const h = height / 2 - padding;
            
            // Clamp to edge
            let x = Math.cos(angle) * w * 2; // Overshoot
            let y = Math.sin(angle) * h * 2;
            
            // Clamp to box
            if (Math.abs(x) > w) {
                x = Math.sign(x) * w;
                y = x * Math.tan(angle);
            }
            if (Math.abs(y) > h) {
                y = Math.sign(y) * h;
                x = y / Math.tan(angle);
            }
            
            // Invert Y for CSS
            el.style.transform = `translate(${center.x + x}px, ${center.y - y}px) rotate(${deg}deg)`;
            
            activeIdx++;
        }
    });
}

function initDust() {
    const dustCount = 400; // More dust
    const dustGeo = new THREE.BufferGeometry();
    const positions = [];
    for(let i=0; i<dustCount; i++) {
        // WIDER SPREAD
        positions.push((Math.random()-0.5)*200); 
        positions.push((Math.random())*40); 
        positions.push((Math.random()-0.5)*200); 
    }
    dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const dustMat = new THREE.PointsMaterial({
        color: 0xccddff,
        size: 0.25,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending
    });
    dustGroup.add(new THREE.Points(dustGeo, dustMat));
}

function initRain() {
    const rainCount = 1000; // More rain
    const rainGeo = new THREE.BufferGeometry();
    const positions = [];
    for(let i=0; i<rainCount; i++) {
        // WIDER SPREAD
        positions.push((Math.random()-0.5)*200);
        positions.push(Math.random()*60);
        positions.push((Math.random()-0.5)*200);
    }
    rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const rainMat = new THREE.PointsMaterial({
        color: 0x88ffff,
        size: 0.3,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });
    const rainSystem = new THREE.Points(rainGeo, rainMat);
    rainSystem.userData = { velocities: new Float32Array(rainCount) };
    for(let i=0; i<rainCount; i++) rainSystem.userData.velocities[i] = 20 + Math.random()*20;
    rainGroup.add(rainSystem);
}

function initFluxHelpers() {
    window.flux.enemies = enemies;
    window.flux.staticGroup = staticGroup; 
    window.flux.player = player; // Expose player to global flux for enemy AI
    window.flux.comboCount = 0; // Expose combo count

    // CINEMATIC HELPERS
    window.flux.startCinematic = () => {
        window.flux.cinematicActive = true;
        document.body.classList.add('cinematic-active');
    };
    
    window.flux.stopCinematic = () => {
        window.flux.cinematicActive = false;
        document.body.classList.remove('cinematic-active');
        if (window.flux.clearCameraFocus) window.flux.clearCameraFocus();
    };

    window.flux.shake = (amount) => {
        shakeIntensity = Math.max(shakeIntensity, amount);
        chromaticAberrationIntensity = Math.max(chromaticAberrationIntensity, amount * 0.04);
    };
    
    window.flux.slowMotion = (duration, scale) => {
        slowMoTimer = duration;
        targetTimeScale = scale;
    };

    window.flux.hitStop = (duration) => window.flux.slowMotion(duration, 0.05);
    
    window.flux.spawnParticles = (pos, count, color, speed) => {
        if (!pos || !cubeParticles) return;
        const safeCount = Math.min(count, 50); // Increased limit for spectacle
        for(let i=0; i<safeCount; i++) {
            const vel = new THREE.Vector3(
                (Math.random() - 0.5) * speed,
                (Math.random() * speed),
                (Math.random() - 0.5) * speed
            );
            const life = 0.5 + Math.random() * 0.5;
            cubeParticles.spawn(pos, vel, color, life, 20, 1.0);
        }
    };

    window.flux.spawnHitParticles = (pos, dir) => {
        if (!pos || !sparkParticles) return;
        const baseDir = (dir && dir.isVector3) ? dir.clone() : new THREE.Vector3(0,1,0);
        
        // UPDATED: Realistic Sparks
        // More particles, higher gravity, bounce, and drag
        for(let i=0; i<15; i++) { 
            const spread = new THREE.Vector3(
                (Math.random() - 0.5),
                (Math.random() - 0.5),
                (Math.random() - 0.5)
            ).multiplyScalar(1.5); // Wider spread
            
            const vel = baseDir.clone().add(spread).normalize().multiplyScalar(15 + Math.random() * 25);
            
            // spawn(pos, vel, color, life, gravity, size, grow, bounce, rotVel, drag)
            sparkParticles.spawn(
                pos, 
                vel, 
                0xffaa00, // Orange/Gold
                0.6 + Math.random() * 0.6, // Longer life
                45, // High Gravity
                1.2, // Size
                -1.0, // Shrink
                0.7, // Bounciness
                null,
                1.5 // Drag (Air resistance)
            );
        }

        // CLONE MATERIAL TO FIX SHARED OPACITY BUG
        const mat = flashMat.clone();
        const flash = new THREE.Mesh(flashGeo, mat); 
        flash.position.copy(pos);
        flash.lookAt(camera.position);
        flash.userData = { life: 0.1, grow: 0 }; 
        particleGroup.add(flash);
    };

    window.flux.spawnGhost = (meshGroup, isSilent) => {
        if (!meshGroup || !ghostGroup) return;
        
        const ghost = meshGroup.clone();
        ghost.position.copy(player.mesh.position);
        ghost.rotation.copy(player.mesh.rotation);
        
        const ghostColor = isSilent ? 0x888888 : 0x00ffff;
        const ghostMat = new THREE.MeshBasicMaterial({
            color: ghostColor,
            transparent: true,
            opacity: 0.4,
            wireframe: true
        });
        
        ghost.traverse((child) => {
            if (child.isMesh) {
                child.material = ghostMat;
            }
        });
        
        ghost.userData = { life: 0.3 };
        ghostGroup.add(ghost);
    };

    window.flux.spawnVectorTrap = (pos) => {
        if (!vectorTrapGroup) return;
        
        const geo = new THREE.IcosahedronGeometry(1, 1);
        const mat = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            wireframe: true,
            transparent: true,
            opacity: 0.8
        });
        
        const trap = new THREE.Mesh(geo, mat);
        trap.position.copy(pos);
        trap.userData = { life: 0.3, scaleSpeed: 15.0 };
        vectorTrapGroup.add(trap);
    };
    
    window.flux.spawnDebris = (pos, count) => {
        if (!pos || !debrisSystem) return;
        for(let i=0; i<count; i++) {
            const vel = new THREE.Vector3(
                (Math.random() - 0.5) * 15,
                (Math.random() * 15) + 5,
                (Math.random() - 0.5) * 15
            );
            const rotVel = new THREE.Vector3(Math.random()*10, Math.random()*10, Math.random()*10);
            debrisSystem.spawn(pos, vel, 0xaaaaaa, 3.0, 30, 1.5 + Math.random(), 0, 0.6, rotVel);
        }
    };

    window.flux.spawnShell = (pos, dir) => {
        if(!pos || !shellSystem) return;
        const vel = dir.clone().multiplyScalar(-2).add(new THREE.Vector3(0, 4, 0));
        vel.x += (Math.random() - 0.5) * 2;
        vel.z += (Math.random() - 0.5) * 2;
        
        const rotVel = new THREE.Vector3(Math.random()*20, Math.random()*20, 0);
        shellSystem.spawn(pos, vel, 0xffd700, 3.0, 20, 1.0, 0, 0.7, rotVel);
    };
    
    window.flux.spawnChargeParticles = (pos) => {
        if (!pos || !cubeParticles) return;
        const radius = 2.5;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        const pPos = new THREE.Vector3(
            pos.x + radius * Math.sin(phi) * Math.cos(theta),
            pos.y + radius * Math.cos(phi),
            pos.z + radius * Math.sin(phi) * Math.sin(theta)
        );
        
        const dir = new THREE.Vector3().subVectors(pos, pPos).normalize().multiplyScalar(15);
        cubeParticles.spawn(pPos, dir, 0xffaa00, 0.2, 0, 1.0);
    };
    
    window.flux.spawnMassiveImpact = (pos) => {
        if (!pos) return;
        window.flux.spawnShockwave(pos);
        window.flux.spawnParticles(pos, 80, 0xffaa00, 50); // More particles
        window.flux.spawnDebris(pos, 20); // More debris
        window.flux.shake(2.0);
        camVelSpring.z -= 20; 
        window.flux.slowMotion(0.8, 0.2); 
        if(window.flux.audio) window.flux.audio.play('massive_impact');
    };

    window.flux.spawnBlockParticles = (pos) => {
        if(!pos) return;
        window.flux.spawnParticles(pos, 15, 0x00ffff, 20);
        if(window.flux.audio) window.flux.audio.play('block');
    };
    
    window.flux.spawnTrail = (start, end) => {
        if (!start || !end) return;
        if (typeof start.x !== 'number' || typeof end.x !== 'number') return; 

        const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
        const len = start.distanceTo(end);
        if(len < 0.01) return; 

        const width = 0.15; 
        const geo = new THREE.BoxGeometry(width, width, len);
        
        // Trail color based on Overdrive
        let color = 0xff00aa;
        if (comboCount > 15) color = 0x00f3ff;
        if (player && player.isOverdrive) color = 0xff0000;
        
        const mat = new THREE.MeshBasicMaterial({ 
            color: color, 
            transparent: true, 
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        const segment = new THREE.Mesh(geo, mat);
        segment.position.copy(center);
        segment.lookAt(end);
        segment.userData = { life: 0.2 }; 
        if(trailGroup) trailGroup.add(segment);
    };
    
    window.flux.spawnShockwave = (pos) => {
        if(!pos || !particleGroup) return;
        const mat = shockwavePool[shockwavePoolIdx];
        shockwavePoolIdx = (shockwavePoolIdx + 1) % SHOCKWAVE_POOL_SIZE;
        mat.opacity = 0.6; // Higher opacity for visibility
        mat.color.setHex(0xffffff);

        const wave = new THREE.Mesh(shockwaveGeo, mat);
        wave.position.copy(pos);
        wave.lookAt(camera.position); 
        wave.userData = { life: 0.4, grow: 40.0, gravity: 0 }; // Faster growth
        particleGroup.add(wave); 
    };

    window.flux.spawnEnemyProjectile = (start, dir) => {
        if (!projectileGroup) return;
        const geo = new THREE.BoxGeometry(0.1, 0.1, 1.0);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const proj = new THREE.Mesh(geo, mat);
        proj.position.copy(start);
        proj.lookAt(start.clone().add(dir));
        proj.userData = { velocity: dir.clone().multiplyScalar(30), life: 2.0 };
        projectileGroup.add(proj);
        enemyProjectiles.push(proj);
    };
    
    // --- NEW: LASER HELPER ---
    window.flux.spawnLaser = (start, end, target) => {
        if (laserSystem) {
            laserSystem.spawn(start, end, target);
        }
    };
    
    // --- NEW: BOSS BEAM HELPER ---
    window.flux.fireBossBeam = (start, end, duration, width) => {
        if (deathRay) {
            deathRay.fire(start, end, duration, width);
        }
    };

    // --- NEW: PLAYER BEAM HELPER ---
    window.flux.firePlayerBeam = (start, end) => {
        if (playerBeam) {
            playerBeam.fire(start, end, 0.2, 0.5); // Short, sharp beam
        }
    };
    
    // --- NEW: ANUBIS BEAM HELPER ---
    window.flux.spawnAnubisBeam = (start, end) => {
        // Use death ray but faster and thinner
        if (deathRay) {
            deathRay.fire(start, end, 0.5, 1.0);
        }
    };

    window.flux.spawnTechText = (text) => {
        spawnFloatingText(player.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), text, false, true);
    };
    
    // Camera Focus Helpers for Boss Intros
    window.flux.setCameraFocus = (targetPos, lerpSpeed) => {
        // We can override the camera proxy target logic temporarily
        // For now, let's just snap the proxy target
        if (cameraProxyTarget) {
            cameraProxyTarget.copy(targetPos);
        }
    };
    
    window.flux.clearCameraFocus = () => {
        // Logic in main loop handles resetting to player
    };

    window.flux.explode = (pos) => {
        if (!pos) return;
        
        window.flux.spawnMassiveImpact(pos); 
        
        const radius = 8.0;
        const damage = 120;
        
        if (enemies) {
            enemies.forEach(enemy => {
                if (!enemy.userData.isDead) {
                    const dist = enemy.position.distanceTo(pos);
                    if (dist < radius) {
                        enemy.userData.hp -= damage;
                        const dir = new THREE.Vector3().subVectors(enemy.position, pos).normalize();
                        dir.y = 0.5; 
                        enemy.userData.velocity.add(dir.multiplyScalar(40));
                        enemy.userData.onGround = false;
                        
                        // Check for death here, or let update loop handle it
                        if (enemy.userData.hp <= 0) window.flux.killEnemy(enemy);
                        else {
                            // Safely flash
                            flashEnemy(enemy);
                        }
                    }
                }
            });
        }
        
        if (player && !player.isDead) {
            const dist = player.mesh.position.distanceTo(pos);
            if (dist < radius) {
                player.takeDamage(30);
                const dir = new THREE.Vector3().subVectors(player.mesh.position, pos).normalize();
                dir.y = 0.5;
                player.velocity.add(dir.multiplyScalar(30));
                player.isKnockedDown = true;
            }
        }
    };

    window.flux.killEnemy = (enemy) => {
        if(!enemy) return;
        enemy.userData.isDead = true;
        enemy.userData.respawnTimer = 5.0;
        enemy.visible = false;
        
        const deathPos = enemy.position.clone();
        enemy.position.y = -500; // Move out of bounds
        
        // --- SPECTACLE: MASSIVE EXPLOSION FX ---
        
        // 1. Audio: Double Layer for impact
        if(window.flux.audio) {
            window.flux.audio.play('drone_death'); // High freq crackle
            window.flux.audio.play('massive_impact'); // Low freq boom
        }

        // 2. Visuals: Overwhelming Particles
        // Sparks (Orange/Red) - High velocity
        if (sparkParticles) {
            for(let i=0; i<40; i++) {
                const vel = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize().multiplyScalar(20 + Math.random()*30);
                sparkParticles.spawn(deathPos, vel, 0xffaa00, 0.8, 30, 1.5, -1, 0.6, null, 2.0);
            }
        }
        
        // Debris - Chunks flying
        window.flux.spawnDebris(deathPos, 15);
        
        // Shockwave
        window.flux.spawnShockwave(deathPos);
        
        // Flash - Big billboard
        const mat = flashMat.clone();
        const flash = new THREE.Mesh(flashGeo, mat); 
        flash.position.copy(deathPos);
        flash.lookAt(camera.position);
        flash.userData = { life: 0.15, grow: 5.0 }; 
        particleGroup.add(flash);
        
        // 3. Juice
        window.flux.shake(1.2);
        window.flux.slowMotion(0.2, 0.1); // Brief hitstop
        
        // 4. Rewards
        spawnPlasmaOrbs(deathPos, 5 + Math.floor(Math.random() * 5)); 
        
        if (enemy.userData.origin) {
            spawnFloatingText(enemy.userData.origin, "DESTROYED", true); 
        }
        window.flux.addCombo();
        
        if(enemy.userData.velocity) enemy.userData.velocity.set(0,0,0);
    };
    
    window.flux.addCombo = () => {
        comboCount++;
        window.flux.comboCount = comboCount; // Sync global
        comboTimeout = COMBO_RESET_TIME;
        updateHUD();
    };

    window.flux.showDamage = (pos, amount, isCrit) => {
        if(!pos) return;
        spawnFloatingText(pos, amount, isCrit);
    };
    
    window.flux.showParry = (pos) => {
        spawnFloatingText(pos, "PARRY", false, false, true);
    };

    window.flux.onPlayerDeath = () => {
        const screen = document.getElementById('game-over-screen');
        if(screen) screen.classList.remove('hidden');
        if(window.flux.audio) window.flux.audio.play('death');
        window.flux.slowMotion(2.0, 0.1); 
    };
}

function flashEnemy(obj) {
    if (!obj) return;
    
    // Recursive flash for Groups
    obj.traverse((child) => {
        if (child.isMesh) {
            // Handle emissive materials
            if (child.material && child.material.emissive) {
                if (!child.userData.origEmissive) child.userData.origEmissive = child.material.emissive.getHex();
                child.material.emissive.setHex(0xffffff);
                setTimeout(() => {
                    if (child.material) child.material.emissive.setHex(child.userData.origEmissive);
                }, 100);
            } 
            // Handle basic color materials
            else if (child.material && child.material.color) {
                if (!child.userData.origColor) child.userData.origColor = child.material.color.getHex();
                child.material.color.setHex(0xffffff);
                setTimeout(() => {
                    if (child.material) child.material.color.setHex(child.userData.origColor);
                }, 100);
            }
        }
    });
}

function spawnFloatingText(pos, text, isCrit, isTech = false, isParry = false) {
    if(!pos) return;
    const div = document.createElement('div');
    
    if (isParry) {
        div.className = 'damage-number damage-parry';
    } else if (isTech) {
        div.className = 'damage-number';
        div.style.color = '#ffff00';
        div.style.fontSize = '24px';
        div.style.fontStyle = 'italic';
        div.style.textShadow = '0 0 10px #ffff00';
    } else {
        div.className = isCrit ? 'damage-number damage-crit' : 'damage-number';
    }
    
    div.innerText = text;
    document.body.appendChild(div);

    const tempV = pos.clone();
    tempV.project(camera);
    
    const x = (tempV.x * .5 + .5) * window.innerWidth;
    const y = (-(tempV.y * .5) + .5) * window.innerHeight;

    div.style.left = `${x}px`;
    div.style.top = `${y}px`;

    setTimeout(() => {
        if(div.parentNode) div.parentNode.removeChild(div);
    }, 800);
}

function spawnPlasmaOrbs(pos, count) {
    if (!pos || !cubeParticles) return;
    
    // Config for Plasma Orb (larger, glowing, flies upwards then drops)
    const orbColor = 0x00f3ff;
    const orbSize = 0.4;
    const orbLife = 5.0;
    const orbGravity = 15;
    
    for (let i = 0; i < count; i++) {
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 8, // Horizontal spread
            15 + (Math.random() * 5), // Initial upward thrust
            (Math.random() - 0.5) * 8
        );
        
        const orbScale = orbSize + (Math.random() * 0.2);
        
        // Use the existing cubeParticles system, but configure the particle to represent a collectible orb
        cubeParticles.spawn(pos.clone(), vel, orbColor, orbLife, orbGravity, orbScale, 0, 0.4);
    }
}

function initPostProcessing(width, height) {
    composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    // FIXED: Increased threshold to prevent whiteout on bright effects
    bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(width/2, height/2), 1.5, 0.6, 0.85);
    composer.addPass(bloomPass);

    rgbShiftPass = new THREE.ShaderPass(THREE.RGBShiftShader);
    rgbShiftPass.uniforms['amount'].value = 0.0015;
    composer.addPass(rgbShiftPass);
}

function updateHUD() {
    const comboContainer = document.getElementById('combo-container');
    const comboText = document.getElementById('combo-count');
    const comboLabel = document.getElementById('combo-label');
    
    let styleRank = document.getElementById('style-rank');
    if (!styleRank && comboContainer) {
        styleRank = document.createElement('div');
        styleRank.id = 'style-rank';
        comboContainer.prepend(styleRank);
    }
    
    if (comboCount > 0) {
        comboContainer.classList.add('active');
        comboText.innerText = comboCount;
        
        let rankIndex = 0;
        if (comboCount > 3) rankIndex = 1; // C
        if (comboCount > 6) rankIndex = 2; // B
        if (comboCount > 10) rankIndex = 3; // A
        if (comboCount > 15) rankIndex = 4; // S
        if (comboCount > 25) rankIndex = 5; // SS
        if (comboCount > 40) rankIndex = 6; // SSS
        
        const rank = styleRanks[rankIndex];
        if (styleRank) {
            styleRank.innerText = rank;
            styleRank.className = `rank-${rank.toLowerCase()}`;
        }
        
        if (comboCount > 15) {
             comboText.style.color = '#ff0055';
             comboText.style.textShadow = '0 0 20px #ff0055';
             comboLabel.innerText = "OVERDRIVE";
        } else {
             comboText.style.color = '#00f3ff';
             comboText.style.textShadow = '2px 2px 0 #000, 0 0 15px var(--neon-blue)';
             comboLabel.innerText = "HITS";
        }
        comboText.style.transform = 'scale(1.8)';
        setTimeout(() => comboText.style.transform = 'scale(1)', 50);
    } else {
        comboContainer.classList.remove('active');
    }
}

function buildWorld(group) {
    const gridTex = TextureGen.createGrid(512, '#00f3ff', '#101025'); 
    gridTex.repeat.set(10, 10);
    
    const buildingTex = TextureGen.createBuildingTex(256, '#555'); 
    const hazardTex = TextureGen.createHazard(256);
    hazardTex.repeat.set(1, 4);
    
    const adTex = TextureGen.createAd(256, "FLUX");

    // STATIC GEOMETRY
    const floorGeo = new THREE.PlaneGeometry(300, 300);
    const floorMat = new THREE.MeshStandardMaterial({ 
        map: gridTex,
        roughness: 0.2,
        metalness: 0.3
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.1;
    floor.receiveShadow = true;
    floor.matrixAutoUpdate = false; 
    floor.updateMatrix();
    group.add(floor);
    
    const wallMat = new THREE.MeshStandardMaterial({
        map: buildingTex,
        roughness: 0.3,
        metalness: 0.5
    });
    const boxMat = new THREE.MeshStandardMaterial({ map: hazardTex });

    const centerBlock = new THREE.Mesh(new THREE.BoxGeometry(10, 4, 10), wallMat);
    centerBlock.position.set(0, 2, 0);
    centerBlock.castShadow = true;
    centerBlock.receiveShadow = true;
    centerBlock.matrixAutoUpdate = false; 
    centerBlock.updateMatrix();
    group.add(centerBlock);

    // THE LONG HALL (Wall Run Test)
    const longWallGeo = new THREE.BoxGeometry(2, 15, 60);
    const longWall1 = new THREE.Mesh(longWallGeo, wallMat);
    longWall1.position.set(-35, 7.5, 0);
    longWall1.castShadow = true;
    longWall1.receiveShadow = true;
    longWall1.matrixAutoUpdate = false;
    longWall1.updateMatrix();
    group.add(longWall1);

    const longWall2 = new THREE.Mesh(longWallGeo, wallMat);
    longWall2.position.set(35, 7.5, 0);
    longWall2.castShadow = true;
    longWall2.receiveShadow = true;
    longWall2.matrixAutoUpdate = false;
    longWall2.updateMatrix();
    group.add(longWall2);

    const rampGeo = new THREE.BoxGeometry(4, 1, 8);
    const ramp1 = new THREE.Mesh(rampGeo, boxMat);
    ramp1.position.set(0, 1, 9);
    ramp1.rotation.x = 0.4;
    ramp1.matrixAutoUpdate = false; 
    ramp1.updateMatrix();
    group.add(ramp1);

    // INSTANCED PILLARS
    const pillarGeo = new THREE.BoxGeometry(4, 20, 4);
    const pillarMesh = new THREE.InstancedMesh(pillarGeo, wallMat, 4);
    pillarMesh.castShadow = true;
    const dummy = new THREE.Object3D();
    
    for(let i=0; i<4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        dummy.position.set(Math.cos(angle) * 25, 10, Math.sin(angle) * 25);
        dummy.updateMatrix();
        pillarMesh.setMatrixAt(i, dummy.matrix);
        
        const sign = new THREE.Mesh(new THREE.PlaneGeometry(3, 1.5), new THREE.MeshBasicMaterial({ map: adTex, transparent:true, side: THREE.DoubleSide }));
        sign.position.set(Math.cos(angle) * 25, 18, Math.sin(angle) * 25);
        sign.lookAt(0, 18, 0);
        sign.matrixAutoUpdate = false;
        sign.updateMatrix();
        group.add(sign);
        
        // Add Point Lights to Pillars (Visible Source)
        const lightColor = (i % 2 === 0) ? 0x00f3ff : 0xff0055;
        const pLight = new THREE.PointLight(lightColor, 2.0, 25);
        pLight.position.set(Math.cos(angle) * 25, 16, Math.sin(angle) * 25);
        group.add(pLight);

        // Visible Bulb Mesh
        const bulb = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 8, 8), 
            new THREE.MeshBasicMaterial({ color: lightColor })
        );
        bulb.position.copy(pLight.position);
        group.add(bulb);
    }
    pillarMesh.instanceMatrix.needsUpdate = true;
    group.add(pillarMesh);
    
    // INSTANCED PLATFORMS
    const platGeo = new THREE.BoxGeometry(6, 0.5, 6);
    const platMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.4 });
    const platMesh = new THREE.InstancedMesh(platGeo, platMat, 6);
    platMesh.castShadow = true;
    platMesh.receiveShadow = true;
    
    for(let i=0; i<6; i++) {
        const angle = (i / 6) * Math.PI * 2 + 0.5;
        const dist = 18;
        dummy.position.set(Math.cos(angle) * dist, 6 + i, Math.sin(angle) * dist);
        dummy.updateMatrix();
        platMesh.setMatrixAt(i, dummy.matrix);
        
        // Add under-glow lights to platforms (Visible Source)
        const pLight = new THREE.PointLight(0xffaa00, 1.5, 15);
        pLight.position.set(Math.cos(angle) * dist, 5 + i, Math.sin(angle) * dist);
        group.add(pLight);
        
        const bulb = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 8, 8), 
            new THREE.MeshBasicMaterial({ color: 0xffaa00 })
        );
        bulb.position.copy(pLight.position);
        group.add(bulb);
    }
    platMesh.instanceMatrix.needsUpdate = true;
    group.add(platMesh);
    
    if (typeof AssetFactory !== 'undefined') {
        for (let i = 0; i < 6; i++) {
            const barrel = AssetFactory.createExplosiveBarrel();
            const bx = (Math.random() - 0.5) * 40;
            const bz = (Math.random() - 0.5) * 40;
            barrel.position.set(bx, 0, bz);
            barrel.userData = { type: 'barrel' };
            group.add(barrel);
        }
    }
    
    buildSkyline(group, buildingTex);
}

function buildSkyline(group, texture) {
    const geo = new THREE.BoxGeometry(10, 60, 10);
    const mat = new THREE.MeshBasicMaterial({ 
        map: texture, 
        color: 0x888888, // Lighter fog color
        fog: true 
    });
    
    const count = 30;
    const mesh = new THREE.InstancedMesh(geo, mat, count);
    const dummy = new THREE.Object3D();

    for(let i=0; i<count; i++) { 
        const angle = Math.random() * Math.PI * 2;
        const radius = 80 + Math.random() * 60;
        dummy.position.set(
            Math.cos(angle) * radius,
            20 + Math.random() * 20,
            Math.sin(angle) * radius
        );
        dummy.scale.y = 1 + Math.random() * 2.5;
        dummy.scale.x = 1 + Math.random();
        dummy.scale.z = 1 + Math.random();
        dummy.updateMatrix();
        mesh.setMatrixAt(i, dummy.matrix);
    }
    mesh.instanceMatrix.needsUpdate = true;
    group.add(mesh);
}

function onWindowResize() {
    if (Math.abs(window.innerWidth - lastWidth) < 10) return;
    lastWidth = window.innerWidth;
    
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    composer.setSize(window.innerWidth, window.innerHeight);
    
    const width = window.innerWidth;
    const height = window.innerHeight;
    const aspect = width / height;
    
    // Improved FOV calculation for Portrait Mode
    let vFOV;
    if (aspect < 1.0) {
        vFOV = 85; 
    } else {
        vFOV = 2 * Math.atan( Math.tan( (TARGET_HORIZONTAL_FOV * Math.PI) / 360 ) / aspect ) * (180 / Math.PI);
    }
    
    camera.aspect = aspect;
    camera.fov = vFOV;
    camera.updateProjectionMatrix();
    
    // Update Bestiary Camera if exists
    if (bestiaryCamera) {
        bestiaryCamera.aspect = aspect;
        bestiaryCamera.updateProjectionMatrix();
    }
}

function updateCameraTransparency(cam, targetMesh) {
    const dir = new THREE.Vector3().subVectors(targetMesh.position, cam.position);
    const dist = dir.length();
    dir.normalize();
    
    camRaycaster.set(cam.position, dir);
    camRaycaster.far = dist - 0.5; 
    
    const intersects = camRaycaster.intersectObjects(staticGroup.children, true);
    const objectsToFade = new Set();
    
    for (let hit of intersects) {
        let obj = hit.object;
        if (obj.isMesh && !obj.isInstancedMesh) { 
            objectsToFade.add(obj);
        }
    }
    
    for (let i = fadedObjects.length - 1; i >= 0; i--) {
        let obj = fadedObjects[i];
        if (!objectsToFade.has(obj)) {
            if (obj.userData.originalMaterial) {
                obj.material = obj.userData.originalMaterial;
                delete obj.userData.originalMaterial;
            }
            fadedObjects.splice(i, 1);
        }
    }
    
    for (let obj of objectsToFade) {
        if (!fadedObjects.includes(obj)) {
            if (!obj.userData.originalMaterial) {
                obj.userData.originalMaterial = obj.material;
            }
            if (!Array.isArray(obj.material)) {
                const newMat = obj.material.clone();
                newMat.transparent = true;
                newMat.opacity = 0.25;
                newMat.depthWrite = false; 
                obj.material = newMat;
                fadedObjects.push(obj);
            }
        }
    }
}

function animate() {
    requestAnimationFrame(animate);

    try {
        const rawDt = clock.getDelta();
        
        // --- CINEMATIC CONTROL FIX (START) ---
        if (window.flux.cinematicActive) {
            if (!document.body.classList.contains('cinematic-active')) {
                document.body.classList.add('cinematic-active');
            }
        } else {
            if (document.body.classList.contains('cinematic-active')) {
                document.body.classList.remove('cinematic-active');
            }
        }
        // --- CINEMATIC CONTROL FIX (END) ---
        
        // --- BESTIARY RENDER LOOP ---
        if (isBestiaryOpen && bestiaryScene && bestiaryCamera && bestiaryRenderer) {
            if (bestiaryModel) {
                bestiaryModel.rotation.y += rawDt * 0.5;
            }
            bestiaryRenderer.render(bestiaryScene, bestiaryCamera);
            return;
        }

        // --- PAUSE CHECK ---
        if (isPaused) {
            return;
        }
        
        frameCount++;
        const now = performance.now();
        if (now - lastTime >= 1000) {
            const fps = frameCount;
            if (debugText) debugText.innerText = fps;
            frameCount = 0;
            lastTime = now;
        }

        if (slowMoTimer > 0) {
            slowMoTimer -= rawDt;
            timeScale += (targetTimeScale - timeScale) * 10 * rawDt;
        } else {
            timeScale += (1.0 - timeScale) * 5 * rawDt;
        }
        
        if (window.flux.audio) {
            window.flux.audio.setSlowMo(timeScale);
        }
        
        let gameDt = rawDt * timeScale;
        if (gameDt > 0.05) gameDt = 0.05; 

        if (comboTimeout > 0) {
            comboTimeout -= rawDt; 
            if (comboTimeout <= 0) {
                comboCount = 0;
                window.flux.comboCount = 0;
                updateHUD();
            }
        }

        if (player && input) {
            player.update(gameDt, input, camera);
        }
        
        // Update Spawn System
        if (spawnSystem && player) {
            spawnSystem.update(gameDt, player);
        }
        
        if (deathRay) deathRay.update(gameDt);
        if (playerBeam) playerBeam.update(gameDt);
        
        // DEATH RAY COLLISION
        if (deathRay && deathRay.active && player && !player.isDead) {
            // Line segment vs Point (Player)
            // deathRay.startPos to deathRay.endPos
            // Simple distance check to line
            const p = player.mesh.position;
            const a = deathRay.startPos;
            const b = deathRay.endPos;
            
            const ab = new THREE.Vector3().subVectors(b, a);
            const ap = new THREE.Vector3().subVectors(p, a);
            
            const t = Math.max(0, Math.min(1, ap.dot(ab) / ab.lengthSq()));
            const closest = new THREE.Vector3().copy(a).add(ab.multiplyScalar(t));
            
            const dist = p.distanceTo(closest);
            
            // Beam width varies by scale
            const beamWidth = deathRay.mesh.scale.x; // Scale is radius
            
            if (dist < beamWidth + 1.0) { // +1 for player radius
                player.takeDamage(50 * gameDt); // Continuous damage
                if (window.flux.spawnParticles) window.flux.spawnParticles(p, 2, 0xff00ff, 5);
            }
        }
        
        if (enemyProjectiles) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const proj = enemyProjectiles[i];
                proj.position.add(proj.userData.velocity.clone().multiplyScalar(gameDt));
                proj.userData.life -= gameDt;
                
                if (player && !player.isDead) {
                    const dist = proj.position.distanceTo(player.mesh.position);
                    if (dist < 1.5) {
                        player.takeDamage(15);
                        window.flux.spawnParticles(proj.position, 5, 0xff0000, 10);
                        projectileGroup.remove(proj);
                        enemyProjectiles.splice(i, 1);
                        continue;
                    }
                }
                
                // Check collision with static objects (Barrels, Walls)
                if (staticGroup) {
                    // Simple ground/wall check by raycasting forward
                    const dir = proj.userData.velocity.clone().normalize();
                    const ray = new THREE.Raycaster(proj.position, dir, 0, 1.0); // Check 1 unit ahead
                    const hits = ray.intersectObjects(staticGroup.children, true);
                    if (hits.length > 0) {
                        // Hit wall
                        window.flux.spawnParticles(hits[0].point, 5, 0xffaa00, 10);
                        projectileGroup.remove(proj);
                        enemyProjectiles.splice(i, 1);
                        continue;
                    }
                }
                
                if (proj.userData.life <= 0) {
                    projectileGroup.remove(proj);
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        if (laserSystem) laserSystem.update(gameDt);
        
        // --- NEW TRAIL SYSTEM UPDATE ---
        if (window.flux.trails && player && player.mesh) {
            const updateTrail = (trail, obj, offset) => {
                if (!obj) return;
                const worldPos = new THREE.Vector3();
                obj.updateWorldMatrix(true, false);
                obj.getWorldPosition(worldPos);
                if (offset) {
                    // Apply offset in local space rotation
                    const quat = new THREE.Quaternion();
                    obj.getWorldQuaternion(quat);
                    const offsetVec = offset.clone().applyQuaternion(quat);
                    worldPos.add(offsetVec);
                }
                trail.update(worldPos, gameDt);
            };

            // Wing Tips (Binders)
            // Binders are roughly 1.4 tall, origin at 0.2y. Top is ~0.9y local.
            if (player.binderL) updateTrail(window.flux.trails.wingL, player.binderL, new THREE.Vector3(0, 0.8, 0));
            if (player.binderR) updateTrail(window.flux.trails.wingR, player.binderR, new THREE.Vector3(0, 0.8, 0));
            
            // Feet (Foot mesh is at 0,-shinLen,0 relative to shin)
            if (player.legL && player.legL.foot) updateTrail(window.flux.trails.footL, player.legL.foot, new THREE.Vector3(0, -0.2, 0));
            if (player.legR && player.legR.foot) updateTrail(window.flux.trails.footR, player.legR.foot, new THREE.Vector3(0, -0.2, 0));
        }

        if (vectorTrapGroup) {
            for(let i = vectorTrapGroup.children.length - 1; i >= 0; i--) {
                const trap = vectorTrapGroup.children[i];
                trap.userData.life -= gameDt;
                trap.scale.addScalar(trap.userData.scaleSpeed * gameDt);
                trap.rotation.x += 2 * gameDt;
                trap.rotation.y += 2 * gameDt;
                
                if (trap.material) trap.material.opacity = trap.userData.life * 3;
                
                if (trap.userData.life <= 0) {
                    vectorTrapGroup.remove(trap);
                }
            }
        }

        // --- RAIN & DUST UPDATE ---
        if (rainGroup && rainGroup.children.length > 0) {
            const rainSystem = rainGroup.children[0];
            if (rainSystem.userData && rainSystem.userData.velocities) {
                const positions = rainSystem.geometry.attributes.position.array;
                const velocities = rainSystem.userData.velocities;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] -= velocities[i / 3] * gameDt; 
                    if (positions[i + 1] < 0) {
                        positions[i + 1] = 60; 
                        positions[i] = (Math.random() - 0.5) * 200; 
                        positions[i + 2] = (Math.random() - 0.5) * 200; 
                    }
                }
                rainSystem.geometry.attributes.position.needsUpdate = true;
            }
        }

        if (dustGroup) {
            dustGroup.rotation.y += 0.05 * gameDt;
        }

        // --- CLEANUP LOOP ---
        if (trailGroup) {
            for (let i = trailGroup.children.length - 1; i >= 0; i--) {
                const trail = trailGroup.children[i];
                if (trail.userData && trail.userData.life !== undefined) {
                    trail.userData.life -= gameDt;
                    if (trail.userData.life <= 0) {
                        trailGroup.remove(trail);
                    }
                }
            }
        }

        if (ghostGroup) {
            for (let i = ghostGroup.children.length - 1; i >= 0; i--) {
                const ghost = ghostGroup.children[i];
                if (ghost.userData && ghost.userData.life !== undefined) {
                    ghost.userData.life -= gameDt;
                    if (ghost.userData.life <= 0) {
                        ghostGroup.remove(ghost);
                    }
                }
            }
        }
        
        if (particleGroup) {
             for (let i = particleGroup.children.length - 1; i >= 0; i--) {
                const p = particleGroup.children[i];
                if (p.userData && p.userData.life !== undefined) {
                    p.userData.life -= gameDt;
                    if (p.material) {
                        p.material.opacity = p.userData.life * 2.0; 
                        if (p.material.opacity > 1) p.material.opacity = 1;
                    }
                    if (p.userData.grow) {
                        p.scale.addScalar(p.userData.grow * gameDt);
                    }
                    if (p.userData.life <= 0) {
                        particleGroup.remove(p);
                    }
                }
            }
        }
        
        // --- CRITICAL FIX: UPDATE INSTANCED PARTICLES ---
        // This ensures sparks, debris, and shells age and disappear instead of persisting forever.
        if (cubeParticles) cubeParticles.update(gameDt);
        if (sparkParticles) sparkParticles.update(gameDt);
        if (debrisSystem) debrisSystem.update(gameDt);
        if (shellSystem) shellSystem.update(gameDt);

        // --- ENEMY UPDATE LOOP ---
        if (enemies) {
            const totalEnemies = enemies.length;
            for(let i=0; i<totalEnemies; i++) {
                const obj = enemies[i];
                if (!obj || !obj.userData) continue; 
                
                // If this is a new MechDroneEnemy, delegate to its controller
                if (obj.userData.controller && typeof obj.userData.controller.update === 'function') {
                    if (player) {
                        obj.userData.controller.update(gameDt, player);
                    }
                    continue;
                }

                // --- LEGACY ENEMY LOGIC (Fallback) ---
                if (obj.userData.isDead) {
                    if (gameDt > 0) {
                        obj.userData.respawnTimer -= gameDt;
                        if (obj.userData.respawnTimer <= 0) {
                            obj.userData.isDead = false;
                            obj.visible = true;
                            obj.position.copy(obj.userData.origin);
                            obj.userData.hp = obj.userData.maxHp;
                            obj.userData.velocity.set(0,0,0);
                            obj.userData.aiState = 'CHASE';
                            window.flux.spawnParticles(obj.position, 20, 0x00ff00, 5);
                        }
                    }
                    continue;
                }

                if (obj.userData.springs) {
                    const springs = obj.userData.springs;
                    let diff = springs.scale.target - springs.scale.pos;
                    let accel = (diff * springs.scale.k) - (springs.scale.vel * springs.scale.d);
                    springs.scale.vel += accel * gameDt;
                    springs.scale.pos += springs.scale.vel * gameDt;
                    
                    diff = springs.tiltX.target - springs.tiltX.pos;
                    accel = (diff * springs.tiltX.k) - (springs.tiltX.vel * springs.tiltX.d);
                    springs.tiltX.vel += accel * gameDt;
                    springs.tiltX.pos += springs.tiltX.vel * gameDt;
                    
                    diff = springs.tiltZ.target - springs.tiltZ.pos;
                    accel = (diff * springs.tiltZ.k) - (springs.tiltZ.vel * springs.tiltZ.d);
                    springs.tiltZ.vel += accel * gameDt;
                    springs.tiltZ.pos += springs.tiltZ.vel * gameDt;

                    const s = springs.scale.pos;
                    const bulge = 1.0 + (1.0 - s) * 0.5;
                    obj.scale.set(bulge, s, bulge);
                    obj.rotation.x = springs.tiltX.pos;
                    obj.rotation.z = springs.tiltZ.pos;
                }

                if (gameDt > 0 && player && !player.isDead) {
                     const distSq = obj.position.distanceToSquared(player.mesh.position);
                     
                     if (distSq > 900) {
                         if (frameCount % 4 !== (i % 4)) {
                             obj.position.addScaledVector(obj.userData.velocity, gameDt);
                             continue; 
                         }
                     }

                     aiTempVec.copy(player.mesh.position).sub(obj.position);
                     const distToPlayer = Math.sqrt(distSq);
                     
                     if (obj.userData.aiTimer > 0) obj.userData.aiTimer -= gameDt;
                     
                     if (obj.userData.aiState === 'CHASE') {
                         if (distToPlayer < 3.5) {
                             obj.userData.aiState = 'PREPARE';
                             obj.userData.aiTimer = 0.6; 
                         } else {
                             aiTempVec.normalize();
                             const speed = obj.userData.speed;
                             obj.userData.velocity.x += (aiTempVec.x * speed - obj.userData.velocity.x) * 5 * gameDt;
                             obj.userData.velocity.z += (aiTempVec.z * speed - obj.userData.velocity.z) * 5 * gameDt;
                             obj.rotation.y = Math.atan2(aiTempVec.x, aiTempVec.z);
                         }
                     } 
                     else if (obj.userData.aiState === 'PREPARE') {
                         if (obj.userData.aiTimer <= 0) {
                             obj.userData.aiState = 'ATTACK';
                             obj.userData.aiTimer = 0.2; 
                             aiForwardVec.set(Math.sin(obj.rotation.y), 0, Math.cos(obj.rotation.y));
                             obj.userData.velocity.addScaledVector(aiForwardVec, 30);
                             if(window.flux.audio) window.flux.audio.play('dash'); 
                         }
                     } else if (obj.userData.aiState === 'ATTACK') {
                         if (distToPlayer < 2.5) {
                             player.takeDamage(15);
                             obj.userData.aiState = 'RECOVER';
                             obj.userData.aiTimer = 1.5;
                             if(window.flux.audio) window.flux.audio.play('hit_flesh');
                         }
                         if (obj.userData.aiTimer <= 0) {
                             obj.userData.aiState = 'RECOVER';
                             obj.userData.aiTimer = 1.0;
                         }
                     } else if (obj.userData.aiState === 'RECOVER') {
                         obj.userData.velocity.multiplyScalar(0.9);
                         if (obj.userData.aiTimer <= 0) obj.userData.aiState = 'CHASE';
                     }

                     const vel = obj.userData.velocity;
                     if (!obj.userData.onGround) vel.y -= 60 * gameDt; 
                     if (obj.position.y + vel.y * gameDt < 1.1) {
                         obj.position.y = 1.1;
                         vel.y = 0;
                         obj.userData.onGround = true;
                     } else {
                         obj.userData.onGround = false;
                     }
                     vel.x *= 0.9;
                     vel.z *= 0.9;
                     obj.position.addScaledVector(vel, gameDt);
                }
            }
        }
        
        // --- PERFECT STABLE CAMERA ---
        if (player && player.mesh) {
            const dt = rawDt;
            const pPos = player.mesh.position.clone();
            const isPortrait = window.innerHeight > window.innerWidth;
            
            // --- HIDE PLAYER MESH IF FPS ---
            // SAFE CHECK: Ensure groups exist before accessing
            const fullBodyVisible = !player.isFirstPerson && !player.isDead;
            if (player.visualGroup) player.visualGroup.visible = fullBodyVisible;
            if (player.swordGroup) player.swordGroup.visible = fullBodyVisible && (player.currentWeapon === player.WEAPON_MELEE);
            if (player.gunGroup) player.gunGroup.visible = fullBodyVisible && (player.currentWeapon !== player.WEAPON_MELEE);

            let targetLookPos;
            if (player.isFirstPerson) {
                // Look forward from player's perspective
                const forward = new THREE.Vector3(Math.sin(player.mesh.rotation.y), 0, Math.cos(player.mesh.rotation.y));
                targetLookPos = pPos.clone().add(new THREE.Vector3(0, 1.8, 0)).add(forward.multiplyScalar(5));
            } else {
                targetLookPos = pPos.clone().add(new THREE.Vector3(0, 2.5, 0));
                // VERTICAL LOOK AHEAD (K-Style Report)
                // Pan camera up if player is ascending rapidly
                if (player.velocity.y > 5) {
                    targetLookPos.y += Math.min(player.velocity.y * 0.2, 8.0);
                }
            }
            
            // --- CINEMATIC FOCUS (NEW) ---
            let lerpFactor = 0.05;
            let finalLookTarget = targetLookPos;
            
            // Check for Lock-On Target
            if (player.targetEnemy && !player.targetEnemy.userData.isDead) {
                // Lerp camera to look at midpoint between player and target
                const targetPos = player.targetEnemy.position.clone();
                const midPoint = new THREE.Vector3().lerpVectors(pPos, targetPos, 0.5);
                midPoint.y += 2.0; // Look slightly above midpoint
                finalLookTarget = midPoint;
                lerpFactor = 0.1; // Faster focus for combat
                
                // Update Lock-On Cursor Position
                const cursor = document.getElementById('lock-cursor');
                if (cursor) {
                    cursor.classList.remove('hidden');
                    const screenPos = targetPos.clone().add(new THREE.Vector3(0, 1.0, 0)).project(camera);
                    const x = (screenPos.x * .5 + .5) * window.innerWidth;
                    const y = (-(screenPos.y * .5) + .5) * window.innerHeight;
                    
                    // Only show if in front of camera
                    if (screenPos.z < 1) {
                        cursor.style.left = `${x}px`;
                        cursor.style.top = `${y}px`;
                    } else {
                        cursor.classList.add('hidden');
                    }
                }
            } else {
                const cursor = document.getElementById('lock-cursor');
                if (cursor) cursor.classList.add('hidden');
                
                if (laserSystem && laserSystem.lasers.some(l => l.active)) {
                    const activeLaser = laserSystem.lasers.find(l => l.active);
                    if (activeLaser) {
                        // Estimate current laser position for cinematic focus
                        const laserPos = new THREE.Vector3()
                            .copy(activeLaser.p0).multiplyScalar((1-activeLaser.t) * (1-activeLaser.t))
                            .addScaledVector(activeLaser.p1, 2 * (1-activeLaser.t) * activeLaser.t)
                            .addScaledVector(activeLaser.p2, activeLaser.t * activeLaser.t);
                            
                        finalLookTarget = laserPos.clone().add(new THREE.Vector3(0, 1.0, 0)); // Look just above the laser
                        lerpFactor = 0.1; // Smoother, slower focus for cinema feel
                    }
                }
            }
            
            // Smoothly move the camera target towards the final position
            cameraProxyTarget.lerp(finalLookTarget, lerpFactor);

            // --- CAMERA LOGIC ---
            let targetDistH = player.isFirstPerson ? 0.01 : (isPortrait ? 12.0 : 8.0);
            let targetDistV = player.isFirstPerson ? 0.01 : (isPortrait ? 7.0 : 5.0);
            
            let desiredPos;

            if (player.isFirstPerson) {
                 // FPS Camera - positioned at player's head
                 const headHeight = 1.5; // Adjust based on your character height
                 camera.position.copy(player.mesh.position).add(new THREE.Vector3(0, headHeight, 0));
                 
                 // Shake effect applied to position
                 if (shakeIntensity > 0) {
                    camera.position.add(new THREE.Vector3(
                        (Math.random() - 0.5) * shakeIntensity * 0.1,
                        (Math.random() - 0.5) * shakeIntensity * 0.1,
                        (Math.random() - 0.5) * shakeIntensity * 0.1
                    ));
                 }
                 
                 // Set camera rotation based on player yaw and pitch
                 camera.rotation.order = 'YXZ';
                 // CRITICAL FIX: Rotate camera 180 degrees to face same way as mesh
                 camera.rotation.y = player.mesh.rotation.y + Math.PI; // Yaw from player (flipped)
                 camera.rotation.x = player.camPitch; // Pitch from right stick
                 
                 // Skip the rest of TPS logic (springs, lookAt, etc)
            } else {
                // FOLLOW CAMERA (Fix for "Camera facing behind me")
                // Calculate forward vector based on player rotation
                const rotY = player.mesh.rotation.y;
                const forward = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
                
                // Desired position is Behind (-Forward) and Up
                const offset = forward.clone().multiplyScalar(-targetDistH);
                offset.y = targetDistV;
                
                desiredPos = pPos.clone().add(offset);
                
                 // Third Person (Regular Spring Logic)
                 const currentToDesired = new THREE.Vector3().subVectors(desiredPos, camPosSpring);
                 const distanceToDesired = currentToDesired.length();
                 
                 const maxDistanceForSnap = 15.0;
                 if (distanceToDesired > maxDistanceForSnap) {
                     const recoveryStiffness = 30.0; // Increased stiffness for faster tracking
                     const recoveryDamping = 12.0;
                     const diff = new THREE.Vector3().subVectors(desiredPos, camPosSpring);
                     const accel = diff.multiplyScalar(recoveryStiffness).sub(camVelSpring.clone().multiplyScalar(recoveryDamping));
                     camVelSpring.add(accel.multiplyScalar(dt));
                     
                     const maxRecoveryVel = 25.0 + (distanceToDesired * 0.5);
                     if (camVelSpring.lengthSq() > maxRecoveryVel * maxRecoveryVel) {
                         camVelSpring.normalize().multiplyScalar(maxRecoveryVel);
                     }
                 } else {
                     const stiffness = 15.0; // Increased stiffness
                     const damping = 8.0;
                     const diff = new THREE.Vector3().subVectors(desiredPos, camPosSpring);
                     const accel = diff.multiplyScalar(stiffness).sub(camVelSpring.clone().multiplyScalar(damping));
                     camVelSpring.add(accel.multiplyScalar(dt));
                     
                     const maxVel = 8.0; // Increased max velocity
                     if (camVelSpring.lengthSq() > maxVel * maxVel) {
                         camVelSpring.normalize().multiplyScalar(maxVel);
                     }
                 }
                 
                camPosSpring.add(camVelSpring.clone().multiplyScalar(dt));
                
                const camToTarget = new THREE.Vector3().subVectors(cameraProxyTarget, camPosSpring).normalize();
                const idealDist = cameraProxyTarget.distanceTo(camPosSpring);
                
                camRaycaster.set(camPosSpring, camToTarget);
                camRaycaster.far = idealDist + 2.0;
                
                let finalCamPos = camPosSpring.clone();
                if (staticGroup) {
                    const hits = camRaycaster.intersectObjects(staticGroup.children, true);
                    if (hits.length > 0 && hits[0].distance < idealDist) {
                        const hitDist = Math.max(0.5, hits[0].distance - 1.0);
                        finalCamPos.copy(camPosSpring).add(camToTarget.multiplyScalar(hitDist));
                    }
                }

                if (shakeIntensity > 0) {
                    finalCamPos.add(new THREE.Vector3(
                        (Math.random() - 0.5) * shakeIntensity * 0.3,
                        (Math.random() - 0.5) * shakeIntensity * 0.3,
                        (Math.random() - 0.5) * shakeIntensity * 0.3
                    ));
                    
                    // Rotational Shake (Roll)
                    camera.rotation.z = (Math.random() - 0.5) * shakeIntensity * 0.1;
                    
                    shakeIntensity *= SHAKE_DECAY;
                    if (shakeIntensity < 0.001) {
                        shakeIntensity = 0;
                        camera.rotation.z = 0;
                    }
                } else {
                    camera.rotation.z = 0;
                }
                
                camera.position.copy(finalCamPos);
                camera.lookAt(cameraProxyTarget);
            }

            const baseFOV = player.isFirstPerson ? 90 : (isPortrait ? 75 : 60);
            camera.fov = baseFOV;
            camera.updateProjectionMatrix();
            
            if (chromaticAberrationIntensity > 0.0015) {
                chromaticAberrationIntensity *= 0.9;
            } else {
                chromaticAberrationIntensity = 0.0015;
            }
            if (rgbShiftPass) rgbShiftPass.uniforms['amount'].value = chromaticAberrationIntensity;
            
            updateCameraTransparency(camera, player.mesh);
        }
        
        // Update Offscreen Indicators
        updateOffscreenIndicators();

        composer.render();

        if (Math.random() > 0.95 && debugText) {
            debugText.innerText = Math.round(1 / (rawDt || 0.016));
        }
    } catch (e) {
        console.error("RUNTIME ERROR:", e);
    }
}</script>

</body></html>