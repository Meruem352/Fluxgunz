<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Flux GunZ Mobile</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&amp;family=Rajdhani:wght@400;600;700&amp;display=swap" rel="stylesheet">
    
    <style>:root {
    --bg-color: #050510;
    --terminal-green: #00ff9d;
    --neon-blue: #00f3ff;
    --neon-pink: #ff0055;
    --neon-yellow: #ffcc00;
    --hud-bg: rgba(0, 10, 20, 0.7);
    --hud-border: rgba(0, 243, 255, 0.3);
    --font-main: 'Rajdhani', sans-serif;
    --font-header: 'Orbitron', sans-serif;
}

* {
    box-sizing: border-box;
    user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
}

/* --- GLOBAL UTILITY --- */
.hidden {
    display: none !important;
}

body {
    margin: 0;
    padding: 0;
    background-color: #000;
    color: white;
    font-family: var(--font-main);
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100dvh;
    width: 100vw;
    position: fixed;
    /* NEW: CRITICAL FOR PREVENTING FREEZES */
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    overscroll-behavior: none;
}

/* HUD GLITCH EFFECT (Neural Zealot) */
body.hud-glitch #ui-layer {
    animation: hud-glitch-anim 0.2s infinite;
    filter: hue-rotate(90deg) contrast(1.5);
}
body.hud-glitch .hud-top-left, 
body.hud-glitch .hud-top-right {
    transform: skewX(20deg) !important;
}

@keyframes hud-glitch-anim {
    0% { transform: translate(0, 0); clip-path: inset(0 0 0 0); }
    20% { transform: translate(-5px, 5px); clip-path: inset(10% 0 80% 0); }
    40% { transform: translate(5px, -5px); clip-path: inset(80% 0 10% 0); }
    60% { transform: translate(-5px, -5px); clip-path: inset(40% 0 40% 0); }
    80% { transform: translate(5px, 5px); clip-path: inset(10% 0 60% 0); }
    100% { transform: translate(0, 0); clip-path: inset(0 0 0 0); }
}

#game-container {
    position: relative;
    width: 100%;
    height: 100%;
    max-width: 100%;
    background-color: #000;
    overflow: hidden;
    touch-action: none;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated; /* Keep retro feel */
}

/* --- UI LAYER & HUD --- */
#ui-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 40;
    pointer-events: none;
    padding: 10px;
    padding-bottom: max(10px, env(safe-area-inset-bottom));
    perspective: 1000px; /* 3D HUD Effect */
    transition: filter 0.1s;
}

/* Decorative Corners */
.hud-corner {
    position: absolute;
    width: 40px; height: 40px;
    border: 2px solid var(--neon-blue);
    opacity: 0.5;
}
.hud-corner.tl { top: 10px; left: 10px; border-right: 0; border-bottom: 0; }
.hud-corner.tr { top: 10px; right: 10px; border-left: 0; border-bottom: 0; }
.hud-corner.bl { bottom: 10px; left: 10px; border-right: 0; border-top: 0; }
.hud-corner.br { bottom: 10px; right: 10px; border-left: 0; border-top: 0; }

/* HUD Top Left */
.hud-top-left {
    position: absolute;
    top: 20px; left: 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    transform: rotateY(5deg); /* 3D Tilt */
    transform-origin: left center;
}

.status-bars {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.bar-row {
    display: flex;
    align-items: center;
    gap: 8px;
}

.bar-label {
    font-family: var(--font-header);
    font-weight: 900;
    font-size: 14px;
    color: var(--neon-blue);
    width: 25px;
    text-shadow: 0 0 5px var(--neon-blue);
}

.bar-track {
    width: 200px;
    height: 14px;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid var(--hud-border);
    position: relative;
    transform: skewX(-20deg);
    overflow: hidden;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
}

.bar-fill {
    height: 100%;
    width: 100%;
    position: absolute;
    top: 0; left: 0;
    transition: width 0.1s linear;
    z-index: 2;
}

.bar-lag {
    height: 100%;
    width: 100%;
    background: #ffffff;
    position: absolute;
    top: 0; left: 0;
    transition: width 0.5s ease-out 0.2s; /* Delay for impact feel */
    z-index: 1;
    opacity: 0.8;
}

.bar-fill.hp { 
    background: linear-gradient(90deg, #ff0055, #ff5500); 
    box-shadow: 0 0 10px #ff0055;
}
.bar-fill.ap { 
    background: linear-gradient(90deg, #00f3ff, #0055ff); 
    box-shadow: 0 0 10px #00f3ff;
}

/* Shield Bar */
#shield-bar-container {
    width: 100%;
    height: 4px;
    background: #000;
    margin-top: 2px;
    opacity: 0;
    transition: opacity 0.3s;
    transform: skewX(-20deg);
}
#shield-bar-container.active { opacity: 1; }
#shield-bar {
    width: 100%; height: 100%;
    background: #00ffff;
    box-shadow: 0 0 8px #00ffff;
    transition: width 0.1s;
}

/* Ammo */
.ammo-container {
    margin-top: 10px;
    background: linear-gradient(90deg, rgba(0,0,0,0.8), transparent);
    padding: 5px 10px;
    border-left: 4px solid var(--terminal-green);
    display: flex;
    flex-direction: column;
    transform: skewX(-10deg);
}
.weapon-info {
    display: flex;
    align-items: center;
    gap: 10px;
}
#weapon-name {
    font-family: var(--font-header);
    font-size: 12px;
    color: #aaa;
    letter-spacing: 1px;
}
.weapon-line {
    flex: 1;
    height: 1px;
    background: #555;
}
#ammo-count {
    font-family: var(--font-header);
    font-size: 24px;
    font-weight: 900;
    color: var(--terminal-green);
    text-shadow: 0 0 10px var(--terminal-green);
    line-height: 1;
}
#reload-msg {
    color: var(--neon-yellow);
    font-family: var(--font-header);
    font-size: 12px;
    animation: blink 0.2s infinite;
    margin-top: 5px;
    text-shadow: 0 0 5px var(--neon-yellow);
}

/* HUD Top Right */
.hud-top-right {
    position: absolute;
    top: 20px; right: 20px;
    transform: rotateY(-5deg);
    transform-origin: right center;
}
.debug-panel {
    background: var(--hud-bg);
    border: 1px solid var(--hud-border);
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 10px;
    color: #888;
    backdrop-filter: blur(4px);
}
.debug-row span { color: var(--neon-blue); font-weight: bold; }

/* Combo & Style */
#combo-container {
    position: absolute;
    top: 25%; right: 30px;
    text-align: right;
    opacity: 0;
    transform: translateX(50px) skewX(-10deg);
    transition: opacity 0.2s, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
#combo-container.active { opacity: 1; transform: translateX(0) skewX(-10deg); }

.combo-wrapper {
    display: flex;
    align-items: center;
    gap: 15px;
}
#style-rank {
    font-family: var(--font-header);
    font-size: 80px;
    font-weight: 900;
    font-style: italic;
    line-height: 1;
    text-shadow: 5px 5px 0 rgba(0,0,0,0.8);
    transform: scale(1);
    transition: transform 0.1s;
}
.combo-info {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
}
#combo-count {
    font-family: var(--font-header);
    font-size: 42px;
    font-weight: 900;
    color: var(--neon-blue);
    line-height: 0.9;
    text-shadow: 0 0 10px var(--neon-blue);
}
#combo-label {
    font-size: 14px;
    color: #fff;
    letter-spacing: 4px;
    font-weight: 600;
}

/* Style Ranks Colors */
.rank-d { color: #999; }
.rank-c { color: #fff; text-shadow: 0 0 10px #fff; }
.rank-b { color: #0f0; text-shadow: 0 0 15px #0f0; }
.rank-a { color: #ff0; text-shadow: 0 0 20px #ff0; }
.rank-s { color: #f00; text-shadow: 0 0 25px #f00; animation: shake 0.5s infinite; }
.rank-ss { color: #f0f; text-shadow: 0 0 30px #f0f; animation: glitch 0.2s infinite; }
.rank-sss { 
    background: linear-gradient(to bottom, #fff, #0ff, #f0f); 
    -webkit-background-clip: text; 
    -webkit-text-fill-color: transparent;
    filter: drop-shadow(0 0 10px #fff);
    animation: pulse 0.1s infinite;
}

/* --- SPACE HUD ELEMENTS --- */
#space-hud-overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
    display: none; /* Active only in space */
}

.prograde-marker {
    position: absolute;
    width: 20px; height: 20px;
    border: 2px solid var(--terminal-green);
    border-radius: 50%;
    transform: translate(-50%, -50%);
}
.prograde-marker::after {
    content: '';
    position: absolute;
    top: -5px; left: 50%;
    width: 2px; height: 5px;
    background: var(--terminal-green);
    transform: translateX(-50%);
}
.prograde-marker::before {
    content: '';
    position: absolute;
    left: -5px; top: 50%;
    width: 5px; height: 2px;
    background: var(--terminal-green);
    transform: translateY(-50%);
}

.retrograde-marker {
    position: absolute;
    width: 20px; height: 20px;
    border: 2px solid var(--neon-pink);
    border-radius: 50%;
    transform: translate(-50%, -50%);
}
.retrograde-marker::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 14px; height: 14px;
    border: 1px solid var(--neon-pink);
    transform: translate(-50%, -50%) rotate(45deg);
}

.flight-mode-indicator {
    position: absolute;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    font-family: var(--font-header);
    font-size: 12px;
    color: var(--neon-blue);
    background: rgba(0, 20, 40, 0.8);
    padding: 4px 10px;
    border: 1px solid var(--neon-blue);
    border-radius: 4px;
    letter-spacing: 2px;
    text-shadow: 0 0 5px var(--neon-blue);
}
.flight-mode-indicator.decoupled {
    color: var(--neon-pink);
    border-color: var(--neon-pink);
    text-shadow: 0 0 5px var(--neon-pink);
}

/* SPACE OBJECTIVES */
#space-objectives {
    position: absolute;
    top: 120px; left: 20px;
    display: flex;
    flex-direction: column;
    gap: 5px;
    transform: skewX(-10deg);
}
.objective-header {
    font-family: var(--font-header);
    color: var(--neon-yellow);
    font-size: 12px;
    letter-spacing: 2px;
    margin-bottom: 5px;
    text-shadow: 0 0 5px var(--neon-yellow);
}
.objective-item {
    font-size: 12px;
    color: #fff;
    background: rgba(0, 0, 0, 0.5);
    padding: 4px 8px;
    border-left: 2px solid #555;
    transition: all 0.3s;
}
.objective-item.active {
    border-color: var(--neon-blue);
    color: var(--neon-blue);
}
.objective-item.done {
    border-color: var(--terminal-green);
    color: #555;
    text-decoration: line-through;
}

/* SPACE LOCK INDICATORS */
.space-lock-indicator {
    position: absolute;
    width: 40px; height: 40px;
    border: 2px solid var(--terminal-green);
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 30;
    box-shadow: 0 0 10px var(--terminal-green);
    animation: lockOn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.space-lock-indicator.locked {
    border-color: var(--neon-pink);
    box-shadow: 0 0 15px var(--neon-pink);
    transform: translate(-50%, -50%) rotate(45deg);
}
.space-lock-indicator::before {
    content: '';
    position: absolute;
    top: -5px; left: -5px;
    width: 10px; height: 10px;
    border-top: 2px solid white;
    border-left: 2px solid white;
}
.space-lock-indicator::after {
    content: '';
    position: absolute;
    bottom: -5px; right: -5px;
    width: 10px; height: 10px;
    border-bottom: 2px solid white;
    border-right: 2px solid white;
}

@keyframes lockOn { 
    from { transform: translate(-50%, -50%) scale(2); opacity: 0; } 
    to { transform: translate(-50%, -50%) scale(1); opacity: 1; } 
}

/* --- CONTROLS --- */
#controls {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 30;
    pointer-events: auto;
}

/* JOYSTICK STYLES - GPU OPTIMIZED */
.joystick-zone {
    position: absolute;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    pointer-events: none;
    /* GPU Optimization */
    will-change: transform;
    transform: translateZ(0);
    transform-origin: center center;
    /* Center anchor logic handled by JS positioning top/left */
    margin-left: -60px; /* Center on touch point */
    margin-top: -60px;
}

.joystick-knob {
    position: absolute;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(0, 243, 255, 0.8);
    box-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
    /* Center in parent using margins so JS only does offset */
    left: 50%;
    top: 50%;
    margin-left: -25px;
    margin-top: -25px;
    /* GPU Optimization */
    will-change: transform;
    transform: translateZ(0);
}

/* Buttons */
.btn {
    position: absolute;
    border-radius: 12px; /* Squircle */
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(0, 15, 30, 0.6);
    backdrop-filter: blur(8px);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: var(--font-header);
    box-shadow: 0 4px 15px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,255,255,0.05);
    transition: transform 0.05s, background 0.1s, border-color 0.1s;
    touch-action: none;
    /* GPU Layer */
    will-change: transform;
    transform: translateZ(0);
}
.btn:active {
    transform: scale3d(0.92, 0.92, 1); /* GPU scale */
    background: rgba(255, 255, 255, 0.15);
    border-color: var(--neon-blue);
}
.btn span {
    font-size: 24px;
    filter: drop-shadow(0 0 5px rgba(255,255,255,0.5));
}

/* Sizes */
.btn.small { width: 50px; height: 50px; font-size: 16px; }
.btn.medium { width: 65px; height: 65px; font-size: 20px; }
.btn.large { width: 90px; height: 90px; font-size: 32px; border-width: 2px; }
.btn.tiny { width: 50px; height: 50px; font-size: 14px; opacity: 0.8; }

/* Colors */
#btn-attack { border-color: var(--neon-pink); background: rgba(255, 0, 85, 0.15); }
#btn-jump { border-color: var(--terminal-green); background: rgba(0, 255, 157, 0.1); }
#btn-dash { border-color: var(--neon-blue); background: rgba(0, 243, 255, 0.1); }
#btn-block { border-color: var(--neon-yellow); background: rgba(255, 204, 0, 0.1); }
#btn-tech { border-color: #fff; background: rgba(255, 255, 255, 0.1); }
#btn-missile { border-color: #ffaa00; background: rgba(255, 170, 0, 0.15); }

/* Layout Positions (Default) */
#btn-attack { bottom: 40px; right: 40px; }
#btn-jump { bottom: 20px; right: 140px; }
#btn-dash { bottom: 140px; right: 20px; }
#btn-block { bottom: 100px; right: 120px; }
#btn-switch { bottom: 20px; right: 220px; }
#btn-reload { bottom: 180px; right: 100px; }
#btn-tech { bottom: 150px; right: 80px; }
#btn-missile { bottom: 90px; right: 10px; }

.control-cluster.left {
    position: absolute;
    left: 20px; bottom: 100px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.btn.toggle {
    position: relative;
    width: 55px; height: 55px;
    margin-bottom: 0; /* Reset */
}
#btn-gyro.active { background: var(--neon-blue); color: black; box-shadow: 0 0 15px var(--neon-blue); }

/* --- MODALS & MENUS --- */
.modal {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 5, 10, 0.85);
    backdrop-filter: blur(15px);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
}

.modal-content {
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid var(--neon-blue);
    padding: 40px;
    width: 400px;
    text-align: center;
    box-shadow: 0 0 50px rgba(0, 243, 255, 0.1);
    position: relative;
    clip-path: polygon(
        20px 0, 100% 0, 
        100% calc(100% - 20px), calc(100% - 20px) 100%, 
        0 100%, 0 20px
    );
}

.menu-header h1 {
    font-family: var(--font-header);
    font-size: 32px;
    color: white;
    margin: 0;
    letter-spacing: 2px;
}
.menu-deco-line {
    width: 100%; height: 2px;
    background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
    margin: 15px 0 25px 0;
}

.menu-grid {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.menu-btn {
    background: rgba(0, 243, 255, 0.05);
    border: 1px solid rgba(0, 243, 255, 0.3);
    color: var(--neon-blue);
    padding: 15px;
    font-family: var(--font-main);
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
}
.menu-btn:hover {
    background: rgba(0, 243, 255, 0.2);
    letter-spacing: 1px;
}
.menu-btn:active {
    background: var(--neon-blue);
    color: black;
}
.menu-btn.highlight {
    border-color: var(--neon-pink);
    color: var(--neon-pink);
    background: rgba(255, 0, 85, 0.1);
}
.menu-btn.highlight:hover { background: rgba(255, 0, 85, 0.3); }
.menu-btn.disabled { opacity: 0.4; pointer-events: none; border-color: #555; color: #555; }

/* --- BESTIARY --- */
.bestiary-container {
    width: 90%; height: 90%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}
.bestiary-header {
    font-family: var(--font-header);
    font-size: 24px;
    color: var(--neon-yellow);
    letter-spacing: 4px;
    text-shadow: 0 0 10px var(--neon-yellow);
}
.bestiary-view-wrapper {
    flex: 1;
    width: 100%;
    position: relative;
    border: 1px solid #333;
    background: radial-gradient(circle, #1a1a2e 0%, #000 100%);
}
.bestiary-view { width: 100%; height: 100%; }
.view-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
}
.corner {
    position: absolute; width: 20px; height: 20px;
    border: 2px solid var(--neon-blue);
}
.corner.tl { top: 10px; left: 10px; border-right: 0; border-bottom: 0; }
.corner.tr { top: 10px; right: 10px; border-left: 0; border-bottom: 0; }
.corner.bl { bottom: 10px; left: 10px; border-right: 0; border-top: 0; }
.corner.br { bottom: 10px; right: 10px; border-left: 0; border-top: 0; }

.bestiary-controls {
    display: flex; align-items: center; gap: 20px; width: 100%; justify-content: center;
}
.nav-btn {
    background: none; border: 1px solid var(--neon-blue); color: var(--neon-blue);
    width: 40px; height: 40px; font-size: 20px; cursor: pointer;
    transition: all 0.2s;
}
.nav-btn:hover { background: var(--neon-blue); color: black; }
.bestiary-label-container { text-align: center; }
#bestiary-label {
    font-family: var(--font-header);
    font-size: 28px; color: white; font-weight: bold;
}
.label-deco { width: 100%; height: 2px; background: var(--neon-pink); margin-top: 5px; }
.bestiary-info {
    width: 100%; padding: 15px;
    background: rgba(0,0,0,0.7);
    border-left: 4px solid var(--neon-blue);
    color: #ccc; font-size: 16px; text-align: center;
}

/* --- LOADING SCREEN --- */
#loading-screen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: #000;
    z-index: 9999;
    display: flex; justify-content: center; align-items: center;
}
.loading-content {
    text-align: center;
    display: flex; flex-direction: column; gap: 20px; align-items: center;
    z-index: 2;
}
.loading-logo {
    font-family: var(--font-header);
    font-size: 48px;
    color: var(--neon-blue);
    text-shadow: 0 0 20px var(--neon-blue);
    letter-spacing: 5px;
}
.loading-bar-container {
    width: 300px; height: 4px; background: #333;
    position: relative; overflow: hidden;
}
.loading-bar-fill {
    width: 100%; height: 100%; background: var(--terminal-green);
    animation: loadBar 2s infinite ease-in-out;
    transform-origin: left;
}
.tap-prompt {
    color: white; font-size: 14px; letter-spacing: 2px;
    animation: blink 1s infinite;
    margin-top: 20px;
}
@keyframes loadBar { 0% { transform: scaleX(0); } 50% { transform: scaleX(1); } 100% { transform: scaleX(0); transform-origin: right; } }

/* --- GAME OVER SCREEN --- */
#game-over-screen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9);
    z-index: 9000;
    display: flex; justify-content: center; align-items: center;
}
.go-content { text-align: center; }
.glitch-text {
    font-family: var(--font-header);
    font-size: 64px;
    color: var(--neon-pink);
    text-shadow: 2px 2px 0px #00ffff;
    animation: glitch 0.3s infinite;
}
.sub-text { color: #aaa; letter-spacing: 4px; margin-top: 10px; }

/* --- FLOATING TEXT --- */
.damage-number {
    position: absolute;
    font-family: var(--font-header);
    font-weight: 900;
    font-size: 32px;
    pointer-events: none;
    text-shadow: 2px 2px 0 #000;
    animation: floatUp 0.8s cubic-bezier(0.215, 0.610, 0.355, 1.000) forwards;
    z-index: 100;
    color: white;
}
.damage-crit { 
    color: #ff0055; font-size: 48px; 
    text-shadow: 0 0 10px #ff0055, 3px 3px 0 #000;
}
.damage-parry {
    color: #00ffff; font-size: 40px; font-style: italic;
    text-shadow: 0 0 15px #00ffff;
}

/* --- MENU BUTTON (UPDATED POSITION FOR MOBILE) --- */
#btn-menu {
    top: 80px; /* Moved down from 60px */
    left: 50%; transform: translateX(-50%);
    width: 60px; height: 35px; /* Slightly larger */
    background: rgba(0,0,0,0.9);
    border: 1px solid var(--neon-blue);
    border-top: none;
    clip-path: polygon(0 0, 100% 0, 80% 100%, 20% 100%);
    display: flex; justify-content: center; align-items: center;
    cursor: pointer;
    pointer-events: auto; /* Ensure clickable */
    z-index: 200; /* Ensure on top */
}
#btn-menu .icon { color: var(--neon-blue); font-size: 20px; margin-top: -5px; }

/* --- LAUNCH BUTTON --- */
#btn-launch {
    top: 120px; /* Moved down relative to menu */
    left: 50%; transform: translateX(-50%);
    width: 120px; height: 40px;
    background: rgba(255, 0, 85, 0.2);
    border: 1px solid var(--neon-pink);
    clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
    display: flex; justify-content: center; align-items: center;
    cursor: pointer;
    pointer-events: auto; /* Ensure clickable */
    transition: all 0.2s;
}
#btn-launch:active {
    background: var(--neon-pink);
    color: black;
}
#btn-launch .text {
    font-family: var(--font-header);
    color: var(--neon-pink);
    font-weight: bold;
    letter-spacing: 2px;
}
#btn-launch:active .text { color: black; }

/* --- HUD EDITOR --- */
#hud-editor {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 2000;
    background: rgba(0, 20, 0, 0.95);
    display: flex;
    flex-direction: column;
}
.editor-toolbar {
    background: #000; border-bottom: 2px solid var(--terminal-green);
    display: flex;
    justify-content: space-between; padding: 15px 30px;
    align-items: center;
}
.editor-actions { display: flex; gap: 10px; }
.editor-btn {
    background: #003300; border: 1px solid #00ff00; color: #00ff00;
    padding: 8px 16px; cursor: pointer; font-family: var(--font-main);
}
.editor-btn:hover { background: #005500; }
.editor-btn.close { border-color: #ff0055; color: #ff0055; background: #330000; }

/* --- ANIMATIONS --- */
@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
@keyframes floatUp {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
    20% { transform: translate(-50%, -150%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -300%) scale(1.0); opacity: 0; }
}
@keyframes glitch { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0); } }
@keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
@keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }

/* --- LOCK-ON CURSOR --- */
#lock-cursor {
    position: absolute;
    width: 80px;
    height: 80px;
    /* Centering handled by JS setting left/top + this transform */
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 100; /* High Z-Index to ensure visibility */
    display: flex;
    justify-content: center;
    align-items: center;
    transition: opacity 0.1s;
}

/* Outer rotating ring */
.lock-ring {
    position: absolute;
    width: 100%; height: 100%;
    border: 2px dashed var(--neon-pink);
    border-radius: 50%;
    animation: lockSpin 4s linear infinite;
    box-shadow: 0 0 15px var(--neon-pink); /* Stronger glow */
    opacity: 0.9;
}

/* Inner counter-rotating ring */
.lock-ring-inner {
    position: absolute;
    width: 60%; height: 60%;
    border: 1px solid var(--neon-blue);
    border-radius: 50%;
    border-left-color: transparent;
    border-right-color: transparent;
    animation: lockSpinRev 2s linear infinite;
    box-shadow: 0 0 8px var(--neon-blue);
}

/* Corner Brackets */
.lock-brackets {
    position: absolute;
    width: 120%; height: 120%;
    border: 2px solid rgba(255, 255, 255, 0.8);
    clip-path: polygon(
        0 0, 20% 0, 0 20%, 
        0 80%, 20% 100%, 0 100%,
        100% 0, 80% 0, 100% 20%,
        100% 100%, 80% 100%, 100% 80%
    );
    background: 
        linear-gradient(to right, var(--neon-pink) 2px, transparent 2px) 0 0,
        linear-gradient(to bottom, var(--neon-pink) 2px, transparent 2px) 0 0,
        linear-gradient(to left, var(--neon-pink) 2px, transparent 2px) 100% 0,
        linear-gradient(to bottom, var(--neon-pink) 2px, transparent 2px) 100% 0,
        linear-gradient(to right, var(--neon-pink) 2px, transparent 2px) 0 100%,
        linear-gradient(to top, var(--neon-pink) 2px, transparent 2px) 0 100%,
        linear-gradient(to left, var(--neon-pink) 2px, transparent 2px) 100% 100%,
        linear-gradient(to top, var(--neon-pink) 2px, transparent 2px) 100% 100%;
    background-repeat: no-repeat;
    background-size: 15px 15px;
    animation: lockPulse 0.5s ease-in-out infinite alternate; /* Faster pulse */
}

.lock-text {
    position: absolute;
    top: 120%; /* Moved down slightly */
    font-family: var(--font-header);
    font-size: 12px;
    font-weight: bold;
    color: white;
    background: rgba(255, 0, 85, 0.8);
    padding: 2px 8px;
    border-radius: 4px;
    letter-spacing: 1px;
    white-space: nowrap;
    box-shadow: 0 0 10px var(--neon-pink);
    text-shadow: 0 0 2px black;
}

/* --- NEW: ROOM CODE INPUT --- */
.flux-input {
    background: rgba(0, 20, 40, 0.8);
    border: 1px solid var(--neon-blue);
    color: var(--neon-blue);
    font-family: var(--font-main);
    font-size: 18px;
    padding: 10px;
    text-align: center;
    width: 250px;
    margin-top: 15px;
    text-transform: uppercase;
    outline: none;
    letter-spacing: 2px;
    pointer-events: auto; /* Ensure clickable */
}
.flux-input::placeholder {
    color: rgba(0, 243, 255, 0.5);
}
.flux-input:focus {
    box-shadow: 0 0 15px var(--neon-blue);
    background: rgba(0, 40, 80, 0.9);
}

@keyframes lockSpin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
@keyframes lockSpinRev { 0% { transform: rotate(0deg); } 100% { transform: rotate(-360deg); } }
@keyframes lockPulse { 0% { transform: scale(1); opacity: 0.8; } 100% { transform: scale(1.1); opacity: 1; } }</style>
    
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post Processing Imports -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/RGBShiftShader.js"></script>

</head>
<body>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="loading-logo">FLUX ENGINE</div>
            <div class="loading-bar-container">
                <div class="loading-bar-fill"></div>
            </div>
            <div class="loading-text">SYSTEM INITIALIZATION...</div>
            
            <!-- ROOM CODE INPUT -->
            <input type="text" id="room-code-input" class="flux-input" placeholder="ROOM CODE (OPTIONAL)" maxlength="10" autocomplete="off">
            
            <div class="tap-prompt">TAP TERMINAL TO ENGAGE</div>
        </div>
        <div class="scanline-overlay"></div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden">
        <div class="go-content">
            <div class="glitch-text" data-text="CRITICAL FAILURE">CRITICAL FAILURE</div>
            <div class="sub-text">SYSTEM REBOOT REQUIRED</div>
            <div class="tap-prompt">TAP TO RESTART</div>
        </div>
    </div>

    <!-- MAIN MENU MODAL -->
    <div id="main-menu" class="modal hidden">
        <div class="modal-content">
            <div class="menu-header">
                <h1 class="glitch-text" data-text="FLUX OS v9.0">FLUX OS v9.0</h1>
                <div class="menu-deco-line"></div>
            </div>
            <div class="menu-grid">
                <button class="menu-btn" id="menu-mechs">
                    <span class="btn-icon">‚óà</span> MECHS (BESTIARY)
                </button>
                <button class="menu-btn disabled" id="menu-items">
                    <span class="btn-icon">üîí</span> ITEMS [LOCKED]
                </button>
                <button class="menu-btn disabled" id="menu-arena">
                    <span class="btn-icon">üîí</span> ARENA [LOCKED]
                </button>
                <button class="menu-btn" id="menu-options">
                    <span class="btn-icon">‚öô</span> OPTIONS
                </button>
                <button class="menu-btn highlight" id="menu-quit">
                    <span class="btn-icon">‚ñ∂</span> RESUME
                </button>
            </div>
        </div>
    </div>

    <!-- BESTIARY MODAL -->
    <div id="bestiary-menu" class="modal hidden">
        <div class="bestiary-container">
            <div class="bestiary-header">TACTICAL DATABASE</div>
            <div class="bestiary-view-wrapper">
                <div class="bestiary-view" id="bestiary-canvas-container">
                    <!-- 3D View Rendered Here -->
                </div>
                <div class="view-overlay">
                    <div class="corner tl"></div><div class="corner tr"></div>
                    <div class="corner bl"></div><div class="corner br"></div>
                </div>
            </div>
            <div class="bestiary-controls">
                <button class="nav-btn" id="bestiary-prev">&lt;</button>
                <div class="bestiary-label-container">
                    <div id="bestiary-label">DRONE: STANDARD</div>
                    <div class="label-deco"></div>
                </div>
                <button class="nav-btn" id="bestiary-next">&gt;</button>
            </div>
            <div class="bestiary-info">
                <p id="bestiary-desc">Standard combat drone equipped with laser weaponry. Common threat.</p>
            </div>
            <button class="menu-btn small" id="bestiary-back">RETURN</button>
        </div>
    </div>

    <!-- OPTIONS MODAL -->
    <div id="options-menu" class="modal hidden">
        <div class="modal-content">
            <h1>SYSTEM CONFIG</h1>
            <div class="menu-deco-line"></div>
            <button class="menu-btn" id="opt-layout">HUD LAYOUT EDITOR</button>
            <button class="menu-btn small" id="opt-back">RETURN</button>
        </div>
    </div>

    <!-- HUD EDITOR OVERLAY -->
    <div id="hud-editor" class="hidden">
        <div class="editor-toolbar">
            <span>LAYOUT EDITOR // DRAG TO MOVE</span>
            <div class="editor-actions">
                <button class="editor-btn" id="editor-save">SAVE</button>
                <button class="editor-btn" id="editor-load">LOAD</button>
                <button class="editor-btn" id="editor-reset">RESET</button>
                <button class="editor-btn close" id="editor-close">EXIT</button>
            </div>
        </div>
        <input type="file" id="layout-file-input" style="display:none" accept=".json">
        <div class="editor-grid"></div>
    </div>

    <!-- Cinematic Bars -->
    <div class="cinematic-bar top"></div>
    <div class="cinematic-bar bottom"></div>

    <!-- Game Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- Scanline Overlay & Vignette -->
        <div class="scanlines"></div>
        <div class="vignette"></div>
        <div class="noise-overlay"></div>

        <!-- UI / HUD -->
        <div id="ui-layer">
            <!-- DEBUG OVERLAY - Add this inside #ui-layer -->
            <div id="debug-overlay" style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: lime;
                padding: 20px;
                font-family: monospace;
                font-size: 16px;
                border: 2px solid lime;
                z-index: 9999;
                text-align: left;
                min-width: 300px;
                pointer-events: none;
            ">
                <div>STATUS: <span id="debug-status">Connecting...</span></div>
                <div>ROOM: <span id="debug-room">---</span></div>
                <div>PLAYERS: <span id="debug-players">0</span></div>
                <div>MY ID: <span id="debug-myid">---</span></div>
            </div>

            <!-- Decorative Corners -->
            <div class="hud-corner tl"></div>
            <div class="hud-corner tr"></div>
            <div class="hud-corner bl"></div>
            <div class="hud-corner br"></div>

            <!-- Menu Toggle Button -->
            <button id="btn-menu" class="hud-btn">
                <span class="icon">‚ò∞</span>
            </button>

            <!-- LAUNCH BUTTON (Mobile Flight Trigger) -->
            <button id="btn-launch" class="hud-btn wide">
                <span class="text">LAUNCH</span>
            </button>

            <!-- Dynamic Crosshair -->
            <div id="crosshair">
                <div class="ch-dot"></div>
                <div class="ch-circle"></div>
                <div class="ch-lines"></div>
            </div>

            <!-- Lock-On Cursor -->
            <div id="lock-cursor" class="hidden">
                <div class="lock-ring"></div>
                <div class="lock-ring-inner"></div>
                <div class="lock-brackets"></div>
                <div class="lock-text">TARGET LOCK</div>
            </div>
            
            <!-- Off-Screen Indicators (Threat Halos) -->
            <div id="offscreen-indicators"></div>

            <div class="hud-top-left">
                <div class="status-bars">
                    <div class="bar-row">
                        <div class="bar-label">HP</div>
                        <div class="bar-track">
                            <div id="hp-bar-lag" class="bar-lag"></div>
                            <div id="hp-bar" class="bar-fill hp"></div>
                        </div>
                    </div>
                    <div class="bar-row">
                        <div class="bar-label">AP</div>
                        <div class="bar-track">
                            <div id="ap-bar-lag" class="bar-lag"></div>
                            <div id="ap-bar" class="bar-fill ap"></div>
                        </div>
                    </div>
                    <!-- Shield Bar (Dynamically injected usually, but structure here for ref) -->
                    <div id="shield-bar-container">
                        <div id="shield-bar"></div>
                    </div>
                </div>
                
                <!-- Ammo Indicator -->
                <div class="ammo-container" id="ammo-display">
                    <div class="weapon-info">
                        <span id="weapon-name">KATANA</span>
                        <div class="weapon-line"></div>
                    </div>
                    <span id="ammo-count">---</span>
                </div>
                <div id="reload-msg" class="hidden">RELOAD REQUIRED</div>
            </div>

            <div class="hud-top-right">
                <!-- Credits Display -->
                <div class="credits-container">
                    <span class="currency-symbol">‚óà</span>
                    <span id="credits-count">0</span>
                </div>

                <div class="debug-panel">
                    <div class="debug-row">FPS <span id="fps-counter">60</span></div>
                    <div class="debug-row" id="res-debug">RES 50%</div>
                </div>
            </div>

            <div id="combo-container">
                <div class="combo-wrapper">
                    <div id="style-rank" class="rank-d">D</div>
                    <div class="combo-info">
                        <div id="combo-count">0</div>
                        <div id="combo-label">HITS</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="controls">
            <!-- Left Joystick (Movement) -->
            <div id="joystick-zone-left" class="joystick-zone hidden">
                <div id="joystick-knob-left" class="joystick-knob"></div>
            </div>
            
            <!-- Right Joystick (Camera) -->
            <div id="joystick-zone-right" class="joystick-zone hidden">
                <div id="joystick-knob-right" class="joystick-knob"></div>
            </div>

            <!-- Left Side Toggles -->
            <div class="control-cluster left">
                <button class="btn toggle" id="btn-lock" data-action="lock"><span>üéØ</span></button>
                <button class="btn toggle" id="btn-cam-switch" data-action="cam-switch"><span>üëÅ</span></button>
                <button class="btn toggle" id="btn-gyro" data-action="gyro"><span>üì±</span></button>
            </div>

            <!-- Right Side Actions -->
            <div id="action-buttons">
                <button class="btn action small" id="btn-reload" data-action="reload"><span>‚Üª</span></button>
                <button class="btn action small" id="btn-switch" data-action="switch"><span>‚öî</span></button>
                <button class="btn action medium" id="btn-block" data-action="block"><span>üõ°</span></button>
                <button class="btn action medium" id="btn-dash" data-action="dash"><span>‚ö°</span></button>
                <button class="btn action medium" id="btn-jump" data-action="jump"><span>‚ñ≤</span></button>
                <button class="btn action large" id="btn-attack" data-action="attack"><span>üí•</span></button>
                
                <!-- NEW: Missile Button -->
                <button class="btn action small" id="btn-missile" data-action="missile"><span>üöÄ</span></button>
                
                <!-- Tech button (Flight Mode Toggle) -->
                <button class="btn action tiny" id="btn-tech" data-action="tech"><span>‚òÖ</span></button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>/**
 * TEXTURE GENERATOR - HERCULEAN GRAPHICS UPDATE
 * High-fidelity procedural textures with multi-pass noise and blending.
 * UPDATED: Added Procedural MatCap for Anime-style lighting.
 * UPDATED: Vibrant Color Palette & Increased Brightness
 * UPDATED: Added Soft Sprite for particles/stars (Fixes square artifacts).
 * UPDATED: Added Planet Texture generator (Solar System Expansion).
 */
const TextureGen = {
    
    // Helper: Simple Pseudo-Random Noise
    noise2D: function(x, y) {
        const dot = (x, y) => {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        };
        const i_x = Math.floor(x);
        const i_y = Math.floor(y);
        const f_x = x - i_x;
        const f_y = y - i_y;
        
        const a = dot(i_x, i_y);
        const b = dot(i_x + 1, i_y);
        const c = dot(i_x, i_y + 1);
        const d = dot(i_x + 1, i_y + 1);
        
        const u_x = f_x * f_x * (3.0 - 2.0 * f_x);
        const u_y = f_y * f_y * (3.0 - 2.0 * f_y);
        
        return a + (b - a) * u_x + (c - a) * u_y + (a - b - c + d) * u_x * u_y;
    },

    createNoise: function(ctx, width, height, alpha = 0.1) {
        const imgData = ctx.createImageData(width, height);
        const buffer = new Uint32Array(imgData.data.buffer);
        const len = buffer.length;
        for (let i = 0; i < len; i++) {
            if (Math.random() < 0.5) continue; 
            const val = Math.random() * 255;
            buffer[i] = (Math.floor(val * alpha) << 24) | (val << 16) | (val << 8) | val;
        }
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = width;
        tmpCanvas.height = height;
        tmpCanvas.getContext('2d').putImageData(imgData, 0, 0);
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(tmpCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    },

    createSoftSprite: function() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        const cx = 32;
        const cy = 32;
        const r = 32;
        
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
        grad.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
        grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
        grad.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);
        
        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    },

    // UPDATED: Solar System Textures
    createPlanetTexture: function(size = 512, type = 'earth') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        // 1. Base Fill
        if (type === 'earth') ctx.fillStyle = '#001133';
        else if (type === 'mars') ctx.fillStyle = '#8B4513';
        else if (type === 'jupiter') ctx.fillStyle = '#D2B48C';
        else if (type === 'moon') ctx.fillStyle = '#1a1a1a';
        else if (type === 'sun') ctx.fillStyle = '#ffaa00';
        else if (type === 'mercury') ctx.fillStyle = '#444444';
        else if (type === 'venus') ctx.fillStyle = '#e6c229';
        else if (type === 'saturn') ctx.fillStyle = '#f4d03f';
        else if (type === 'uranus') ctx.fillStyle = '#73c6b6';
        else if (type === 'neptune') ctx.fillStyle = '#2e86c1';
        else if (type === 'pluto') ctx.fillStyle = '#d1c4e9'; // Pale purple/grey
        
        ctx.fillRect(0, 0, size, size);
        
        // 2. Procedural Detail
        const imgData = ctx.getImageData(0, 0, size, size);
        const data = imgData.data;
        
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const nx = x / size * 10;
                const ny = y / size * 10;
                const idx = (y * size + x) * 4;
                
                let n = 0;
                
                if (type === 'earth') {
                    n = this.noise2D(nx, ny) * 1.0 + this.noise2D(nx * 2, ny * 2) * 0.5;
                    n = n / 1.75; 
                    if (n > 0.55) { 
                        const landVar = (n - 0.55) * 3.0; 
                        data[idx] = 34 + landVar * 100;   
                        data[idx+1] = 139 + landVar * 50; 
                        data[idx+2] = 34 + landVar * 20;  
                    } else if (n > 0.5) { 
                        data[idx] = 0; data[idx+1] = 100; data[idx+2] = 200;
                    } 
                } else if (type === 'mars') {
                    n = this.noise2D(nx * 2, ny * 2);
                    data[idx] = 180 + n * 75; data[idx+1] = 50 + n * 50; data[idx+2] = 20;
                } else if (type === 'jupiter' || type === 'saturn') {
                    const distortion = this.noise2D(nx, ny) * 2.0;
                    const band = Math.sin((ny + distortion) * 3.0);
                    const baseR = (type === 'jupiter') ? 200 : 240;
                    const baseG = (type === 'jupiter') ? 150 : 200;
                    const baseB = (type === 'jupiter') ? 100 : 100;
                    data[idx] = baseR + band * 55;
                    data[idx+1] = baseG + band * 40;
                    data[idx+2] = baseB + band * 30;
                } else if (type === 'moon' || type === 'mercury' || type === 'pluto') {
                    n = this.noise2D(nx * 5, ny * 5);
                    const val = (type === 'pluto' ? 150 : 50) + n * 100;
                    data[idx] = val; data[idx+1] = val; data[idx+2] = val;
                    if (type === 'pluto') data[idx+2] += 20; // Slight blue tint
                } else if (type === 'sun') {
                    n = this.noise2D(nx * 3, ny * 3) + this.noise2D(nx * 10, ny * 10) * 0.5;
                    data[idx] = 255; data[idx+1] = 100 + n * 155; data[idx+2] = n * 50;
                } else if (type === 'venus') {
                    n = this.noise2D(nx * 2, ny * 2);
                    data[idx] = 230 + n * 25; data[idx+1] = 194 + n * 25; data[idx+2] = 41 + n * 25;
                } else if (type === 'uranus') {
                    data[idx] = 115; data[idx+1] = 198; data[idx+2] = 182;
                } else if (type === 'neptune') {
                    n = this.noise2D(nx * 2, ny * 2);
                    data[idx] = 46 + n * 20; data[idx+1] = 134 + n * 20; data[idx+2] = 193 + n * 50;
                }
            }
        }
        ctx.putImageData(imgData, 0, 0);
        
        if (type === 'earth') {
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for(let i=0; i<20; i++) {
                const cx = Math.random() * size;
                const cy = Math.random() * size;
                const rx = 50 + Math.random() * 150;
                const ry = 20 + Math.random() * 50;
                ctx.beginPath();
                ctx.ellipse(cx, cy, rx, ry, Math.random(), 0, Math.PI*2);
                ctx.fill();
            }
        }

        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    },

    createGrid: function(size = 1024, color = '#00f3ff', bg = '#101025') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size);
        grad.addColorStop(0, '#2a2a4e'); 
        grad.addColorStop(1, '#050510'); 
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, size, size);

        this.createNoise(ctx, size, size, 0.08);

        const divisions = 8;
        const step = size / divisions;

        ctx.lineWidth = 8; 
        ctx.shadowBlur = 25;
        ctx.shadowColor = color;
        ctx.strokeStyle = color;

        ctx.beginPath();
        for(let i=0; i<=size; i+=step) {
            ctx.moveTo(i, 0); ctx.lineTo(i, size);
            ctx.moveTo(0, i); ctx.lineTo(size, i);
        }
        ctx.stroke();

        ctx.lineWidth = 2;
        ctx.shadowBlur = 5;
        ctx.strokeStyle = 'rgba(0, 243, 255, 0.3)'; 
        const subStep = step / 4;
        ctx.beginPath();
        for(let i=0; i<=size; i+=subStep) {
            if(i % step === 0) continue;
            ctx.moveTo(i, 0); ctx.lineTo(i, size);
            ctx.moveTo(0, i); ctx.lineTo(size, i);
        }
        ctx.stroke();

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = 16;
        return tex;
    },

    createBuildingTex: function(size = 512, baseColor = '#444') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#555555'; 
        ctx.fillRect(0,0,size,size);
        
        this.createNoise(ctx, size, size, 0.15);
        
        ctx.globalCompositeOperation = 'multiply';
        const grad = ctx.createLinearGradient(0, 0, 0, size);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, '#aaaaaa');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,size,size);
        ctx.globalCompositeOperation = 'source-over';

        const cols = 4;
        const rows = 8;
        const padX = 20;
        const padY = 15;
        const w = (size / cols) - padX;
        const h = (size / rows) - padY;

        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                const isLit = Math.random() > 0.5; 
                if(isLit) {
                    const hue = Math.random() > 0.5 ? 320 : 190; 
                    ctx.fillStyle = `hsla(${hue}, 100%, 75%, 0.95)`;
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = ctx.fillStyle;
                } else {
                    ctx.fillStyle = '#111122';
                    ctx.shadowBlur = 0;
                }
                
                const x = c * (size/cols) + padX/2;
                const y = r * (size/rows) + padY/2;
                ctx.fillRect(x, y, w, h);
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, w, h);
            }
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    createHazard: function(size = 512, color1 = '#333', color2 = '#ffcc00') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#333333';
        ctx.fillRect(0, 0, size, size);
        this.createNoise(ctx, size, size, 0.1);

        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        const r = 32;
        const w = Math.sqrt(3) * r;
        const h = 2 * r;
        
        for (let y = -h; y < size + h; y += h * 0.75) {
            for (let x = -w; x < size + w; x += w) {
                const cx = x + ((Math.floor(y / (h * 0.75)) % 2) * w / 2);
                const cy = y;
                
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    ctx.lineTo(cx + r * Math.cos(i * Math.PI / 3), cy + r * Math.sin(i * Math.PI / 3));
                }
                ctx.closePath();
                ctx.stroke();
                
                if (Math.random() > 0.90) { 
                    ctx.fillStyle = '#ffaa00';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffaa00';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        ctx.globalAlpha = 0.7;
        ctx.fillStyle = color2;
        const stripeWidth = 128;
        ctx.beginPath();
        for (let i = -size; i < size * 2; i += stripeWidth * 2) {
            ctx.moveTo(i, 0);
            ctx.lineTo(i + stripeWidth, 0);
            ctx.lineTo(i + stripeWidth - size, size);
            ctx.lineTo(i - size, size);
        }
        ctx.fill();
        ctx.globalAlpha = 1.0;
        
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 15;
        ctx.strokeRect(0,0,size,size);

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    createCarbonFiber: function(size = 512) {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#111111';
        ctx.fillRect(0, 0, size, size);

        const tile = size / 16; 
        
        for(let y=0; y<16; y++) {
            for(let x=0; x<16; x++) {
                const isVertical = (x+y)%2 === 0;
                const gx = x*tile;
                const gy = y*tile;
                
                const grad = isVertical 
                    ? ctx.createLinearGradient(gx, gy, gx+tile, gy)
                    : ctx.createLinearGradient(gx, gy, gx, gy+tile);
                
                grad.addColorStop(0, '#222');
                grad.addColorStop(0.5, '#444');
                grad.addColorStop(1, '#222');
                
                ctx.fillStyle = grad;
                ctx.fillRect(gx, gy, tile, tile);
            }
        }
        
        this.createNoise(ctx, size, size, 0.03);

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(2, 2);
        return tex;
    },

    createAd: function(size = 512, text = "FLUX") {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size / 2;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0,0,size,size/2);
        
        ctx.strokeStyle = '#ff0055';
        ctx.lineWidth = 10;
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#ff0055';
        ctx.strokeRect(10, 10, size-20, (size/2)-20);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '900 80px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ffffff';
        ctx.fillText(text, size/2, size/4);
        
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        for(let i=0; i<size/2; i+=6) {
            ctx.fillRect(0, i, size, 3);
        }

        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    },

    createNeonSign: function(size = 256, color = '#0f0', text = "BAR") {
        const canvas = document.createElement('canvas');
        canvas.width = size / 2;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#111';
        ctx.fillRect(0,0,size/2, size);
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center';
        
        const chars = text.split('');
        const startY = (size - (chars.length * 60)) / 2 + 40;
        
        for(let i=0; i<chars.length; i++) {
            ctx.fillText(chars[i], size/4, startY + (i * 60));
        }
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 6;
        ctx.strokeRect(5, 5, (size/2)-10, size-10);
        
        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    },
    
    createMatCap: function(size = 256, color = '#ffffff', rimColor = '#000000') {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const cx = size / 2;
        const cy = size / 2;
        const r = size / 2;
        
        ctx.fillStyle = rimColor;
        ctx.fillRect(0, 0, size, size);
        
        const grad = ctx.createRadialGradient(cx - r*0.2, cy - r*0.2, r*0.1, cx, cy, r);
        grad.addColorStop(0, '#ffffff'); 
        grad.addColorStop(0.4, color);   
        grad.addColorStop(0.9, rimColor); 
        grad.addColorStop(1, rimColor);
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, r - 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalCompositeOperation = 'source-atop';
        const highlightGrad = ctx.createLinearGradient(0, 0, size, size);
        highlightGrad.addColorStop(0, 'rgba(255,255,255,0.8)');
        highlightGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
        ctx.fillStyle = highlightGrad;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();

        const tex = new THREE.CanvasTexture(canvas);
        return tex;
    },
    
    addNoise: function(ctx, size, alpha) {
        this.createNoise(ctx, size, size, alpha);
    }
};</script>
    <script>/**
 * VFX SYSTEM - HERCULEAN VISUALS
 * Handles Ribbon Trails, Procedural Meshes, and Complex Effects.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes in update loops.
 * OPTIMIZED: Implemented Object Pooling for Explosions, Flashes, Ghosts, and Trails.
 * OPTIMIZED: Replaced splice with Swap-and-Pop in ObjectPool.release.
 * PERF FIX: Optimized RibbonTrail update loop.
 */

// Static reusable vectors
const _vfxVec1 = new THREE.Vector3();
const _vfxVec2 = new THREE.Vector3();
const _vfxVec3 = new THREE.Vector3();
const _vfxDir = new THREE.Vector3();
const _vfxPerp = new THREE.Vector3();
const _vfxQuat = new THREE.Quaternion();
const _vfxScale = new THREE.Vector3();

/**
 * GENERIC OBJECT POOL
 * Manages reuse of objects to prevent GC.
 */
class ObjectPool {
    constructor(createFn, initialSize = 10) {
        this.pool = [];
        this.active = [];
        this.createFn = createFn;
        for(let i=0; i<initialSize; i++) {
            this.pool.push(this.createFn());
        }
    }
    
    get() {
        let obj = this.pool.pop();
        if (!obj) obj = this.createFn();
        this.active.push(obj);
        return obj;
    }
    
    release(obj) {
        const idx = this.active.indexOf(obj);
        if (idx > -1) {
            // Swap-and-Pop Optimization (O(1))
            const last = this.active[this.active.length - 1];
            this.active[idx] = last;
            this.active.pop();
        }
        this.pool.push(obj);
    }
    
    update(dt) {
        for(let i = this.active.length - 1; i >= 0; i--) {
            const obj = this.active[i];
            if (obj.update) {
                const alive = obj.update(dt);
                if (!alive) {
                    if (obj.mesh) obj.mesh.visible = false;
                    this.release(obj);
                    // Note: release() modifies this.active.
                    // Since we iterate backwards, swapping the last element into current position 'i'
                    // is safe because 'i' will decrement and we won't process the swapped element again this frame.
                    // However, release() does indexOf which is O(N).
                    // To be truly O(1), release needs the index, but we keep the API clean.
                    // The swap-and-pop inside release is still faster than splice for large arrays.
                }
            }
        }
    }
}

/**
 * GHOST POOL
 * Specialized pool for Player Ghosts (Afterimages).
 * Avoids cloning the entire player hierarchy every frame.
 */
class GhostPool {
    constructor(scene, initialSize = 5) {
        this.scene = scene;
        this.pool = [];
        this.active = [];
        this.material = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.4,
            wireframe: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
    }

    get(sourceRoot) {
        let ghost = this.pool.pop();
        
        if (!ghost) {
            // Lazy creation: Clone the source structure once
            ghost = sourceRoot.clone();
            
            // Replace materials with shared ghost material
            ghost.traverse((child) => {
                if (child.isMesh) {
                    child.material = this.material;
                }
            });
            
            this.scene.add(ghost);
        }
        
        ghost.visible = true;
        this.active.push(ghost);
        return ghost;
    }

    release(ghost) {
        ghost.visible = false;
        const idx = this.active.indexOf(ghost);
        if (idx > -1) {
            const last = this.active[this.active.length - 1];
            this.active[idx] = last;
            this.active.pop();
        }
        this.pool.push(ghost);
    }

    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const ghost = this.active[i];
            ghost.userData.life -= dt;
            
            if (ghost.userData.life <= 0) {
                this.release(ghost);
            } else {
                // Fade out
                const s = 1.0 - (0.2 - ghost.userData.life) * 0.5; // Shrink slightly
            }
        }
    }

    // Helper to sync transforms without cloning
    copyTransforms(source, target) {
        target.position.copy(source.position);
        target.quaternion.copy(source.quaternion);
        target.scale.copy(source.scale);
        
        const sourceChildren = source.children;
        const targetChildren = target.children;
        
        for (let i = 0; i < sourceChildren.length; i++) {
            if (targetChildren[i]) {
                this.copyTransforms(sourceChildren[i], targetChildren[i]);
            }
        }
    }
}

/**
 * TRAIL MESH POOL
 * Reuses generic boxes for bullet trails/slashes.
 * Replaces `new BoxGeometry` every frame.
 */
class TrailMeshPool {
    constructor(scene, initialSize = 20) {
        this.scene = scene;
        this.pool = [];
        this.active = [];
        
        // Shared Geometry and Material
        this.geometry = new THREE.BoxGeometry(1, 1, 1);
        this.geometry.translate(0, 0, 0.5); // Pivot at end for scaling length
        
        this.material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        for(let i=0; i<initialSize; i++) {
            const mesh = new THREE.Mesh(this.geometry, this.material.clone()); // Clone mat for individual opacity/color
            mesh.visible = false;
            scene.add(mesh);
            this.pool.push(mesh);
        }
    }

    spawn(start, end, width, color, life) {
        let mesh = this.pool.pop();
        if (!mesh) {
            mesh = new THREE.Mesh(this.geometry, this.material.clone());
            this.scene.add(mesh);
        }
        
        mesh.visible = true;
        mesh.position.copy(start);
        mesh.lookAt(end);
        
        const len = start.distanceTo(end);
        mesh.scale.set(width, width, len);
        
        mesh.material.color.setHex(color);
        mesh.material.opacity = 0.8;
        
        mesh.userData.life = life;
        mesh.userData.maxLife = life;
        
        this.active.push(mesh);
    }

    update(dt) {
        for (let i = this.active.length - 1; i >= 0; i--) {
            const mesh = this.active[i];
            mesh.userData.life -= dt;
            
            if (mesh.userData.life <= 0) {
                mesh.visible = false;
                // Swap-and-Pop
                const last = this.active[this.active.length - 1];
                this.active[i] = last;
                this.active.pop();
                
                this.pool.push(mesh);
            } else {
                mesh.material.opacity = (mesh.userData.life / mesh.userData.maxLife) * 0.8;
                mesh.scale.x *= 0.9; // Narrowing
                mesh.scale.y *= 0.9;
            }
        }
    }
}

class RibbonTrail {
    constructor(scene, maxPoints = 50, width = 0.5, color = 0x00ffff) {
        this.maxPoints = maxPoints;
        this.width = width;
        this.maxAge = 0.5; // Seconds before a point disappears
        
        // Ring Buffer for points (x, y, z flattened)
        this.points = new Float32Array(maxPoints * 3);
        this.birthTimes = new Float32Array(maxPoints); // Track when points were created
        
        this.head = 0; // Index of the latest point
        this.count = 0; // Number of active points
        this.initialized = false; // Flag to track if we have a start pos
        
        // Geometry
        this.geometry = new THREE.BufferGeometry();
        
        // 2 vertices per point (triangle strip)
        // Position buffer size: maxPoints * 2 vertices * 3 coordinates
        // OPTIMIZATION: Allocate once
        const positions = new Float32Array(maxPoints * 2 * 3);
        this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // UVs
        // OPTIMIZATION: Allocate once
        const uvs = new Float32Array(maxPoints * 2 * 2);
        this.geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        
        // INDICES for Triangle Strip simulation
        const indices = [];
        for (let i = 0; i < maxPoints - 1; i++) {
            const v = i * 2;
            // Triangle 1
            indices.push(v, v + 1, v + 2);
            // Triangle 2
            indices.push(v + 2, v + 1, v + 3);
        }
        this.geometry.setIndex(indices);
        
        // Material (Additive Gradient)
        this.material = new THREE.MeshBasicMaterial({
            color: color,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.frustumCulled = false; // Always render
        scene.add(this.mesh);
    }
    
    update(targetPos, dt) {
        const now = performance.now() / 1000;

        // INITIALIZATION FIX: Fill buffer with start pos to prevent line from (0,0,0)
        if (!this.initialized) {
            for (let i = 0; i < this.maxPoints; i++) {
                this.points[i * 3] = targetPos.x;
                this.points[i * 3 + 1] = targetPos.y;
                this.points[i * 3 + 2] = targetPos.z;
                this.birthTimes[i] = now;
            }
            this.initialized = true;
            this.count = 1; // Start with 1 valid point
            return;
        }

        // 1. Add new point if moved enough
        let added = false;
        if (this.count > 0) {
            const hx = this.points[this.head * 3];
            const hy = this.points[this.head * 3 + 1];
            const hz = this.points[this.head * 3 + 2];
            const dx = targetPos.x - hx;
            const dy = targetPos.y - hy;
            const dz = targetPos.z - hz;
            
            // Minimum distance threshold to add a new segment
            if (dx*dx + dy*dy + dz*dz > 0.05) {
                // Decrement head (wrap around) to add new point at the "front"
                this.head = (this.head - 1 + this.maxPoints) % this.maxPoints;
                
                // Write new point
                this.points[this.head * 3] = targetPos.x;
                this.points[this.head * 3 + 1] = targetPos.y;
                this.points[this.head * 3 + 2] = targetPos.z;
                this.birthTimes[this.head] = now;
                
                if (this.count < this.maxPoints) this.count++;
                added = true;
            } else {
                // Update head position even if not adding new segment (keeps trail attached to player)
                this.points[this.head * 3] = targetPos.x;
                this.points[this.head * 3 + 1] = targetPos.y;
                this.points[this.head * 3 + 2] = targetPos.z;
                this.birthTimes[this.head] = now; // Refresh head time
            }
        }
        
        // 2. Prune old points (Retraction)
        // The tail is at (head + count - 1) % maxPoints
        while (this.count > 1) { // Always keep at least 1 point (the head)
            const tailIdx = (this.head + this.count - 1) % this.maxPoints;
            const age = now - this.birthTimes[tailIdx];
            
            if (age > this.maxAge) {
                this.count--;
            } else {
                break; // Tail is young enough, stop pruning
            }
        }
        
        this.updateGeometry();
    }
    
    updateGeometry() {
        // OPTIMIZATION: Access existing arrays directly
        const posArr = this.geometry.attributes.position.array;
        const uvArr = this.geometry.attributes.uv.array;
        
        // Iterate through valid points in the ring buffer
        // We need at least 2 points to draw a segment
        if (this.count < 2) {
            this.geometry.setDrawRange(0, 0);
            return;
        }

        // Reuse static vectors
        _vfxVec3.set(0, 1, 0); // Up vector

        for (let i = 0; i < this.count - 1; i++) {
            const idx1 = (this.head + i) % this.maxPoints;
            const idx2 = (this.head + i + 1) % this.maxPoints;
            
            // Read p1
            _vfxVec1.set(
                this.points[idx1 * 3],
                this.points[idx1 * 3 + 1],
                this.points[idx1 * 3 + 2]
            );
            
            // Read p2
            _vfxVec2.set(
                this.points[idx2 * 3],
                this.points[idx2 * 3 + 1],
                this.points[idx2 * 3 + 2]
            );
            
            // Calculate direction
            _vfxDir.subVectors(_vfxVec2, _vfxVec1).normalize();
            
            // Calculate perpendicular (Ribbon width)
            _vfxPerp.crossVectors(_vfxDir, _vfxVec3).normalize().multiplyScalar(this.width / 2);
            
            // Vertex 1 (Left)
            const v1 = i * 6; // i * 2 vertices * 3 coords
            posArr[v1] = _vfxVec1.x - _vfxPerp.x;
            posArr[v1 + 1] = _vfxVec1.y - _vfxPerp.y;
            posArr[v1 + 2] = _vfxVec1.z - _vfxPerp.z;

            // Vertex 2 (Right)
            const v2 = v1 + 3;
            posArr[v2] = _vfxVec1.x + _vfxPerp.x;
            posArr[v2 + 1] = _vfxVec1.y + _vfxPerp.y;
            posArr[v2 + 2] = _vfxVec1.z + _vfxPerp.z;
            
            // UVs (Fade out along length)
            const uvX = i / (this.count - 1);
            const u1 = i * 4; // i * 2 vertices * 2 coords
            uvArr[u1] = uvX;
            uvArr[u1 + 1] = 0;
            
            const u2 = u1 + 2;
            uvArr[u2] = uvX;
            uvArr[u2 + 1] = 1;
        }
        
        // Handle the very last segment to prevent artifacts
        // Just copy the previous vertices for the last point to close the strip
        const lastI = this.count - 1;
        const lastV = lastI * 6;
        // We don't strictly need to set positions for the last point if we set draw range correctly
        // But for safety, copy previous
        const prevV = (lastI - 1) * 6;
        if (prevV >= 0) {
             posArr[lastV] = posArr[prevV+3]; // Connect to previous right
             posArr[lastV+1] = posArr[prevV+4];
             posArr[lastV+2] = posArr[prevV+5];
             posArr[lastV+3] = posArr[prevV+3];
             posArr[lastV+4] = posArr[prevV+4];
             posArr[lastV+5] = posArr[prevV+5];
        }

        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.uv.needsUpdate = true;
        
        // Update draw range
        // (count - 1) segments * 6 indices per segment (2 triangles)
        this.geometry.setDrawRange(0, Math.max(0, (this.count - 1) * 6));
    }
}

/**
 * THRUSTER PLUME
 * Volumetric-looking cone with noise shader for engine exhaust.
 */
class ThrusterPlume {
    constructor(parent, color = 0x00ffff) {
        const geometry = new THREE.CylinderGeometry(0.05, 0.4, 1.5, 8, 4, true);
        geometry.translate(0, -0.75, 0); // Pivot at top
        
        // Custom Shader for Volumetric Noise Look
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(color) },
                uOpacity: { value: 0.8 },
                uScale: { value: 1.0 }
            },
            vertexShader: `
                #include <common>
                #include <logdepthbuf_pars_vertex>

                varying vec2 vUv;
                uniform float uTime;
                uniform float uScale;
                
                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    
                    // Jitter/Noise displacement based on time and vertical position
                    float noise = sin(pos.y * 10.0 - uTime * 20.0) * 0.05 * uScale;
                    pos.x += noise * pos.y; // More jitter at bottom
                    pos.z += cos(pos.y * 10.0 - uTime * 15.0) * 0.05 * uScale * pos.y;
                    
                    // Stretch based on scale
                    pos.y *= uScale;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    
                    #include <logdepthbuf_vertex>
                }
            `,
            fragmentShader: `
                #include <common>
                #include <logdepthbuf_pars_fragment>

                uniform vec3 uColor;
                uniform float uOpacity;
                uniform float uTime;
                varying vec2 vUv;
                
                void main() {
                    #include <logdepthbuf_fragment>

                    // Fade out at bottom
                    float alpha = smoothstep(0.0, 0.2, vUv.y) * (1.0 - vUv.y);
                    
                    // Core glow
                    float core = 1.0 - abs(vUv.x - 0.5) * 2.0;
                    core = pow(core, 4.0);
                    
                    // Pulse
                    float pulse = 0.8 + 0.2 * sin(uTime * 30.0 - vUv.y * 10.0);
                    
                    vec3 finalColor = uColor * (core + 0.5) * pulse;
                    
                    // Direct multiplication by uOpacity allows full invisibility when 0
                    gl_FragColor = vec4(finalColor, alpha * uOpacity);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.rotation.x = Math.PI; // Point down
        parent.add(this.mesh);
    }
    
    update(dt, intensity = 1.0) {
        if (intensity <= 0.01) {
            this.mesh.visible = false;
            return;
        }
        this.mesh.visible = true;
        this.mesh.material.uniforms.uTime.value += dt;
        this.mesh.material.uniforms.uScale.value = 1.0 + (intensity * 2.0); 
        this.mesh.material.uniforms.uOpacity.value = intensity; 
    }
    
    setColor(hex) {
        this.mesh.material.uniforms.uColor.value.setHex(hex);
    }
}

class DeathRay {
    constructor(scene) {
        this.mesh = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 1, 8, 1, true),
            new THREE.MeshBasicMaterial({ 
                color: 0xff00ff, 
                transparent: true, 
                opacity: 0, 
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            })
        );
        this.mesh.rotation.x = -Math.PI / 2; // Point Z
        this.mesh.visible = false;
        scene.add(this.mesh);
        
        this.core = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.3, 1, 8, 1, true),
            new THREE.MeshBasicMaterial({ color: 0xffffff, blending: THREE.AdditiveBlending })
        );
        this.core.rotation.x = -Math.PI / 2;
        this.mesh.add(this.core);
        
        this.active = false;
        this.timer = 0;
        this.duration = 0;
        this.startPos = new THREE.Vector3();
        this.endPos = new THREE.Vector3();
        this.maxScale = 1;
    }
    
    fire(start, end, duration = 1.0, width = 2.0) {
        this.active = true;
        this.timer = 0;
        this.duration = duration;
        this.startPos.copy(start);
        this.endPos.copy(end);
        this.maxScale = width;
        
        this.mesh.visible = true;
        this.mesh.position.copy(start);
        this.mesh.lookAt(end);
        
        const dist = start.distanceTo(end);
        this.mesh.scale.set(0, 0, dist); // Z is length
        this.mesh.translateZ(dist / 2); // Center cylinder
    }
    
    update(dt) {
        if (!this.active) return;
        
        this.timer += dt;
        const progress = this.timer / this.duration;
        
        if (progress >= 1) {
            this.active = false;
            this.mesh.visible = false;
            return;
        }
        
        // Expand and contract
        const scale = Math.sin(progress * Math.PI) * this.maxScale;
        const dist = this.startPos.distanceTo(this.endPos);
        
        this.mesh.scale.set(scale, scale, dist);
        this.mesh.material.opacity = Math.sin(progress * Math.PI);
        
        // Jitter
        this.mesh.rotation.z += dt * 10;
    }
}

class SlashEffect {
    constructor(scene) {
        const geo = new THREE.PlaneGeometry(10, 10);
        const mat = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.visible = false;
        scene.add(this.mesh);
        this.active = false;
        this.life = 0;
    }
    
    spawn(pos, quat, scale) {
        this.active = true;
        this.life = 0.3;
        this.mesh.position.copy(pos);
        this.mesh.quaternion.copy(quat);
        this.mesh.scale.set(scale, 0.1, 1); // Start thin
        this.mesh.visible = true;
        this.mesh.material.opacity = 1.0;
    }
    
    update(dt) {
        if (!this.active) return;
        this.life -= dt;
        if (this.life <= 0) {
            this.active = false;
            this.mesh.visible = false;
            return;
        }
        // Expand width
        this.mesh.scale.y += dt * 20.0;
        this.mesh.material.opacity = this.life / 0.3;
    }
}

class JudgmentBeam {
    constructor(scene) {
        const geo = new THREE.CylinderGeometry(0.5, 0.5, 100, 8);
        geo.translate(0, 50, 0); // Pivot at bottom
        const mat = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.visible = false;
        scene.add(this.mesh);
        this.active = false;
        this.life = 0;
    }
    
    spawn(pos) {
        this.active = true;
        this.life = 0.5;
        this.mesh.position.copy(pos);
        this.mesh.visible = true;
        this.mesh.scale.set(0.1, 1, 0.1);
    }
    
    update(dt) {
        if (!this.active) return;
        this.life -= dt;
        if (this.life <= 0) {
            this.active = false;
            this.mesh.visible = false;
            return;
        }
        const scale = Math.sin((this.life / 0.5) * Math.PI) * 2.0;
        this.mesh.scale.set(scale, 1, scale);
        this.mesh.material.opacity = Math.min(1.0, this.life * 3.0);
    }
}

/**
 * TRACER SYSTEM
 * Simple pooled projectiles for visual feedback (Space Vulcan).
 */
class TracerSystem {
    constructor(scene, count = 50) {
        this.pool = [];
        this.scene = scene;
        
        const geo = new THREE.BoxGeometry(0.5, 0.5, 15.0);
        geo.translate(0, 0, 7.5); // Pivot at back
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0.9, 
            blending: THREE.AdditiveBlending,
            depthWrite: false 
        });
        
        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.visible = false;
            scene.add(mesh);
            this.pool.push({ mesh, life: 0, velocity: new THREE.Vector3() });
        }
    }
    
    spawn(pos, dir, speed = 400) {
        const tracer = this.pool.find(t => !t.mesh.visible);
        if (tracer) {
            tracer.mesh.visible = true;
            tracer.mesh.position.copy(pos);
            tracer.mesh.lookAt(pos.clone().add(dir));
            tracer.velocity.copy(dir).multiplyScalar(speed);
            tracer.life = 1.0; // 1 second max life
        }
    }
    
    update(dt) {
        for(const t of this.pool) {
            if (t.mesh.visible) {
                t.life -= dt;
                t.mesh.position.add(t.velocity.clone().multiplyScalar(dt));
                if (t.life <= 0) {
                    t.mesh.visible = false;
                }
            }
        }
    }
}

/**
 * SPEED LINES SYSTEM
 * Creates "warp speed" streaks when moving fast in space.
 */
class SpeedLineSystem {
    constructor(scene, count = 200) {
        this.count = count;
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3 * 2); // 2 verts per line
        const colors = new Float32Array(count * 3 * 2);
        
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const mat = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        this.mesh = new THREE.LineSegments(geo, mat);
        this.mesh.frustumCulled = false;
        scene.add(this.mesh);
        
        this.lines = [];
        for(let i=0; i<count; i++) {
            this.lines.push({
                pos: new THREE.Vector3(
                    (Math.random()-0.5)*100,
                    (Math.random()-0.5)*100,
                    (Math.random()-0.5)*100
                ),
                len: 5 + Math.random() * 10
            });
        }
    }
    
    update(dt, playerPos, velocity) {
        const speed = velocity.length();
        const dir = velocity.clone().normalize();
        if (speed < 10) {
            this.mesh.visible = false;
            return;
        }
        this.mesh.visible = true;
        
        const positions = this.mesh.geometry.attributes.position.array;
        const colors = this.mesh.geometry.attributes.color.array;
        
        // Opacity based on speed
        const opacity = Math.min(1.0, (speed - 10) / 100);
        this.mesh.material.opacity = opacity * 0.5;
        
        const range = 50;
        
        for(let i=0; i<this.count; i++) {
            const line = this.lines[i];
            
            // Move opposite to player
            line.pos.sub(velocity.clone().multiplyScalar(dt));
            
            // Wrap around player
            if (line.pos.x < playerPos.x - range) line.pos.x += range*2;
            if (line.pos.x > playerPos.x + range) line.pos.x -= range*2;
            
            if (line.pos.y < playerPos.y - range) line.pos.y += range*2;
            if (line.pos.y > playerPos.y + range) line.pos.y -= range*2;
            
            if (line.pos.z < playerPos.z - range) line.pos.z += range*2;
            if (line.pos.z > playerPos.z + range) line.pos.z -= range*2;
            
            // Update Vertices
            const idx = i * 6;
            
            // Head
            positions[idx] = line.pos.x;
            positions[idx+1] = line.pos.y;
            positions[idx+2] = line.pos.z;
            
            // Tail (Stretch based on speed)
            const stretch = Math.min(20, speed * 0.1);
            const tail = line.pos.clone().sub(dir.clone().multiplyScalar(line.len * stretch));
            
            positions[idx+3] = tail.x;
            positions[idx+4] = tail.y;
            positions[idx+5] = tail.z;
            
            // Colors (White head, fade tail)
            colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1;
            colors[idx+3] = 0; colors[idx+4] = 0.5; colors[idx+5] = 1; // Blueish tail
        }
        
        this.mesh.geometry.attributes.position.needsUpdate = true;
        this.mesh.geometry.attributes.color.needsUpdate = true;
    }
}

/**
 * SPACE EXPLOSION
 * Expanding sphere mesh + particles for zero-g explosions.
 */
class SpaceExplosion {
    constructor(scene) {
        this.scene = scene;
        this.active = false;
        this.life = 0;
        
        // Core Sphere
        const geo = new THREE.SphereGeometry(1, 32, 32);
        const mat = new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.visible = false;
        scene.add(this.mesh);
        
        // Shockwave Ring
        const ringGeo = new THREE.RingGeometry(0.8, 1.0, 32);
        const ringMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        this.ring = new THREE.Mesh(ringGeo, ringMat);
        this.mesh.add(this.ring);
    }
    
    spawn(pos, scale = 1.0) {
        this.active = true;
        this.life = 0.5;
        this.mesh.position.copy(pos);
        this.mesh.scale.set(0.1, 0.1, 0.1);
        this.mesh.visible = true;
        this.targetScale = scale * 10.0;
        
        // Random rotation for ring
        this.ring.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
        
        // Spawn Particles (if global helper exists)
        if (window.flux && window.flux.spawnParticles) {
            window.flux.spawnParticles(pos, 20, 0xffaa00, 20);
        }
    }
    
    update(dt) {
        if (!this.active) return false;
        
        this.life -= dt;
        if (this.life <= 0) {
            this.active = false;
            this.mesh.visible = false;
            return false;
        }
        
        const progress = 1.0 - (this.life / 0.5);
        const curScale = this.targetScale * Math.sin(progress * Math.PI * 0.5); // Ease out
        
        this.mesh.scale.set(curScale, curScale, curScale);
        this.mesh.material.opacity = this.life / 0.5;
        this.ring.material.opacity = this.life / 0.5;
        
        // Expand ring faster
        this.ring.scale.set(1 + progress, 1 + progress, 1);
        
        return true; // Still active
    }
}

/**
 * HIT FLASH
 * Simple planar flash for impacts.
 */
class HitFlash {
    constructor(scene) {
        const flashGeo = new THREE.PlaneGeometry(5, 5);
        const flashMat = new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            transparent: true,
            opacity: 0.8, 
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
        });
        this.mesh = new THREE.Mesh(flashGeo, flashMat); 
        this.mesh.visible = false;
        scene.add(this.mesh);
        this.life = 0;
    }
    
    spawn(pos, lookAtPos) {
        this.mesh.position.copy(pos);
        this.mesh.lookAt(lookAtPos);
        this.mesh.visible = true;
        this.mesh.material.opacity = 0.8;
        this.mesh.scale.set(1, 1, 1);
        this.life = 0.15;
    }
    
    update(dt) {
        if (this.life <= 0) return false;
        this.life -= dt;
        
        const scale = 1.0 + (0.15 - this.life) * 5.0;
        this.mesh.scale.set(scale, scale, scale);
        this.mesh.material.opacity = this.life / 0.15;
        
        if (this.life <= 0) {
            this.mesh.visible = false;
            return false;
        }
        return true;
    }
}

/**
 * DISTORTION WAVE
 * Visual shockwave for heavy impacts.
 */
class DistortionWave {
    constructor(scene) {
        const geo = new THREE.SphereGeometry(1, 32, 32);
        const mat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            wireframe: true
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.visible = false;
        scene.add(this.mesh);
        this.active = false;
        this.life = 0;
    }
    
    spawn(pos) {
        this.active = true;
        this.life = 0.4;
        this.mesh.position.copy(pos);
        this.mesh.scale.set(0.1, 0.1, 0.1);
        this.mesh.visible = true;
        this.mesh.material.opacity = 0.5;
    }
    
    update(dt) {
        if (!this.active) return false;
        this.life -= dt;
        
        if (this.life <= 0) {
            this.active = false;
            this.mesh.visible = false;
            return false;
        }
        
        const progress = 1.0 - (this.life / 0.4);
        const scale = 1.0 + progress * 15.0;
        this.mesh.scale.set(scale, scale, scale);
        this.mesh.material.opacity = this.life * 1.5;
        
        return true;
    }
}</script> 
    <script>/**
 * HOMING LASER SYSTEM - OPTIMIZED
 * Uses InstancedMesh and Quadratic Bezier curves for "Swarm" missiles.
 * UPDATED: Implemented 'free list' stack for O(1) spawn complexity.
 * UPDATED: Improved Visuals (Capsule geometry, Smoke Trail).
 * FIXED: Replaced CapsuleGeometry with CylinderGeometry for r128 compatibility.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _lPos = new THREE.Vector3();
const _lTan = new THREE.Vector3();
const _lVec = new THREE.Vector3();

class HomingLaserSystem {
    constructor(scene, maxLasers = 100) {
        this.maxLasers = maxLasers;
        this.lasers = []; // Active laser data: { t: 0..1, p0, p1, p2, speed, active, target }
        
        // Free List Stack (Indices of inactive lasers)
        this.freeList = [];
        
        // Geometry: Cylinder approximating a capsule (r128 compat)
        const geo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
        geo.translate(0, 0.4, 0); // Pivot at tail
        geo.rotateX(Math.PI/2); // Point forward
        
        // Material: Glowing Green/Blue with Rim
        const mat = new THREE.MeshBasicMaterial({
            color: 0x00ffaa,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });
        
        this.mesh = new THREE.InstancedMesh(geo, mat, maxLasers);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(this.mesh);
        
        this.dummy = new THREE.Object3D();
        
        // Pre-fill pool and free list
        for(let i=0; i<maxLasers; i++) {
            this.lasers.push({ active: false, t: 0, p0: new THREE.Vector3(), p1: new THREE.Vector3(), p2: new THREE.Vector3(), speed: 1, target: null });
            this.freeList.push(i); // All lasers start free
            
            this.dummy.position.set(0, -500, 0);
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
        }
    }
    
    spawn(startPos, endPos, targetEnemy = null) {
        // O(1) Retrieval
        if (this.freeList.length === 0) return;
        const idx = this.freeList.pop();
        
        const laser = this.lasers[idx];
        laser.active = true;
        laser.t = 0;
        laser.p0.copy(startPos);
        laser.p2.copy(endPos);
        laser.target = targetEnemy; // Store target for damage application
        
        // Calculate Control Point (P1) for the Curve
        // Project outward from start, then add random offset
        // This creates the "Flare out" effect before homing in
        const dist = startPos.distanceTo(endPos);
        const mid = new THREE.Vector3().lerpVectors(startPos, endPos, 0.5);
        
        // Random flare direction
        const flare = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() + 0.5) * 1, // Bias upwards
            (Math.random() - 0.5) * 2
        ).normalize().multiplyScalar(dist * 0.8); // Flare magnitude
        
        laser.p1.copy(mid).add(flare);
        
        laser.speed = 1.5 + Math.random(); // Variation in speed
        
        // Flare effect on spawn
        if (window.flux && window.flux.spawnParticles) {
             window.flux.spawnParticles(startPos, 5, 0xffffff, 5);
        }
    }
    
    update(dt) {
        let activeCount = 0;
        
        for (let i = 0; i < this.maxLasers; i++) {
            const laser = this.lasers[i];
            
            // Skip inactive lasers
            if (!laser.active) {
                // Ensure it's hidden (redundant but safe)
                this.dummy.position.set(0, -500, 0);
                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(i, this.dummy.matrix);
                continue;
            }
            
            activeCount++;
            laser.t += dt * laser.speed;
            
            // Update target position if it's moving
            if (laser.target && !laser.target.userData.isDead) {
                laser.p2.copy(laser.target.position);
            }
            
            if (laser.t >= 1.0) {
                // Hit!
                laser.active = false;
                this.freeList.push(i); // Return to pool
                
                if (window.flux && window.flux.spawnHitParticles) {
                    window.flux.spawnHitParticles(laser.p2, new THREE.Vector3(0, 1, 0));
                }
                
                // APPLY DAMAGE
                if (laser.target && !laser.target.userData.isDead) {
                    // Check for Hunter Shield
                    if (laser.target.userData.controller && 
                        typeof laser.target.userData.controller.shouldBlock === 'function') {
                        
                        // Calculate attack direction (missile velocity vector at impact)
                        // Approximate using P1 -> P2 vector
                        const attackDir = new THREE.Vector3().subVectors(laser.p2, laser.p1).normalize();
                        // Note: shouldBlock expects origin of attack, so we project backwards
                        const attackOrigin = laser.p2.clone().sub(attackDir);
                        
                        if (laser.target.userData.controller.shouldBlock(attackOrigin)) {
                            if (window.flux.spawnBlockParticles) window.flux.spawnBlockParticles(laser.p2);
                            if (window.flux.audio) window.flux.audio.play('block');
                            if (window.flux.showDamage) window.flux.showDamage(laser.p2, "BLOCKED", false);
                            continue; // Skip damage
                        }
                    }

                    const dmg = 30;
                    laser.target.userData.hp -= dmg;
                    
                    // Apply Knockback / "Fall Damage" simulation
                    if (laser.target.userData.velocity) {
                        laser.target.userData.velocity.y -= 20; // Push down hard
                        laser.target.userData.onGround = false;
                    }
                    
                    if (window.flux && window.flux.showDamage) {
                        window.flux.showDamage(laser.p2, dmg, false);
                    }
                    
                    if (laser.target.userData.hp <= 0) {
                        if (window.flux && window.flux.killEnemy) {
                            window.flux.killEnemy(laser.target);
                        }
                    } else {
                        // Flash effect
                        if (laser.target.traverse) {
                            laser.target.traverse((child) => {
                                if (child.isMesh && child.material && child.material.emissive) {
                                    child.material.emissive.setHex(0xffffff);
                                    setTimeout(() => {
                                        if (child.material) child.material.emissive.setHex(child.userData.origEmissive || 0x000000);
                                    }, 100);
                                }
                            });
                        }
                    }
                }
                
                continue;
            }
            
            // Quadratic Bezier: B(t) = (1-t)^2 P0 + 2(1-t)t P1 + t^2 P2
            const t = laser.t;
            const it = 1 - t;
            
            // Reuse static vector for position calculation
            _lPos.copy(laser.p0).multiplyScalar(it * it)
                .addScaledVector(laser.p1, 2 * it * t)
                .addScaledVector(laser.p2, t * t);
            
            // Calculate tangent for rotation (derivative)
            // B'(t) = 2(1-t)(P1 - P0) + 2t(P2 - P1)
            // Reuse static vector for tangent
            _lTan.copy(laser.p1).sub(laser.p0).multiplyScalar(2 * it)
                .addScaledVector(_lVec.copy(laser.p2).sub(laser.p1), 2 * t)
                .normalize();
                
            this.dummy.position.copy(_lPos);
            this.dummy.lookAt(_lPos.clone().add(_lTan)); // Note: lookAt still needs a new target or clone+add
            this.dummy.scale.set(1, 1, 1 + (laser.speed * 2)); // Stretch based on speed
            
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
            
            // Smoke Trail (Simulated)
            if (Math.random() > 0.5 && window.flux && window.flux.spawnParticles) {
                 window.flux.spawnParticles(_lPos, 1, 0xaaaaaa, 2);
            }
        }
        
        if (activeCount > 0) {
            this.mesh.instanceMatrix.needsUpdate = true;
        }
    }
}</script> 
    <script>/**
 * ASSET FACTORY - HERCULEAN ASSET UPDATE
 * Generates high-fidelity, complex 3D models using procedural composition.
 * Replaces simple primitives with detailed, multi-part meshes.
 * UPDATED: Added 'createLagKnight' and 'createNeuralZealot' per blueprint.
 * UPDATED: Added 'createGravityTrap' and 'createDataCore'.
 * OPTIMIZED: Implemented static caching for Geometries and Materials.
 */
class AssetFactory {
    
    // CACHE SYSTEM
    static cache = {
        geometries: {},
        materials: {},
        textures: {}
    };

    static getGeometry(key, creator) {
        if (!this.cache.geometries[key]) {
            this.cache.geometries[key] = creator();
        }
        return this.cache.geometries[key];
    }

    static getMaterial(key, creator) {
        if (!this.cache.materials[key]) {
            this.cache.materials[key] = creator();
        }
        return this.cache.materials[key];
    }

    // --- NEW: GRAVITY TRAP (Orbital Hazard) ---
    static createGravityTrap() {
        const group = new THREE.Group();
        
        const matCore = this.getMaterial('grav_core', () => new THREE.MeshBasicMaterial({ color: 0x000000 }));
        const matRing = this.getMaterial('grav_ring', () => new THREE.MeshBasicMaterial({ color: 0xaa00ff, wireframe: true }));
        
        const coreGeo = this.getGeometry('grav_core_geo', () => new THREE.SphereGeometry(2, 16, 16));
        const core = new THREE.Mesh(coreGeo, matCore);
        group.add(core);
        
        const ringGeo = this.getGeometry('grav_ring_geo', () => new THREE.TorusGeometry(4, 0.1, 8, 32));
        const ring1 = new THREE.Mesh(ringGeo, matRing);
        group.add(ring1);
        
        const ring2 = new THREE.Mesh(ringGeo, matRing);
        ring2.rotation.x = Math.PI/2;
        group.add(ring2);
        
        group.userData = { dynamicType: 'gravity_trap', radius: 15 };
        return group;
    }

    // --- NEW: CHRONO-SYNC DATA CORE (MacGuffin) ---
    static createDataCore() {
        const group = new THREE.Group();
        
        const matCase = this.getMaterial('core_case', () => new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 }));
        const matGlow = this.getMaterial('core_glow', () => new THREE.MeshBasicMaterial({ color: 0x00ff9d }));
        
        // Main Unit
        const boxGeo = this.getGeometry('core_box', () => new THREE.BoxGeometry(1, 1.5, 1));
        const box = new THREE.Mesh(boxGeo, matCase);
        group.add(box);
        
        // Glowing Center
        const centerGeo = this.getGeometry('core_center', () => new THREE.CylinderGeometry(0.3, 0.3, 1.6, 8));
        const center = new THREE.Mesh(centerGeo, matGlow);
        group.add(center);
        
        group.userData = { dynamicType: 'data_core' };
        return group;
    }

    // --- NEW: LAG KNIGHT (Heavy Shielded Infantry) ---
    static createLagKnight() {
        const group = new THREE.Group();
        
        // Materials
        const matArmor = this.getMaterial('knight_armor', () => new THREE.MeshStandardMaterial({ color: 0x444455, roughness: 0.3, metalness: 0.8 }));
        const matShield = this.getMaterial('knight_shield', () => new THREE.MeshStandardMaterial({ 
            color: 0x00aaff, 
            transparent: true, 
            opacity: 0.6, 
            roughness: 0.1, 
            metalness: 0.9,
            emissive: 0x004488,
            emissiveIntensity: 0.5
        }));
        const matGlow = this.getMaterial('knight_glow', () => new THREE.MeshBasicMaterial({ color: 0xffaa00 }));

        // Body (Bulky)
        const bodyGeo = this.getGeometry('knight_body', () => new THREE.BoxGeometry(1.2, 1.5, 0.8));
        const body = new THREE.Mesh(bodyGeo, matArmor);
        body.position.y = 0.75;
        group.add(body);
        
        // Head
        const headGeo = this.getGeometry('knight_head', () => new THREE.BoxGeometry(0.5, 0.5, 0.5));
        const head = new THREE.Mesh(headGeo, matArmor);
        head.position.y = 1.6;
        group.add(head);
        
        // Eye
        const eyeGeo = this.getGeometry('knight_eye', () => new THREE.BoxGeometry(0.4, 0.1, 0.1));
        const eye = new THREE.Mesh(eyeGeo, matGlow);
        eye.position.set(0, 1.6, 0.26);
        group.add(eye);
        
        // Shield (Large, Frontal)
        const shieldGeo = this.getGeometry('knight_shield_geo', () => new THREE.BoxGeometry(1.5, 2.5, 0.2));
        const shield = new THREE.Mesh(shieldGeo, matShield);
        shield.position.set(0, 1.0, 0.8); // In front
        // Slight curve visual
        shield.rotation.y = 0.1;
        group.add(shield);
        
        // Shield Generator (Backpack)
        const packGeo = this.getGeometry('knight_pack', () => new THREE.BoxGeometry(0.8, 1.0, 0.5));
        const pack = new THREE.Mesh(packGeo, matArmor);
        pack.position.set(0, 1.0, -0.6);
        group.add(pack);
        
        // Hover Skirt
        const skirtGeo = this.getGeometry('knight_skirt', () => new THREE.CylinderGeometry(0.8, 1.0, 0.5, 6));
        const skirt = new THREE.Mesh(skirtGeo, matArmor);
        skirt.position.y = 0.25;
        group.add(skirt);

        return group;
    }

    // --- NEW: NEURAL ZEALOT (Cyber Cultist) ---
    static createNeuralZealot() {
        const group = new THREE.Group();
        
        // Materials
        const matRobes = this.getMaterial('zealot_robes', () => new THREE.MeshStandardMaterial({ color: 0x110011, roughness: 0.9 }));
        const matCyber = this.getMaterial('zealot_cyber', () => new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.8, wireframe: true }));
        const matSkin = this.getMaterial('zealot_skin', () => new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5 }));

        // Body (Robed)
        const bodyGeo = this.getGeometry('zealot_body', () => new THREE.ConeGeometry(0.5, 1.8, 6));
        const body = new THREE.Mesh(bodyGeo, matRobes);
        body.position.y = 0.9;
        group.add(body);
        
        // Head (Hooded)
        const headGeo = this.getGeometry('zealot_head', () => new THREE.SphereGeometry(0.3, 8, 8));
        const head = new THREE.Mesh(headGeo, matRobes);
        head.position.y = 1.7;
        group.add(head);
        
        // Face (Cyber)
        const faceGeo = this.getGeometry('zealot_face', () => new THREE.BoxGeometry(0.2, 0.2, 0.2));
        const face = new THREE.Mesh(faceGeo, matCyber);
        face.position.set(0, 1.7, 0.2);
        group.add(face);
        
        // Floating Data Rings
        const ringGeo = this.getGeometry('zealot_ring', () => new THREE.TorusGeometry(0.8, 0.02, 4, 16));
        const ring1 = new THREE.Mesh(ringGeo, matCyber);
        ring1.rotation.x = Math.PI/2;
        ring1.position.y = 1.0;
        group.add(ring1);
        
        const ring2 = new THREE.Mesh(ringGeo, matCyber);
        ring2.rotation.x = Math.PI/2;
        ring2.rotation.y = 0.5;
        ring2.position.y = 1.0;
        ring2.scale.set(0.8, 0.8, 0.8);
        group.add(ring2);
        
        // Animation Ref
        group.userData.rings = [ring1, ring2];

        return group;
    }

    // ... existing methods (createMechDrone, createScytherMech, etc.) ...
    
    static getScytherInstancedGeometry() {
        if (this.cache.geometries['scyther_baked']) return this.cache.geometries['scyther_baked'];
        const geometries = [];
        const scale = 2.5; 
        const prepare = (geo) => {
            const nonIndexed = geo.toNonIndexed();
            geo.dispose(); 
            return nonIndexed;
        };
        const torso = new THREE.ConeGeometry(0.4 * scale, 1.2 * scale, 6);
        torso.rotateX(Math.PI); 
        torso.scale(1, 1, 0.6);
        torso.translate(0, 1.0 * scale, 0); 
        geometries.push(prepare(torso));
        const head = new THREE.ConeGeometry(0.2 * scale, 0.6 * scale, 4);
        head.rotateX(-Math.PI/2);
        head.translate(0, 1.6 * scale, 0.2 * scale);
        geometries.push(prepare(head));
        const armL = new THREE.CylinderGeometry(0.05 * scale, 0.05 * scale, 0.6 * scale);
        armL.translate(0, -0.3 * scale, 0);
        armL.rotateZ(0.5);
        armL.translate(0.4 * scale, 1.4 * scale, 0);
        geometries.push(prepare(armL));
        const armR = new THREE.CylinderGeometry(0.05 * scale, 0.05 * scale, 0.6 * scale);
        armR.translate(0, -0.3 * scale, 0);
        armR.rotateZ(-0.5);
        armR.translate(-0.4 * scale, 1.4 * scale, 0);
        geometries.push(prepare(armR));
        const bladeL = new THREE.BoxGeometry(0.1 * scale, 1.0 * scale, 0.05 * scale);
        bladeL.translate(0, 0.5 * scale, 0); 
        bladeL.rotateX(Math.PI/2); 
        bladeL.translate(0.6 * scale, 1.0 * scale, 0);
        geometries.push(prepare(bladeL));
        const bladeR = new THREE.BoxGeometry(0.1 * scale, 1.0 * scale, 0.05 * scale);
        bladeR.translate(0, 0.5 * scale, 0);
        bladeR.rotateX(Math.PI/2);
        bladeR.translate(-0.6 * scale, 1.0 * scale, 0);
        geometries.push(prepare(bladeR));
        const legL = new THREE.CylinderGeometry(0.08 * scale, 0.05 * scale, 0.8 * scale);
        legL.translate(0, -0.4 * scale, 0);
        legL.rotateX(-0.3);
        legL.translate(0.2 * scale, 0.5 * scale, 0);
        geometries.push(prepare(legL));
        const legR = new THREE.CylinderGeometry(0.08 * scale, 0.05 * scale, 0.8 * scale);
        legR.translate(0, -0.4 * scale, 0);
        legR.rotateX(-0.3);
        legR.translate(-0.2 * scale, 0.5 * scale, 0);
        geometries.push(prepare(legR));
        let totalVertices = 0;
        geometries.forEach(g => totalVertices += g.attributes.position.count);
        const mergedPos = new Float32Array(totalVertices * 3);
        const mergedNorm = new Float32Array(totalVertices * 3);
        let offset = 0;
        geometries.forEach(g => {
            const pos = g.attributes.position;
            const norm = g.attributes.normal;
            for(let i=0; i<pos.count; i++) {
                mergedPos[(offset + i)*3] = pos.getX(i);
                mergedPos[(offset + i)*3+1] = pos.getY(i);
                mergedPos[(offset + i)*3+2] = pos.getZ(i);
                if (norm) {
                    mergedNorm[(offset + i)*3] = norm.getX(i);
                    mergedNorm[(offset + i)*3+1] = norm.getY(i);
                    mergedNorm[(offset + i)*3+2] = norm.getZ(i);
                } else {
                    mergedNorm[(offset + i)*3] = 0;
                    mergedNorm[(offset + i)*3+1] = 1;
                    mergedNorm[(offset + i)*3+2] = 0;
                }
            }
            offset += pos.count;
            g.dispose(); 
        });
        const mergedGeo = new THREE.BufferGeometry();
        mergedGeo.setAttribute('position', new THREE.BufferAttribute(mergedPos, 3));
        mergedGeo.setAttribute('normal', new THREE.BufferAttribute(mergedNorm, 3));
        if (totalVertices > 0) mergedGeo.computeVertexNormals();
        this.cache.geometries['scyther_baked'] = mergedGeo;
        return mergedGeo;
    }

    static createAsteroid(size = 10) {
        const geo = this.getGeometry(`asteroid_${Math.floor(size)}`, () => {
            const g = new THREE.DodecahedronGeometry(size, 1); 
            const pos = g.attributes.position;
            for(let i=0; i<pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const z = pos.getZ(i);
                const noise = Math.random() * size * 0.2;
                pos.setX(i, x + (Math.random()-0.5) * noise);
                pos.setY(i, y + (Math.random()-0.5) * noise);
                pos.setZ(i, z + (Math.random()-0.5) * noise);
            }
            g.computeVertexNormals();
            return g;
        });
        const mat = this.getMaterial('asteroid_mat', () => new THREE.MeshStandardMaterial({
            color: 0x555566,
            roughness: 0.9,
            metalness: 0.1,
            flatShading: true
        }));
        const mesh = new THREE.Mesh(geo, mat);
        return mesh;
    }

    static createSpaceDebris() {
        const group = new THREE.Group();
        const count = 5 + Math.floor(Math.random() * 5);
        const mat = this.getMaterial('debris_mat', () => new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.6,
            metalness: 0.8
        }));
        for(let i=0; i<count; i++) {
            const size = 0.5 + Math.random() * 1.5;
            const geo = new THREE.BoxGeometry(size, size * Math.random(), size * Math.random());
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(
                (Math.random()-0.5) * 10,
                (Math.random()-0.5) * 10,
                (Math.random()-0.5) * 10
            );
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            group.add(mesh);
        }
        return group;
    }

    static createEnergyBlade(matBlade, matFrame) {
        const group = new THREE.Group();
        const housingGeo = this.getGeometry('blade_housing', () => new THREE.BoxGeometry(0.12, 0.4, 0.15));
        const housing = new THREE.Mesh(housingGeo, matFrame);
        housing.position.y = 0.2;
        group.add(housing);
        const bladeGeo = this.getGeometry('blade_shape', () => {
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, 0);
            bladeShape.lineTo(0.1, 0.2);
            bladeShape.lineTo(0.08, 1.8); 
            bladeShape.lineTo(0, 2.0);    
            bladeShape.lineTo(-0.05, 1.8);
            bladeShape.lineTo(-0.02, 0);
            return new THREE.ExtrudeGeometry(bladeShape, { depth: 0.02, bevelEnabled: false });
        });
        const blade = new THREE.Mesh(bladeGeo, matBlade);
        blade.rotation.x = -Math.PI / 2;
        blade.position.set(0, 0.4, 0);
        group.add(blade);
        const glowGeo = this.getGeometry('blade_glow', () => new THREE.PlaneGeometry(0.5, 2.2));
        const glow = new THREE.Mesh(glowGeo, matBlade.clone()); 
        glow.material.opacity = 0.3;
        glow.material.side = THREE.DoubleSide;
        glow.rotation.x = -Math.PI/2;
        glow.rotation.y = Math.PI/2; 
        glow.position.set(0, 0.4, 1.0);
        group.add(glow);
        return group;
    }

    static createAvengerShotgun() {
        const group = new THREE.Group();
        const bodyGeo = this.getGeometry('shotgun_body', () => new THREE.BoxGeometry(0.18, 0.25, 0.8));
        const bodyMat = this.getMaterial('shotgun_body_mat', () => new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.6, roughness: 0.4 }));
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.z = 0.2;
        group.add(body);
        const barrelGeo = this.getGeometry('shotgun_barrel', () => new THREE.CylinderGeometry(0.06, 0.06, 1.0, 16));
        const barrelMat = this.getMaterial('shotgun_barrel_mat', () => new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.3 }));
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0, 0.05, 0.8);
        group.add(barrel);
        const shieldGeo = this.getGeometry('shotgun_shield', () => new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8, 1, true));
        const shieldMat = this.getMaterial('shotgun_shield_mat', () => new THREE.MeshStandardMaterial({ color: 0x444444, side: THREE.DoubleSide }));
        const shield = new THREE.Mesh(shieldGeo, shieldMat);
        shield.rotation.x = Math.PI / 2;
        shield.position.set(0, 0.05, 0.8);
        group.add(shield);
        const stockGeo = this.getGeometry('shotgun_stock', () => new THREE.BoxGeometry(0.12, 0.18, 0.6));
        const stock = new THREE.Mesh(stockGeo, bodyMat);
        stock.position.set(0, -0.05, -0.5);
        group.add(stock);
        const gripGeo = this.getGeometry('shotgun_grip', () => new THREE.BoxGeometry(0.2, 0.12, 0.3));
        const gripMat = this.getMaterial('shotgun_grip_mat', () => new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 1.0 }));
        const grip = new THREE.Mesh(gripGeo, gripMat);
        grip.position.set(0, -0.08, 0.6);
        group.add(grip);
        const holoGeo = this.getGeometry('shotgun_holo', () => new THREE.PlaneGeometry(0.1, 0.05));
        const holoMat = this.getMaterial('shotgun_holo_mat', () => new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide }));
        const holo = new THREE.Mesh(holoGeo, holoMat);
        holo.position.set(-0.1, 0.15, 0.1);
        holo.rotation.y = -0.5;
        group.add(holo);
        return group;
    }

    static createCyberMonolith() {
        const group = new THREE.Group();
        const coreGeo = this.getGeometry('monolith_core', () => new THREE.BoxGeometry(8, 25, 8));
        const coreMat = this.getMaterial('monolith_core_mat', () => new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2, metalness: 0.9 }));
        const core = new THREE.Mesh(coreGeo, coreMat);
        core.position.y = 12.5;
        group.add(core);
        const runeGeo = this.getGeometry('monolith_runes', () => new THREE.BoxGeometry(8.1, 20, 8.1));
        const runeMat = this.getMaterial('monolith_runes_mat', () => {
            const runeTex = TextureGen.createAd(512, "SYSTEM_CORE");
            runeTex.wrapS = THREE.RepeatWrapping;
            runeTex.wrapT = THREE.RepeatWrapping;
            runeTex.repeat.set(1, 4);
            return new THREE.MeshBasicMaterial({ 
                map: runeTex, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
        });
        const runes = new THREE.Mesh(runeGeo, runeMat);
        runes.position.y = 12.5;
        group.add(runes);
        const antGeo = this.getGeometry('monolith_ant', () => new THREE.CylinderGeometry(0.2, 0.5, 8));
        const antMat = this.getMaterial('monolith_ant_mat', () => new THREE.MeshStandardMaterial({color: 0x333}));
        for(let i=0; i<4; i++) {
            const ant = new THREE.Mesh(antGeo, antMat);
            ant.position.set(
                (i%2===0 ? 3 : -3),
                28,
                (i<2 ? 3 : -3)
            );
            group.add(ant);
            const light = new THREE.PointLight(0xff0000, 2, 10);
            light.position.copy(ant.position);
            light.position.y += 4;
            group.add(light);
        }
        return group;
    }

    static createHoloTerminal() {
        const group = new THREE.Group();
        const baseGeo = this.getGeometry('terminal_base', () => new THREE.CylinderGeometry(0.2, 0.5, 1.2, 6));
        const baseMat = this.getMaterial('terminal_base_mat', () => new THREE.MeshStandardMaterial({ color: 0x222, metalness: 0.8 }));
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.position.y = 0.6;
        group.add(base);
        const screenGeo = this.getGeometry('terminal_screen', () => new THREE.PlaneGeometry(1.5, 1.0));
        const screenMat = this.getMaterial('terminal_screen_mat', () => {
            const screenTex = TextureGen.createAd(256, "ACCESS");
            return new THREE.MeshBasicMaterial({ 
                map: screenTex, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
        });
        const screen = new THREE.Mesh(screenGeo, screenMat);
        screen.position.set(0, 1.8, 0.3);
        screen.rotation.x = -0.2;
        group.add(screen);
        const keyGeo = this.getGeometry('terminal_keys', () => new THREE.PlaneGeometry(1.0, 0.6));
        const keyMat = this.getMaterial('terminal_keys_mat', () => new THREE.MeshBasicMaterial({ color: 0x00aaff, wireframe: true, transparent: true, opacity: 0.3 }));
        const keys = new THREE.Mesh(keyGeo, keyMat);
        keys.position.set(0, 1.3, 0.6);
        keys.rotation.x = -0.8;
        group.add(keys);
        return group;
    }

    static createMechDrone() {
        const group = new THREE.Group();
        const matDark = this.getMaterial('drone_dark', () => new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0.6 }));
        const matPlate = this.getMaterial('drone_plate', () => new THREE.MeshStandardMaterial({ color: 0x555566, roughness: 0.3, metalness: 0.8 }));
        const matGlow = this.getMaterial('drone_glow', () => new THREE.MeshBasicMaterial({ color: 0xff3300 })); 
        const matEngine = this.getMaterial('drone_engine', () => new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent:true, opacity:0.8, blending: THREE.AdditiveBlending }));
        const coreGeo = this.getGeometry('drone_core', () => new THREE.DodecahedronGeometry(0.5));
        const core = new THREE.Mesh(coreGeo, matDark);
        group.add(core);
        const plateGeo = this.getGeometry('drone_plate_geo', () => new THREE.CylinderGeometry(0.6, 0.6, 0.1, 6));
        const plateTop = new THREE.Mesh(plateGeo, matPlate);
        plateTop.position.y = 0.35;
        group.add(plateTop);
        const plateBot = new THREE.Mesh(plateGeo, matPlate);
        plateBot.position.y = -0.35;
        group.add(plateBot);
        const eyeGeo = this.getGeometry('drone_eye', () => new THREE.SphereGeometry(0.25, 16, 16));
        const eye = new THREE.Mesh(eyeGeo, matGlow);
        eye.position.z = 0.35;
        eye.scale.set(1, 0.4, 1); 
        group.add(eye);
        const eyeShell = new THREE.Mesh(eyeGeo, matGlow.clone()); 
        eyeShell.material.transparent = true;
        eyeShell.material.opacity = 0.4;
        eyeShell.material.blending = THREE.AdditiveBlending;
        eyeShell.scale.set(1.2, 0.6, 1.2);
        eye.add(eyeShell);
        const armGeo = this.getGeometry('drone_arm', () => new THREE.BoxGeometry(0.4, 0.1, 0.1));
        const thrusterGeo = this.getGeometry('drone_thruster', () => {
            const g = new THREE.CylinderGeometry(0.15, 0.1, 0.6, 8);
            g.rotateX(Math.PI/2); 
            return g;
        });
        const leftArm = new THREE.Group();
        leftArm.position.set(-0.6, 0, 0);
        const lArmMesh = new THREE.Mesh(armGeo, matDark);
        leftArm.add(lArmMesh);
        const lThruster = new THREE.Mesh(thrusterGeo, matPlate);
        lThruster.position.x = -0.2;
        leftArm.add(lThruster);
        const engineGlowGeo = this.getGeometry('drone_engine_glow', () => {
            const g = new THREE.ConeGeometry(0.08, 0.4, 8);
            g.rotateX(Math.PI/2);
            return g;
        });
        const engineGlow = new THREE.Mesh(engineGlowGeo, matEngine);
        engineGlow.position.set(-0.2, 0, 0.4); 
        leftArm.add(engineGlow);
        group.add(leftArm);
        const rightArm = leftArm.clone();
        rightArm.position.set(0.6, 0, 0);
        rightArm.rotation.z = Math.PI; 
        group.add(rightArm);
        const gunGeo = this.getGeometry('drone_gun', () => new THREE.BoxGeometry(0.15, 0.15, 0.6));
        const gun = new THREE.Mesh(gunGeo, matDark);
        gun.position.set(0, -0.5, 0.2);
        group.add(gun);
        const barrelGeo = this.getGeometry('drone_gun_barrel', () => new THREE.CylinderGeometry(0.03, 0.03, 0.8));
        const barrel = new THREE.Mesh(barrelGeo, matPlate);
        barrel.rotation.x = Math.PI/2;
        barrel.position.set(0, -0.5, 0.6);
        group.add(barrel);
        group.userData.rotors = [leftArm, rightArm]; 
        return group;
    }

    static createHunter() {
        const group = new THREE.Group();
        const matBody = this.getMaterial('hunter_body', () => new THREE.MeshStandardMaterial({ color: 0x333344, roughness: 0.5, metalness: 0.7 }));
        const matArmor = this.getMaterial('hunter_armor', () => new THREE.MeshStandardMaterial({ color: 0xaa0000, roughness: 0.3, metalness: 0.5 })); 
        const matJoint = this.getMaterial('hunter_joint', () => new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 }));
        const matEye = this.getMaterial('hunter_eye', () => new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        const matShield = this.getMaterial('hunter_shield_mat', () => new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0.0, 
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        }));
        const torsoGeo = this.getGeometry('hunter_torso', () => new THREE.BoxGeometry(0.8, 0.6, 1.5));
        const torso = new THREE.Mesh(torsoGeo, matBody);
        group.add(torso);
        const plateGeo = this.getGeometry('hunter_plate', () => new THREE.CylinderGeometry(0.5, 0.6, 1.2, 4));
        const plate = new THREE.Mesh(plateGeo, matArmor);
        plate.rotation.x = Math.PI/2;
        plate.rotation.y = Math.PI/4;
        plate.position.y = 0.35;
        group.add(plate);
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 0.4, 0.8);
        group.add(headGroup);
        const headGeo = this.getGeometry('hunter_head', () => new THREE.ConeGeometry(0.3, 0.8, 4));
        const head = new THREE.Mesh(headGeo, matBody);
        head.rotation.x = -Math.PI/2;
        headGroup.add(head);
        const earGeo = this.getGeometry('hunter_ear', () => new THREE.ConeGeometry(0.1, 0.3, 4));
        const earL = new THREE.Mesh(earGeo, matArmor);
        earL.position.set(0.2, 0.2, -0.2);
        earL.rotation.z = -0.3;
        headGroup.add(earL);
        const earR = new THREE.Mesh(earGeo, matArmor);
        earR.position.set(-0.2, 0.2, -0.2);
        earR.rotation.z = 0.3;
        headGroup.add(earR);
        const eyeGeo = this.getGeometry('hunter_eye_geo', () => new THREE.BoxGeometry(0.1, 0.05, 0.05));
        const eyeL = new THREE.Mesh(eyeGeo, matEye);
        eyeL.position.set(0.15, 0.1, 0.1);
        eyeL.rotation.y = 0.3;
        headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, matEye);
        eyeR.position.set(-0.15, 0.1, 0.1);
        eyeR.rotation.y = -0.3;
        headGroup.add(eyeR);
        const legs = [];
        const legGeo = this.getGeometry('hunter_leg', () => new THREE.BoxGeometry(0.2, 0.8, 0.2));
        const createLeg = (x, z, isRear) => {
            const legGroup = new THREE.Group();
            legGroup.position.set(x, 0, z);
            const joint = new THREE.Mesh(new THREE.SphereGeometry(0.25), matJoint);
            legGroup.add(joint);
            const upper = new THREE.Mesh(legGeo, matBody);
            upper.position.y = -0.4;
            upper.rotation.x = isRear ? 0.5 : -0.5;
            legGroup.add(upper);
            const lower = new THREE.Mesh(legGeo, matArmor);
            lower.position.set(0, -0.8, isRear ? 0.3 : -0.3);
            lower.rotation.x = isRear ? -0.8 : 0.8;
            upper.add(lower);
            group.add(legGroup);
            return legGroup;
        };
        legs.push(createLeg(0.5, 0.6, false)); 
        legs.push(createLeg(-0.5, 0.6, false)); 
        legs.push(createLeg(0.5, -0.6, true)); 
        legs.push(createLeg(-0.5, -0.6, true)); 
        group.userData.legs = legs; 
        const tailGeo = this.getGeometry('hunter_tail', () => new THREE.CylinderGeometry(0.1, 0.05, 1.0));
        const tail = new THREE.Mesh(tailGeo, matBody);
        tail.rotation.x = -Math.PI/2 - 0.2;
        tail.position.set(0, 0.2, -0.8);
        group.add(tail);
        const shieldGeo = this.getGeometry('hunter_shield_geo', () => new THREE.SphereGeometry(1.2, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5));
        const shield = new THREE.Mesh(shieldGeo, matShield);
        shield.rotation.x = -Math.PI/2; 
        shield.position.set(0, 0.5, 1.0);
        shield.scale.set(1, 0.5, 1); 
        shield.visible = false; 
        group.add(shield);
        group.userData.shield = shield;
        return group;
    }

    static createScytherMech() {
        const group = new THREE.Group();
        const matGreen = this.getMaterial('scyther_green', () => new THREE.MeshStandardMaterial({ color: 0x00aa44, roughness: 0.4, metalness: 0.6 }));
        const matJoint = this.getMaterial('scyther_joint', () => new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }));
        const matBlade = this.getMaterial('scyther_blade', () => new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.9, roughness: 0.1, emissive: 0x88ff88, emissiveIntensity: 0.2 }));
        const matEye = this.getMaterial('scyther_eye', () => new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        const torsoGeo = this.getGeometry('scyther_torso', () => new THREE.ConeGeometry(0.4, 1.2, 6));
        const torso = new THREE.Mesh(torsoGeo, matGreen);
        torso.rotation.x = Math.PI; 
        torso.scale.z = 0.6; 
        group.add(torso);
        const headGeo = this.getGeometry('scyther_head', () => new THREE.ConeGeometry(0.2, 0.6, 4));
        const head = new THREE.Mesh(headGeo, matGreen);
        head.rotation.x = -Math.PI/2; 
        head.position.y = 0.6;
        head.position.z = 0.2;
        group.add(head);
        const eyeGeo = this.getGeometry('scyther_eye_geo', () => new THREE.SphereGeometry(0.08, 8, 8));
        const eyeL = new THREE.Mesh(eyeGeo, matEye);
        eyeL.position.set(0.1, 0.6, 0.4);
        group.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, matEye);
        eyeR.position.set(-0.1, 0.6, 0.4);
        group.add(eyeR);
        const armGeo = this.getGeometry('scyther_arm', () => new THREE.CylinderGeometry(0.05, 0.05, 0.6));
        const bladeGeo = this.getGeometry('scyther_blade_geo', () => {
            const shape = new THREE.Shape();
            shape.moveTo(0,0);
            shape.lineTo(0.2, 0.1);
            shape.lineTo(0.1, 1.5); 
            shape.lineTo(0, 1.6);
            return new THREE.ExtrudeGeometry(shape, {depth: 0.05, bevelEnabled: false});
        });
        const createArm = (side) => {
            const armGroup = new THREE.Group();
            armGroup.position.set(side * 0.4, 0.4, 0);
            const shoulder = new THREE.Mesh(new THREE.SphereGeometry(0.15), matJoint);
            armGroup.add(shoulder);
            const upper = new THREE.Mesh(armGeo, matGreen);
            upper.position.y = -0.3;
            upper.rotation.z = side * 0.5;
            armGroup.add(upper);
            const blade = new THREE.Mesh(bladeGeo, matBlade);
            blade.position.set(side * 0.2, -0.6, 0);
            blade.rotation.z = side * 0.5;
            blade.rotation.x = Math.PI/2; 
            armGroup.add(blade);
            return armGroup;
        };
        const armL = createArm(1);
        group.add(armL);
        const armR = createArm(-1);
        group.add(armR);
        const wingGeo = this.getGeometry('scyther_wing', () => new THREE.PlaneGeometry(0.5, 1.5));
        const wingMat = new THREE.MeshBasicMaterial({ color: 0xccffcc, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
        const wingL = new THREE.Mesh(wingGeo, wingMat);
        wingL.position.set(0.2, 0.2, -0.2);
        wingL.rotation.z = -0.5;
        wingL.rotation.x = 0.5;
        group.add(wingL);
        const wingR = new THREE.Mesh(wingGeo, wingMat);
        wingR.position.set(-0.2, 0.2, -0.2);
        wingR.rotation.z = 0.5;
        wingR.rotation.x = 0.5;
        group.add(wingR);
        const legGeo = this.getGeometry('scyther_leg', () => new THREE.CylinderGeometry(0.08, 0.05, 0.8));
        const createLeg = (side) => {
            const legGroup = new THREE.Group();
            legGroup.position.set(side * 0.2, -0.5, 0);
            const thigh = new THREE.Mesh(legGeo, matGreen);
            thigh.position.y = -0.4;
            thigh.rotation.x = -0.5; 
            legGroup.add(thigh);
            const shin = new THREE.Mesh(legGeo, matGreen);
            shin.position.set(0, -0.8, -0.3);
            shin.rotation.x = 1.0; 
            legGroup.add(shin);
            return legGroup;
        };
        group.add(createLeg(1));
        group.add(createLeg(-1));
        group.userData.wings = [wingL, wingR];
        return group;
    }

    static createCyberSamurai() {
        const group = new THREE.Group();
        const torso = new THREE.Mesh(
            this.getGeometry('samurai_torso', () => new THREE.BoxGeometry(0.6, 0.8, 0.4)),
            this.getMaterial('samurai_torso_mat', () => new THREE.MeshStandardMaterial({ color: 0x550000, metalness: 0.5 }))
        );
        torso.position.y = 0.4;
        group.add(torso);
        const head = new THREE.Mesh(
            this.getGeometry('samurai_head', () => new THREE.BoxGeometry(0.3, 0.3, 0.3)),
            this.getMaterial('samurai_head_mat', () => new THREE.MeshStandardMaterial({ color: 0x111 }))
        );
        head.position.y = 1.0;
        group.add(head);
        const visor = new THREE.Mesh(
            this.getGeometry('samurai_visor', () => new THREE.BoxGeometry(0.32, 0.05, 0.2)),
            this.getMaterial('samurai_visor_mat', () => new THREE.MeshBasicMaterial({ color: 0xff0055 }))
        );
        visor.position.set(0, 1.0, 0.1);
        group.add(visor);
        return group;
    }

    static createExplosiveBarrel() {
        const group = new THREE.Group();
        const barrelGeo = this.getGeometry('barrel_geo', () => new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16));
        const barrelMat = this.getMaterial('barrel_mat', () => new THREE.MeshStandardMaterial({ color: 0xcc3300, metalness: 0.3, roughness: 0.7 }));
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.position.y = 0.6;
        group.add(barrel);
        const ringGeo = this.getGeometry('barrel_ring', () => new THREE.TorusGeometry(0.41, 0.02, 8, 16));
        const ringMat = this.getMaterial('barrel_ring_mat', () => new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        const ring1 = new THREE.Mesh(ringGeo, ringMat);
        ring1.rotation.x = Math.PI / 2;
        ring1.position.y = 0.9;
        group.add(ring1);
        const ring2 = new THREE.Mesh(ringGeo, ringMat);
        ring2.rotation.x = Math.PI / 2;
        ring2.position.y = 0.3;
        group.add(ring2);
        return group;
    }

    static createAnubisBoss() {
        const group = new THREE.Group();
        const matBlack = this.getMaterial('anubis_black', () => new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.2, metalness: 0.9 }));
        const matGold = this.getMaterial('anubis_gold', () => new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.1, metalness: 1.0, emissive: 0xaa8800, emissiveIntensity: 0.2 }));
        const matFlow = this.getMaterial('anubis_flow', () => {
            const flowVert = `
                varying vec2 vUv;
                varying vec3 vNormal;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const flowFrag = `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec2 vUv;
                varying vec3 vNormal;
                void main() {
                    float flow = sin(vUv.y * 30.0 - uTime * 15.0);
                    float intensity = smoothstep(0.8, 1.0, flow);
                    vec3 baseColor = vec3(0.05, 0.05, 0.05); 
                    vec3 lightColor = uColor * 2.0; 
                    vec3 finalColor = mix(baseColor, lightColor, intensity);
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;
            return new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: flowVert,
                fragmentShader: flowFrag
            });
        });
        const torsoGeo = this.getGeometry('anubis_torso', () => new THREE.CylinderGeometry(0.4, 0.2, 1.2, 5));
        const torso = new THREE.Mesh(torsoGeo, matBlack);
        torso.position.y = 1.0;
        group.add(torso);
        const chestGeo = this.getGeometry('anubis_chest', () => new THREE.BoxGeometry(0.6, 0.5, 0.3));
        const chest = new THREE.Mesh(chestGeo, matGold);
        chest.position.set(0, 1.3, 0.15);
        group.add(chest);
        const flowStripGeo = this.getGeometry('anubis_flowstrip', () => new THREE.BoxGeometry(0.1, 1.0, 0.45));
        const flowStrip = new THREE.Mesh(flowStripGeo, matFlow);
        flowStrip.position.set(0, 1.0, 0);
        group.add(flowStrip);
        const headGroup = new THREE.Group();
        headGroup.position.y = 1.7;
        group.add(headGroup);
        const snoutGeo = this.getGeometry('anubis_snout', () => new THREE.ConeGeometry(0.15, 0.5, 4));
        const snout = new THREE.Mesh(snoutGeo, matBlack);
        snout.rotation.x = -Math.PI / 2;
        snout.position.z = 0.25;
        headGroup.add(snout);
        const craniumGeo = this.getGeometry('anubis_cranium', () => new THREE.BoxGeometry(0.3, 0.3, 0.4));
        const cranium = new THREE.Mesh(craniumGeo, matBlack);
        headGroup.add(cranium);
        const earGeo = this.getGeometry('anubis_ear', () => new THREE.ConeGeometry(0.08, 0.6, 4));
        const earL = new THREE.Mesh(earGeo, matGold);
        earL.position.set(0.15, 0.4, -0.1);
        earL.rotation.z = -0.2;
        earL.rotation.x = -0.2;
        headGroup.add(earL);
        const earR = new THREE.Mesh(earGeo, matGold);
        earR.position.set(-0.15, 0.4, -0.1);
        earR.rotation.z = 0.2;
        earR.rotation.x = -0.2;
        headGroup.add(earR);
        const eyeGeo = this.getGeometry('anubis_eye', () => new THREE.BoxGeometry(0.05, 0.02, 0.1));
        const eyeMat = this.getMaterial('anubis_eye_mat', () => new THREE.MeshBasicMaterial({ color: 0xffffff }));
        const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
        eyeL.position.set(0.1, 0.05, 0.2);
        eyeL.rotation.y = 0.2;
        headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
        eyeR.position.set(-0.1, 0.05, 0.2);
        eyeR.rotation.y = -0.2;
        headGroup.add(eyeR);
        const limbGeo = this.getGeometry('anubis_limb', () => new THREE.BoxGeometry(0.15, 1.2, 0.15));
        const legL = new THREE.Mesh(limbGeo, matBlack);
        legL.position.set(0.2, 0.0, 0);
        group.add(legL);
        const legR = new THREE.Mesh(limbGeo, matBlack);
        legR.position.set(-0.2, 0.0, 0);
        group.add(legR);
        const armL = new THREE.Mesh(limbGeo, matBlack);
        armL.position.set(0.5, 1.0, 0);
        armL.rotation.z = -0.2;
        group.add(armL);
        const armR = new THREE.Mesh(limbGeo, matBlack);
        armR.position.set(-0.5, 1.0, 0);
        armR.rotation.z = 0.2;
        group.add(armR);
        const limbFlowGeo = this.getGeometry('anubis_limb_flow', () => new THREE.BoxGeometry(0.05, 1.0, 0.16));
        const limbFlow = new THREE.Mesh(limbFlowGeo, matFlow);
        legL.add(limbFlow.clone());
        legR.add(limbFlow.clone());
        armL.add(limbFlow.clone());
        armR.add(limbFlow.clone());
        const wingGroup = new THREE.Group();
        wingGroup.position.set(0, 1.4, -0.3);
        group.add(wingGroup);
        const createWing = (side, angle) => {
            const w = new THREE.Group();
            const bladeGeo = this.getGeometry('anubis_wing_blade', () => new THREE.BoxGeometry(0.1, 2.5, 0.5));
            const blade = new THREE.Mesh(bladeGeo, matBlack);
            blade.position.y = 1.0;
            w.add(blade);
            const edgeGeo = this.getGeometry('anubis_wing_edge', () => new THREE.BoxGeometry(0.12, 2.5, 0.1));
            const edge = new THREE.Mesh(edgeGeo, matGold);
            edge.position.set(0, 1.0, 0.25);
            w.add(edge);
            const coreGeo = this.getGeometry('anubis_wing_core', () => new THREE.BoxGeometry(0.15, 2.0, 0.3));
            const core = new THREE.Mesh(coreGeo, matFlow);
            core.position.y = 1.0;
            w.add(core);
            w.rotation.z = angle * side;
            w.rotation.x = 0.3; 
            return w;
        };
        const w1 = createWing(1, 0.5); 
        w1.position.x = 0.2;
        wingGroup.add(w1);
        const w2 = createWing(-1, 0.5); 
        w2.position.x = -0.2;
        wingGroup.add(w2);
        const w3 = createWing(1, 2.5); 
        w3.position.x = 0.2;
        w3.scale.set(0.8, 0.8, 0.8);
        wingGroup.add(w3);
        const w4 = createWing(-1, 2.5); 
        w4.position.x = -0.2;
        w4.scale.set(0.8, 0.8, 0.8);
        wingGroup.add(w4);
        group.userData.wings = [w1, w2, w3, w4];
        group.userData.matFlow = matFlow; 
        const staffGeo = this.getGeometry('anubis_staff', () => new THREE.CylinderGeometry(0.05, 0.05, 3.0));
        const staff = new THREE.Mesh(staffGeo, matGold);
        staff.rotation.z = Math.PI / 2;
        armR.add(staff);
        staff.position.set(0, -0.6, 0.5); 
        staff.rotation.x = Math.PI/2;
        group.userData.staff = staff;
        const funnelGroup = new THREE.Group();
        funnelGroup.position.set(0, 2.0, -0.5);
        group.add(funnelGroup);
        const funnels = [];
        const funnelGeo = this.getGeometry('anubis_funnel', () => new THREE.ConeGeometry(0.1, 0.6, 4));
        for(let i=0; i<6; i++) {
            const f = new THREE.Mesh(funnelGeo, matGold);
            f.userData = { 
                id: i, 
                basePos: new THREE.Vector3(Math.cos(i/6 * Math.PI*2)*0.8, Math.sin(i/6 * Math.PI*2)*0.8, 0),
                velocity: new THREE.Vector3()
            };
            funnelGroup.add(f);
            funnels.push(f);
        }
        group.userData.funnels = funnels;
        group.userData.funnelGroup = funnelGroup;
        const haloGeo = this.getGeometry('anubis_halo', () => new THREE.TorusGeometry(0.6, 0.02, 8, 32));
        const halo = new THREE.Mesh(haloGeo, matFlow); 
        halo.position.set(0, 2.2, -0.2);
        group.add(halo);
        group.userData.halo = halo;
        return group;
    }
}</script>
    <script>/**
 * SPACE ASSET FACTORY
 * Specialized generator for Space Mode entities.
 * Handles high-fidelity Capital Ships, Asteroids, and Stations.
 */
class SpaceAssetFactory {
    
    static getMaterial(color, emissive = 0x000000) {
        return new THREE.MeshStandardMaterial({
            color: color,
            emissive: emissive,
            emissiveIntensity: emissive ? 2.0 : 0.0,
            roughness: 0.4,
            metalness: 0.8
        });
    }

    static createAsteroid(size = 10) {
        const geo = new THREE.DodecahedronGeometry(size, 1);
        const pos = geo.attributes.position;
        for(let i=0; i<pos.count; i++) {
            const noise = Math.random() * size * 0.3;
            pos.setX(i, pos.getX(i) + (Math.random()-0.5) * noise);
            pos.setY(i, pos.getY(i) + (Math.random()-0.5) * noise);
            pos.setZ(i, pos.getZ(i) + (Math.random()-0.5) * noise);
        }
        geo.computeVertexNormals();
        
        const mat = new THREE.MeshStandardMaterial({
            color: 0x666677,
            roughness: 0.9,
            metalness: 0.2,
            flatShading: true
        });
        
        return new THREE.Mesh(geo, mat);
    }

    static createSpaceInterceptor() {
        const group = new THREE.Group();
        
        // Materials
        const hullMat = this.getMaterial(0x4444aa);
        const darkMat = this.getMaterial(0x222222);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xff3300 }); // Enemy red engine
        
        // Fuselage
        const bodyGeo = new THREE.ConeGeometry(0.8, 4, 4);
        bodyGeo.rotateX(Math.PI/2);
        const body = new THREE.Mesh(bodyGeo, hullMat);
        group.add(body);
        
        // Wings (Forward Swept)
        const wingGeo = new THREE.BoxGeometry(4, 0.2, 1.5);
        const wing = new THREE.Mesh(wingGeo, hullMat);
        wing.position.z = 0.5;
        group.add(wing);
        
        // Engines
        const engineGeo = new THREE.BoxGeometry(0.5, 0.5, 2);
        const engL = new THREE.Mesh(engineGeo, darkMat);
        engL.position.set(1.5, 0, 0.5);
        group.add(engL);
        
        const engR = new THREE.Mesh(engineGeo, darkMat);
        engR.position.set(-1.5, 0, 0.5);
        group.add(engR);
        
        // Glows
        const glowGeo = new THREE.PlaneGeometry(0.4, 0.4);
        const glowL = new THREE.Mesh(glowGeo, glowMat);
        glowL.position.set(1.5, 0, 1.6);
        group.add(glowL);
        
        const glowR = new THREE.Mesh(glowGeo, glowMat);
        glowR.position.set(-1.5, 0, 1.6);
        group.add(glowR);
        
        return group;
    }

    static createCapitalShip() {
        const group = new THREE.Group();
        
        // Materials
        const hullMat = this.getMaterial(0x303040);
        const darkMat = this.getMaterial(0x151520);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00aaff });
        const engineGlowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, blending: THREE.AdditiveBlending });
        const shieldMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0.3, 
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        // --- MAIN HULL ---
        const hullGeo = new THREE.BoxGeometry(40, 15, 180);
        const hull = new THREE.Mesh(hullGeo, hullMat);
        group.add(hull);
        
        // Detail Plating
        const plateGeo = new THREE.BoxGeometry(42, 8, 100);
        const plate = new THREE.Mesh(plateGeo, darkMat);
        group.add(plate);

        // --- SUBSYSTEM: BRIDGE (Command Tower) ---
        const bridgeGroup = new THREE.Group();
        bridgeGroup.position.set(0, 15, -50);
        group.add(bridgeGroup);
        
        const bridgeGeo = new THREE.BoxGeometry(15, 10, 20);
        const bridgeMesh = new THREE.Mesh(bridgeGeo, hullMat);
        bridgeGroup.add(bridgeMesh);
        
        // Bridge Windows
        const windowGeo = new THREE.BoxGeometry(12, 2, 18);
        const windowMesh = new THREE.Mesh(windowGeo, glowMat);
        windowMesh.position.y = 2;
        bridgeGroup.add(windowMesh);
        
        // Bridge Logic
        bridgeGroup.userData = {
            type: 'enemy',
            enemyType: 'subsystem',
            subsystemType: 'bridge',
            hp: 1500,
            maxHp: 1500,
            isDead: false
        };

        // --- SUBSYSTEMS: ENGINES ---
        const createEngine = (x, z) => {
            const engGroup = new THREE.Group();
            engGroup.position.set(x, 0, z);
            
            const engGeo = new THREE.CylinderGeometry(6, 8, 20, 16);
            engGeo.rotateX(Math.PI/2);
            const engMesh = new THREE.Mesh(engGeo, darkMat);
            engGroup.add(engMesh);
            
            const flareGeo = new THREE.ConeGeometry(5, 15, 16, 1, true);
            flareGeo.rotateX(-Math.PI/2);
            flareGeo.translate(0, 0, 15);
            const flare = new THREE.Mesh(flareGeo, engineGlowMat);
            engGroup.add(flare);
            
            engGroup.userData = {
                type: 'enemy',
                enemyType: 'subsystem',
                subsystemType: 'engine',
                hp: 1000,
                maxHp: 1000,
                isDead: false,
                flare: flare // Ref to hide on death
            };
            return engGroup;
        };

        const engineL = createEngine(15, 90);
        const engineR = createEngine(-15, 90);
        group.add(engineL);
        group.add(engineR);

        // --- CORE (The Weak Point) ---
        const coreGroup = new THREE.Group();
        coreGroup.position.set(0, 0, 0); // Center of ship
        group.add(coreGroup);
        
        // The Reactor
        const coreGeo = new THREE.IcosahedronGeometry(6, 1);
        const coreMat = new THREE.MeshStandardMaterial({ 
            color: 0xff0000, 
            emissive: 0xff0000, 
            emissiveIntensity: 5.0,
            wireframe: true
        });
        const coreMesh = new THREE.Mesh(coreGeo, coreMat);
        coreGroup.add(coreMesh);
        
        // The Shield (Initially Active)
        const shieldGeo = new THREE.SphereGeometry(10, 32, 32);
        const shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
        coreGroup.add(shieldMesh);
        
        coreGroup.userData = {
            type: 'enemy',
            enemyType: 'subsystem',
            subsystemType: 'core',
            hp: 3000,
            maxHp: 3000,
            isDead: false,
            invulnerable: true, // Logic handled in System
            shieldMesh: shieldMesh,
            coreMesh: coreMesh
        };

        // --- HANGARS (Visual) ---
        const hangarGeo = new THREE.BoxGeometry(10, 6, 60);
        const hangarL = new THREE.Mesh(hangarGeo, darkMat);
        hangarL.position.set(25, -2, 0);
        group.add(hangarL);
        
        const hangarR = new THREE.Mesh(hangarGeo, darkMat);
        hangarR.position.set(-25, -2, 0);
        group.add(hangarR);
        
        // Runway Lights
        const stripGeo = new THREE.PlaneGeometry(2, 50);
        stripGeo.rotateX(-Math.PI/2);
        const stripL = new THREE.Mesh(stripGeo, glowMat);
        stripL.position.set(25, 1.1, 0);
        group.add(stripL);
        
        const stripR = new THREE.Mesh(stripGeo, glowMat);
        stripR.position.set(-25, 1.1, 0);
        group.add(stripR);

        // --- MAIN CANNON (NEW) ---
        const cannonGroup = new THREE.Group();
        cannonGroup.position.set(0, 8, -70); // Front top
        group.add(cannonGroup);
        
        // Base
        const cannonBaseGeo = new THREE.BoxGeometry(10, 4, 15);
        const cannonBase = new THREE.Mesh(cannonBaseGeo, darkMat);
        cannonGroup.add(cannonBase);
        
        // Barrels (Twin Railgun)
        const barrelGeo = new THREE.BoxGeometry(2, 2, 20);
        const barrelL = new THREE.Mesh(barrelGeo, hullMat);
        barrelL.position.set(3, 1, -5);
        cannonGroup.add(barrelL);
        
        const barrelR = new THREE.Mesh(barrelGeo, hullMat);
        barrelR.position.set(-3, 1, -5);
        cannonGroup.add(barrelR);
        
        // Charge Emitter
        const emitterGeo = new THREE.SphereGeometry(1.5, 16, 16);
        const emitterMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.5 });
        const emitter = new THREE.Mesh(emitterGeo, emitterMat);
        emitter.position.set(0, 1, -15);
        cannonGroup.add(emitter);
        
        // Expose for logic
        group.userData.mainCannon = {
            group: cannonGroup,
            emitter: emitter
        };

        return group;
    }
}</script> 
    <script>/**
 * HIGH PERFORMANCE PARTICLE SYSTEM - HERCULEAN OPTIMIZATION
 * Uses GPU Instancing to render thousands of particles with 1 draw call.
 * Optimized with High-Water Mark to reduce CPU cycles on low particle counts.
 * OPTIMIZED: Frustum Culling enabled with dynamic Bounding Sphere updates.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes.
 * OPTIMIZED: Implemented Static Color Object to eliminate GC.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _ptVel = new THREE.Vector3();
const _ptQuat = new THREE.Quaternion();
const _ptUp = new THREE.Vector3(0, 1, 0);
const _ptColor = new THREE.Color(); // Static color object

class InstancedParticleSystem {
    constructor(scene, maxParticles = 1000, geometry, material) {
        this.maxParticles = maxParticles;
        this.count = 0;
        this.highWaterMark = 0; // Optimization: Only iterate up to this index until wrap
        this.hasWrapped = false;
        
        // Arrays to store particle state CPU-side
        this.positions = new Float32Array(maxParticles * 3);
        this.velocities = new Float32Array(maxParticles * 3);
        
        // Rotation State (Euler)
        this.rotations = new Float32Array(maxParticles * 3);
        this.rotVelocities = new Float32Array(maxParticles * 3);
        
        this.lives = new Float32Array(maxParticles);
        this.gravities = new Float32Array(maxParticles);
        this.scales = new Float32Array(maxParticles);
        this.baseScales = new Float32Array(maxParticles); // Store original scale for pulsing
        this.growRates = new Float32Array(maxParticles); 
        this.bounciness = new Float32Array(maxParticles); 
        this.drags = new Float32Array(maxParticles); // Air resistance
        this.jitters = new Float32Array(maxParticles); // Position jitter for plasma effect
        this.states = new Int8Array(maxParticles); // 0: Normal, 1: Magnetized, 2: Collecting
        this.delays = new Float32Array(maxParticles); // Time before magnetism activates
        this.types = new Int8Array(maxParticles); // NEW: 0=Visual, 1=HP, 2=Ammo, 3=Credits

        // The Instanced Mesh
        this.mesh = new THREE.InstancedMesh(geometry, material, maxParticles);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        
        // OPTIMIZATION: Enable Frustum Culling
        this.mesh.frustumCulled = true;
        
        // Initialize Bounding Sphere (will be updated dynamically)
        this.mesh.geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(), 50);

        // Initialize off-screen
        this.dummy = new THREE.Object3D();
        for (let i = 0; i < maxParticles; i++) {
            this.dummy.position.set(0, -500, 0);
            this.dummy.scale.set(0,0,0); // Ensure invisible
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
            this.lives[i] = 0;
        }
        
        scene.add(this.mesh);
    }

    spawn(pos, vel, colorHex, life, gravity = 0, size = 1.0, grow = 0, bounce = 0, rotVel = null, drag = 0, jitter = 0, delay = 0, type = 0) {
        let idx = this.count % this.maxParticles;
        
        // Update High Water Mark for loop optimization
        if (!this.hasWrapped) {
            this.highWaterMark = Math.max(this.highWaterMark, idx + 1);
            if (this.count >= this.maxParticles) this.hasWrapped = true;
        }

        this.count++;

        const i3 = idx * 3;
        this.positions[i3] = pos.x;
        this.positions[i3 + 1] = pos.y;
        this.positions[i3 + 2] = pos.z;

        this.velocities[i3] = vel.x;
        this.velocities[i3 + 1] = vel.y;
        this.velocities[i3 + 2] = vel.z;

        // Random initial rotation
        this.rotations[i3] = Math.random() * Math.PI * 2;
        this.rotations[i3 + 1] = Math.random() * Math.PI * 2;
        this.rotations[i3 + 2] = Math.random() * Math.PI * 2;

        if (rotVel) {
            this.rotVelocities[i3] = rotVel.x;
            this.rotVelocities[i3 + 1] = rotVel.y;
            this.rotVelocities[i3 + 2] = rotVel.z;
        } else {
            this.rotVelocities[i3] = 0;
            this.rotVelocities[i3 + 1] = 0;
            this.rotVelocities[i3 + 2] = 0;
        }

        this.lives[idx] = life;
        this.gravities[idx] = gravity;
        this.scales[idx] = size;
        this.baseScales[idx] = size; // Remember base size
        this.growRates[idx] = grow;
        this.bounciness[idx] = bounce;
        this.drags[idx] = drag;
        this.jitters[idx] = jitter;
        this.delays[idx] = delay; // Set delay
        this.states[idx] = 0; // Reset state
        this.types[idx] = type; // Set Type

        // Set Color (OPTIMIZED: Use static color object)
        _ptColor.set(colorHex);
        this.mesh.setColorAt(idx, _ptColor);
        if (this.mesh.instanceColor) this.mesh.instanceColor.needsUpdate = true;
        
        // Initial Matrix Update
        this.dummy.position.copy(pos);
        this.dummy.rotation.set(this.rotations[i3], this.rotations[i3+1], this.rotations[i3+2]);
        this.dummy.scale.set(size, size, size);
        this.dummy.updateMatrix();
        this.mesh.setMatrixAt(idx, this.dummy.matrix);
        this.mesh.instanceMatrix.needsUpdate = true;
    }

    update(dt, targetPos = null, onCollect = null) {
        let active = false;
        
        // Optimization: Only iterate up to the highest active particle index if we haven't wrapped buffer yet
        const limit = this.hasWrapped ? this.maxParticles : this.highWaterMark;
        
        const magnetRadiusSq = 20 * 20; 
        const collectRadiusSq = 3.0 * 3.0; 

        for (let i = 0; i < limit; i++) {
            if (this.lives[i] > 0) {
                active = true;
                this.lives[i] -= dt;
                
                if (this.delays[i] > 0) {
                    this.delays[i] -= dt;
                }

                if (this.lives[i] <= 0) {
                    this.kill(i);
                    continue;
                }

                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                if (this.states[i] === 2) {
                    this.scales[i] -= dt * 15.0; 
                    if (this.scales[i] <= 0) {
                        this.kill(i);
                        continue;
                    }
                    if (targetPos) {
                        this.positions[ix] += (targetPos.x - this.positions[ix]) * 30 * dt;
                        this.positions[iy] += ((targetPos.y + 1.0) - this.positions[iy]) * 30 * dt;
                        this.positions[iz] += (targetPos.z - this.positions[iz]) * 30 * dt;
                    }
                } 
                else {
                    let isMagnetized = false;

                    if (targetPos && this.delays[i] <= 0) {
                        const dx = targetPos.x - this.positions[ix];
                        const dy = (targetPos.y + 1.5) - this.positions[iy]; 
                        const dz = targetPos.z - this.positions[iz];
                        const distSq = dx*dx + dy*dy + dz*dz;

                        if (distSq < collectRadiusSq) {
                            if (this.states[i] !== 2) {
                                this.states[i] = 2; 
                                if (onCollect) {
                                    const tempColor = new THREE.Color();
                                    if (this.mesh.instanceColor) this.mesh.getColorAt(i, tempColor);
                                    onCollect(tempColor, this.baseScales[i], this.types[i]);
                                }
                            }
                            continue;
                        }

                        if (distSq < magnetRadiusSq) {
                            isMagnetized = true;
                            const dist = Math.sqrt(distSq);
                            
                            const nx = dx / dist;
                            const ny = dy / dist;
                            const nz = dz / dist;

                            const tx = -nz;
                            const ty = 0;
                            const tz = nx;

                            const approachSpeed = 40.0 + (1000.0 / (dist + 1.0)); 
                            
                            let orbitSpeed = 30.0;
                            if (dist < 5.0) orbitSpeed = 0; 
                            
                            const desiredVx = (nx * approachSpeed) + (tx * orbitSpeed);
                            const desiredVy = (ny * approachSpeed);
                            const desiredVz = (nz * approachSpeed) + (tz * orbitSpeed);
                            
                            const steerFactor = 10.0 * dt;
                            
                            this.velocities[ix] += (desiredVx - this.velocities[ix]) * steerFactor;
                            this.velocities[iy] += (desiredVy - this.velocities[iy]) * steerFactor;
                            this.velocities[iz] += (desiredVz - this.velocities[iz]) * steerFactor;
                        }
                    }

                    if (!isMagnetized) {
                        this.velocities[iy] -= this.gravities[i] * dt;
                        
                        if (this.drags[i] > 0) {
                            const dragFactor = 1.0 - (this.drags[i] * dt);
                            this.velocities[ix] *= dragFactor;
                            this.velocities[iy] *= dragFactor;
                            this.velocities[iz] *= dragFactor;
                        }
                    } else {
                        const magDrag = 1.0 - (2.0 * dt);
                        this.velocities[ix] *= magDrag;
                        this.velocities[iy] *= magDrag;
                        this.velocities[iz] *= magDrag;
                    }

                    this.positions[ix] += this.velocities[ix] * dt;
                    this.positions[iy] += this.velocities[iy] * dt;
                    this.positions[iz] += this.velocities[iz] * dt;

                    if (!isMagnetized && this.positions[iy] < 0.3) { 
                        this.positions[iy] = 0.3;
                        
                        if (this.bounciness[i] > 0) {
                            const bounceRand = 0.8 + Math.random() * 0.4; 
                            this.velocities[iy] *= -this.bounciness[i] * bounceRand; 
                            
                            const groundFriction = 0.90; 
                            this.velocities[ix] *= groundFriction;
                            this.velocities[iz] *= groundFriction;
                            
                            this.rotVelocities[ix] *= 0.8;
                            this.rotVelocities[iz] *= 0.8;
                            
                            if (Math.abs(this.velocities[iy]) < 1.0) {
                                this.velocities[iy] = 0;
                            }
                        } else {
                            this.velocities[iy] = 0;
                        }
                    }

                    this.rotations[ix] += this.rotVelocities[ix] * dt;
                    this.rotations[iy] += this.rotVelocities[iy] * dt;
                    this.rotations[iz] += this.rotVelocities[iz] * dt;

                    if (this.growRates[i] !== 0) {
                        this.baseScales[i] += this.growRates[i] * dt;
                    }
                    
                    let visualX = this.positions[ix];
                    let visualY = this.positions[iy];
                    let visualZ = this.positions[iz];
                    
                    if (this.jitters[i] > 0) {
                        const j = this.jitters[i];
                        visualX += (Math.random() - 0.5) * j;
                        visualY += (Math.random() - 0.5) * j;
                        visualZ += (Math.random() - 0.5) * j;
                        
                        const plasmaPulse = 1.0 + Math.sin(Date.now() * 0.02 + i * 13.0) * 0.3 + Math.cos(Date.now() * 0.05 + i) * 0.2;
                        this.scales[i] = this.baseScales[i] * plasmaPulse;
                    } else {
                        const pulse = 1.0 + Math.sin(Date.now() * 0.015 + i) * 0.3;
                        this.scales[i] = this.baseScales[i] * pulse;
                    }
                    
                    if (!isMagnetized && Math.abs(this.velocities[iy]) < 0.5 && this.positions[iy] <= 0.4) {
                        visualY += Math.sin(Date.now() * 0.005 + i) * 0.3; 
                    }
                    
                    this.dummy.position.set(visualX, visualY, visualZ);
                }

                this.dummy.rotation.set(this.rotations[ix], this.rotations[iy], this.rotations[iz]);
                
                const speedSq = this.velocities[ix]*this.velocities[ix] + this.velocities[iy]*this.velocities[iy] + this.velocities[iz]*this.velocities[iz];
                let stretch = 1.0;
                if (speedSq > 50.0) { 
                    stretch = 1.0 + (Math.sqrt(speedSq) * 0.03); 
                }
                
                this.dummy.scale.set(this.scales[i] * (1/Math.sqrt(stretch)), this.scales[i] * stretch, this.scales[i] * (1/Math.sqrt(stretch)));
                
                if (stretch > 1.1) {
                    // Reuse static vectors
                    _ptVel.set(this.velocities[ix], this.velocities[iy], this.velocities[iz]).normalize();
                    _ptQuat.setFromUnitVectors(_ptUp, _ptVel);
                    this.dummy.quaternion.copy(_ptQuat);
                }
                
                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(i, this.dummy.matrix);
            }
        }

        if (active) {
            this.mesh.instanceMatrix.needsUpdate = true;
            
            // OPTIMIZATION: Update Bounding Sphere to center on player for accurate Frustum Culling
            if (targetPos) {
                this.mesh.geometry.boundingSphere.center.copy(targetPos);
                this.mesh.geometry.boundingSphere.radius = 100; 
            }
        }
    }
    
    kill(index) {
        this.lives[index] = 0;
        this.dummy.position.set(0, -500, 0);
        this.dummy.scale.set(0,0,0); 
        this.dummy.updateMatrix();
        this.mesh.setMatrixAt(index, this.dummy.matrix);
        this.mesh.instanceMatrix.needsUpdate = true; 
    }
}

class WeatherSystem {
    constructor(scene, count = 2000) {
        this.count = count;
        this.mode = 'SNOW'; 
        
        const geo = new THREE.TetrahedronGeometry(0.1, 0); 
        
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        this.mesh = new THREE.InstancedMesh(geo, mat, count);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        
        this.mesh.frustumCulled = true;
        this.mesh.geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(), 100);
        
        scene.add(this.mesh);
        
        this.dummy = new THREE.Object3D();
        this.positions = new Float32Array(count * 3);
        this.velocities = new Float32Array(count * 3);
        
        this.setMode('SNOW');
    }
    
    setMode(mode) {
        this.mode = mode;
        let color = 0xffffff;
        let opacity = 0.8;
        
        switch(mode) {
            case 'RAIN': 
                color = 0x88aaff; 
                opacity = 0.6;
                break;
            case 'SAND': 
                color = 0xffaa00; 
                opacity = 0.9;
                break;
            case 'VOID': 
                color = 0xaa00ff; 
                opacity = 0.5;
                break;
            case 'SNOW':
            default:
                color = 0xffffff;
                opacity = 0.8;
                break;
        }
        
        this.mesh.material.color.setHex(color);
        this.mesh.material.opacity = opacity;
        
        for(let i=0; i<this.count; i++) {
            this.resetParticle(i, true);
        }
    }
    
    resetParticle(i, fullReset = false) {
        const range = 100;
        
        this.positions[i*3] = (Math.random() - 0.5) * range * 2;
        this.positions[i*3+1] = Math.random() * 50;
        this.positions[i*3+2] = (Math.random() - 0.5) * range * 2;
        
        if (this.mode === 'RAIN') {
            this.velocities[i*3] = (Math.random() - 0.5) * 2;
            this.velocities[i*3+1] = -(40 + Math.random() * 20); 
            this.velocities[i*3+2] = (Math.random() - 0.5) * 2;
            this.dummy.scale.set(0.5, 8.0, 0.5);
        } 
        else if (this.mode === 'SAND') {
            this.velocities[i*3] = 30 + Math.random() * 20; 
            this.velocities[i*3+1] = (Math.random() - 0.5) * 5;
            this.velocities[i*3+2] = (Math.random() - 0.5) * 10;
            this.dummy.scale.set(0.8, 0.8, 0.8);
        }
        else if (this.mode === 'VOID') {
            this.velocities[i*3] = (Math.random() - 0.5) * 2;
            this.velocities[i*3+1] = (Math.random() - 0.5) * 2; 
            this.velocities[i*3+2] = (Math.random() - 0.5) * 2;
            this.dummy.scale.set(1.5, 1.5, 1.5);
        }
        else { 
            this.velocities[i*3] = (Math.random() - 0.5) * 5;
            this.velocities[i*3+1] = -(2 + Math.random() * 3); 
            this.velocities[i*3+2] = (Math.random() - 0.5) * 5;
            this.dummy.scale.set(1, 1, 1);
        }
        
        if (fullReset) {
            this.dummy.position.set(this.positions[i*3], this.positions[i*3+1], this.positions[i*3+2]);
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
        }
    }
    
    update(dt, playerPos) {
        if (!playerPos) return;
        
        this.mesh.geometry.boundingSphere.center.copy(playerPos);
        
        const range = 80;
        
        for(let i=0; i<this.count; i++) {
            const ix = i*3;
            const iy = i*3+1;
            const iz = i*3+2;
            
            this.positions[ix] += this.velocities[ix] * dt;
            this.positions[iy] += this.velocities[iy] * dt;
            this.positions[iz] += this.velocities[iz] * dt;
            
            let wrapped = false;
            
            if (this.positions[ix] < playerPos.x - range) { this.positions[ix] += range * 2; wrapped = true; }
            if (this.positions[ix] > playerPos.x + range) { this.positions[ix] -= range * 2; wrapped = true; }
            
            if (this.positions[iy] < playerPos.y - 20) { this.positions[iy] += 60; wrapped = true; }
            if (this.positions[iy] > playerPos.y + 40) { this.positions[iy] -= 60; wrapped = true; }
            
            if (this.positions[iz] < playerPos.z - range) { this.positions[iz] += range * 2; wrapped = true; }
            if (this.positions[iz] > playerPos.z + range) { this.positions[iz] -= range * 2; wrapped = true; }
            
            if (wrapped) {
                if (this.mode === 'SAND') {
                    this.positions[iy] = playerPos.y + (Math.random() - 0.5) * 40;
                }
            }
            
            this.dummy.position.set(this.positions[ix], this.positions[iy], this.positions[iz]);
            
            if (this.mode !== 'RAIN') {
                this.dummy.rotation.x += dt;
                this.dummy.rotation.z += dt;
            } else {
                this.dummy.rotation.set(0,0,0.1); 
            }
            
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);
        }
        this.mesh.instanceMatrix.needsUpdate = true;
    }
}</script> 
    <script>/**
 * AUDIO SYSTEM - FILE BASED IMPLEMENTATION
 * Implements the complete sound manifest provided by the user.
 * Handles loading, decoding, and playback of external audio assets.
 * UPDATED: Added BGM Support with Crossfading.
 * UPDATED: Rebalanced Audio Mix (Louder Music, Softer SFX).
 * UPDATED: Added Anubis Theme.
 * UPDATED: Added Lock-Off Sound.
 * FIXED: Audio Context resume on user interaction.
 */

const SOUND_FILES = {
    // --- BGM ---
    "bgm_standard": "https://files.catbox.moe/soip1t.mp3",
    "bgm_boss": "https://files.catbox.moe/koldqe.mp3",
    "bgm_anubis": "https://files.catbox.moe/35oj1g.mp3", 

    // --- NEW USER ASSETS (FROM IMAGE) ---
    "Sabre1": "https://files.catbox.moe/49g9xj.mp3", 
    "Sabre2": "https://files.catbox.moe/zsxozo.mp3", 
    "Sabre3": "https://files.catbox.moe/mvuf6h.mp3", 
    "Homing_travel": "https://files.catbox.moe/n9iqnk.mp3", 
    "lockon_set": "https://files.catbox.moe/fa7a8a.mp3", 
    "Lockon_switch": "https://files.catbox.moe/xbmdc5.mp3", 
    "missile_deploy": "https://files.catbox.moe/6il623.mp3", 
    "Slashclimb": "https://files.catbox.moe/mcjk87.mp3", 
    "Drone_explode": "https://files.catbox.moe/4fsb3d.mp3", 
    "dash_new": "https://files.catbox.moe/6eymr8.mp3", 
    "Tele_": "https://files.catbox.moe/yw0ngd.mp3", 
    "metal_scrape": "https://files.catbox.moe/idvqzl.mp3", 

    // --- LEGACY / UI ASSETS ---
    "Combat_MechDroneEnemy_OnEvent_PSMK": "https://files.catbox.moe/kkcg70.mp3", // Flesh hit
    "Physics_StaticGroup_OnEvent_RQK0": "https://files.catbox.moe/20wqm9.mp3", // Wall hit / Land
    "Physics_ExplosiveBarrel_OnEvent_DE9D": "https://files.catbox.moe/wdxmed.mp3", // Heavy Impact
    "Combat_PlayerWeapon_OnEvent_67DJ": "https://files.catbox.moe/ve3zlt.mp3", // Shotgun
    "Combat_PlayerWeapon_OnEvent_89PI": "https://files.catbox.moe/awsvoq.mp3", // Reload
    "UI_btnswitch_OnClick_BBEU": "https://files.catbox.moe/sojfe8.mp3", // Switch / Lock Off
    "UI_damageparry_OnMount_S6ST": "https://files.catbox.moe/n2lkxz.mp3", // Block/Parry
    "Flux_GameEngine_OnEffectSt_BA5Q": "https://files.catbox.moe/w5n8k9.mp3", // Charge
    "UI_loadingscreen_OnClick_7K2W": "https://files.catbox.moe/jgdsmh.mp3", // Startup
    "UI_gameoverscreen_OnMount_4U7H": "https://files.catbox.moe/uas5sx.mp3", // Death
    "UI_btnjump_OnClick_0GBP": "https://files.catbox.moe/fs2c1p.mp3", // UI Click
    "UI_FloatingText_OnMount_KUPV": "https://files.catbox.moe/tpzzgj.mp3", // UI Hover
    "Physics_Player_OnEvent_ZF5G": "https://files.catbox.moe/ko1klv.mp3" // Legacy Jump/Step
};

// Map logical game events to specific sound files
const SOUND_MAP = {
    'slash_light': 'Sabre1',
    'slash_heavy': 'Sabre2',
    'slash_finisher': 'Sabre3',
    'launcher': 'Slashclimb',
    'dash': 'dash_new',
    'teleport': 'Tele_',
    'lock': 'lockon_set',
    'lock_switch': 'Lockon_switch',
    'lock_off': 'UI_btnswitch_OnClick_BBEU', // Distinct sound for lock off
    'laser_fire': 'missile_deploy', 
    'laser_travel': 'Homing_travel',
    'drone_death': 'Drone_explode',
    'run_loop': 'metal_scrape',
    'jump': 'Physics_Player_OnEvent_ZF5G', 
    
    // Legacy Mappings
    'shotgun': 'Combat_PlayerWeapon_OnEvent_67DJ',
    'wall_run': 'Physics_StaticGroup_OnEvent_RQK0',
    'land_heavy': 'Physics_ExplosiveBarrel_OnEvent_DE9D',
    'hit_flesh': 'Combat_MechDroneEnemy_OnEvent_PSMK',
    'hit_wall': 'Physics_StaticGroup_OnEvent_RQK0',
    'switch': 'UI_btnswitch_OnClick_BBEU',
    'reload': 'Combat_PlayerWeapon_OnEvent_89PI',
    'block': 'UI_damageparry_OnMount_S6ST',
    'charge': 'Flux_GameEngine_OnEffectSt_BA5Q',
    'massive_impact': 'Physics_ExplosiveBarrel_OnEvent_DE9D',
    'startup': 'UI_loadingscreen_OnClick_7K2W',
    'death': 'UI_gameoverscreen_OnMount_4U7H',
    'ui_hover': 'UI_FloatingText_OnMount_KUPV',
    'ui_click': 'UI_btnjump_OnClick_0GBP',
    'step': 'Physics_Player_OnEvent_ZF5G'
};

class AudioSystem {
    constructor() {
        const AudioCtor = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioCtor();
        
        // --- MASTER CHAIN ---
        this.out = this.ctx.destination;

        // 1. Master Compressor (Gentle)
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -20;
        this.compressor.knee.value = 40;
        this.compressor.ratio.value = 8;
        this.compressor.attack.value = 0.01;
        this.compressor.release.value = 0.25;
        
        // 2. Global Lowpass (Softener)
        this.globalFilter = this.ctx.createBiquadFilter();
        this.globalFilter.type = 'lowpass';
        this.globalFilter.frequency.value = 12000; // Cut extreme highs
        this.globalFilter.Q.value = 0.5;

        // 3. Master Gain
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.8; 

        // Chain
        this.compressor.connect(this.globalFilter);
        this.globalFilter.connect(this.masterGain);
        this.masterGain.connect(this.out);

        this.enabled = false;
        this.isMuted = false;
        
        this.buffers = {};
        this.activeLoops = {}; 
        
        // BGM State
        this.currentBgmSource = null;
        this.currentBgmGain = null;
        this.currentBgmKey = null;
        
        // Resume context on user interaction
        const resumeAudio = () => {
            if (this.ctx.state === 'suspended') {
                this.ctx.resume().then(() => {
                    console.log("AudioSystem: Context Resumed");
                    // Remove listeners once resumed
                    document.removeEventListener('click', resumeAudio);
                    document.removeEventListener('touchstart', resumeAudio);
                    document.removeEventListener('keydown', resumeAudio);
                });
            }
        };
        
        document.addEventListener('click', resumeAudio);
        document.addEventListener('touchstart', resumeAudio);
        document.addEventListener('keydown', resumeAudio);
    }

    async init() {
        console.log("AudioSystem: Initializing...");
        // Try to resume immediately if possible (e.g. triggered by button click)
        if (this.ctx.state === 'suspended') {
            try {
                await this.ctx.resume();
            } catch (e) {
                console.warn("AudioSystem: Auto-resume failed, waiting for interaction.");
            }
        }
        
        await this.loadSounds();
        
        this.enabled = true;
        console.log(`AudioSystem: ONLINE (State: ${this.ctx.state})`);
        
        this.play('startup');
    }
    
    async loadSounds() {
        const keys = Object.keys(SOUND_FILES);
        const total = keys.length;
        console.log(`AudioSystem: Loading ${total} sound files...`);
        
        const promises = keys.map(async (key) => {
            try {
                const response = await fetch(SOUND_FILES[key]);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                this.buffers[key] = audioBuffer;
            } catch (e) {
                console.warn(`AudioSystem: Failed to load ${key}:`, e);
            }
        });
        
        await Promise.all(promises);
        console.log("AudioSystem: All sounds loaded.");
    }

    setSlowMo(scale) {
        if (!this.enabled || !this.globalFilter) return;
        const targetFreq = 200 + (Math.pow(scale, 2) * 11800);
        this.globalFilter.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1);
    }

    play(sfxName, variation = true) {
        if (!this.enabled || this.isMuted) return;
        // Double check context state
        if (this.ctx.state === 'suspended') this.ctx.resume();

        const fileKey = SOUND_MAP[sfxName];
        if (fileKey && this.buffers[fileKey]) {
            this.playBuffer(this.buffers[fileKey], variation);
            return;
        }
        
        if (this.buffers[sfxName]) {
            this.playBuffer(this.buffers[sfxName], variation);
            return;
        }

        this.playSynthFallback(sfxName, variation);
    }
    
    playBuffer(buffer, variation) {
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        
        if (variation) {
            const detune = (Math.random() * 200) - 100; 
            source.detune.value = detune;
        }
        
        const gain = this.ctx.createGain();
        gain.gain.value = 0.4 + (Math.random() * 0.2); 
        
        source.connect(gain);
        gain.connect(this.compressor);
        
        source.start(0);
    }

    playBGM(key, fadeTime = 1.0) {
        if (!this.enabled || this.isMuted) return;
        if (this.currentBgmKey === key) return; 

        console.log(`AudioSystem: Switching BGM to ${key}`);

        if (this.currentBgmSource && this.currentBgmGain) {
            const oldGain = this.currentBgmGain;
            const oldSource = this.currentBgmSource;
            const t = this.ctx.currentTime;
            
            oldGain.gain.cancelScheduledValues(t);
            oldGain.gain.setValueAtTime(oldGain.gain.value, t);
            oldGain.gain.linearRampToValueAtTime(0, t + fadeTime);
            
            oldSource.stop(t + fadeTime);
        }

        const buffer = this.buffers[key];
        if (!buffer) {
            console.warn(`AudioSystem: BGM ${key} not found/loaded.`);
            this.currentBgmKey = null;
            this.currentBgmSource = null;
            this.currentBgmGain = null;
            return;
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;

        const gain = this.ctx.createGain();
        gain.gain.value = 0; 

        source.connect(gain);
        gain.connect(this.masterGain); 

        source.start(0);

        const t = this.ctx.currentTime;
        gain.gain.linearRampToValueAtTime(0.8, t + fadeTime); 

        this.currentBgmSource = source;
        this.currentBgmGain = gain;
        this.currentBgmKey = key;
    }

    startLoop(sfxName) {
        if (!this.enabled || this.isMuted) return;
        if (this.activeLoops[sfxName]) return; 

        const fileKey = SOUND_MAP[sfxName];
        if (!fileKey || !this.buffers[fileKey]) return;

        const source = this.ctx.createBufferSource();
        source.buffer = this.buffers[fileKey];
        source.loop = true;

        const gain = this.ctx.createGain();
        gain.gain.value = 0.2; 

        source.connect(gain);
        gain.connect(this.compressor);
        source.start(0);

        this.activeLoops[sfxName] = { source, gain };
    }

    stopLoop(sfxName) {
        if (this.activeLoops[sfxName]) {
            const { source, gain } = this.activeLoops[sfxName];
            
            const t = this.ctx.currentTime;
            gain.gain.setValueAtTime(gain.gain.value, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            
            source.stop(t + 0.1);
            delete this.activeLoops[sfxName];
        }
    }

    playSynthFallback(sfxName, variation) {
        const t = this.ctx.currentTime;
        try {
            switch (sfxName) {
                case 'shotgun': 
                case 'hit_wall':
                case 'hit_flesh':
                    this.synthNoise(t); 
                    break;
                case 'jump': 
                case 'dash':
                    this.synthTone(t, 150, 0.1); 
                    break;
                case 'switch': 
                case 'reload':
                    this.synthTone(t, 800, 0.05); 
                    break;
            }
        } catch (e) {
        }
    }
    
    synthNoise(t) {
        const bufferSize = this.ctx.sampleRate * 0.2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.3, t); 
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
        src.connect(g);
        g.connect(this.compressor);
        src.start(t);
    }
    
    synthTone(t, freq, dur) {
        const osc = this.ctx.createOscillator();
        osc.frequency.setValueAtTime(freq, t);
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.1, t); 
        g.gain.linearRampToValueAtTime(0, t + dur);
        osc.connect(g);
        g.connect(this.compressor);
        osc.start(t);
        osc.stop(t + dur);
    }
}</script> 
    <script>/**
 * INPUT SYSTEM - DEFERRED PROCESSING OPTIMIZATION
 * Decoupled Visuals + Aggressive Browser Default Prevention
 * FIXED: Moved heavy math from touchmove handler to game loop to prevent render starvation.
 * FIXED: Implemented GPU acceleration for joystick visuals to prevent main thread blocking.
 */

const ACT = {
    JUMP: 'jump',
    DASH: 'dash',
    ATTACK: 'attack',
    BLOCK: 'block',
    SWITCH: 'switch',
    RELOAD: 'reload',
    STYLE: 'style',
    LOCK: 'lock',
    CAM_SWITCH: 'cam-switch',
    GYRO: 'gyro',
    TECH: 'tech',
    MISSILE: 'missile'
};

// Expose globally
window.ACT = ACT;

// Static reusable object for gyro return
const _gyroDelta = { x: 0, y: 0 };

class InputSystem {
    constructor() {
        // OPTIMIZATION: Create these ONCE. Never reassign them.
        this.moveVector = { x: 0, y: 0 };
        this.lookVector = { x: 0, y: 0 };
        this.gyroVector = { x: 0, y: 0 };
        
        this.gyroEnabled = false;
        this.gyroRatcheting = false;
        
        this.lastGyro = { alpha: 0, beta: 0, gamma: 0 };
        this.gyroFilter = { x: 0, y: 0 };
        this.gyroAlpha = 0.5;
        
        this.actions = {
            [ACT.JUMP]: false,
            [ACT.DASH]: false,
            [ACT.ATTACK]: false,
            [ACT.BLOCK]: false,
            [ACT.SWITCH]: false,
            [ACT.RELOAD]: false,
            [ACT.STYLE]: false,
            [ACT.LOCK]: false, 
            [ACT.CAM_SWITCH]: false,
            [ACT.GYRO]: false,
            [ACT.TECH]: false, 
            [ACT.MISSILE]: false
        };

        this.controlsZone = document.getElementById('controls');
        
        // Visual Cache for Buttons
        this.buttonElements = {};
        
        // Left Joystick
        this.joyLeft = {
            zone: document.getElementById('joystick-zone-left'),
            knob: document.getElementById('joystick-knob-left'),
            center: { x: 0, y: 0 },
            touchId: null,
            active: false,
            rawX: 0, rawY: 0, // NEW: Raw input storage
            visualX: 0, visualY: 0,
            lastVisualX: 0, lastVisualY: 0, // Throttling
            dirty: false
        };

        // Right Joystick
        this.joyRight = {
            zone: document.getElementById('joystick-zone-right'),
            knob: document.getElementById('joystick-knob-right'),
            center: { x: 0, y: 0 },
            touchId: null,
            active: false,
            rawX: 0, rawY: 0, // NEW: Raw input storage
            visualX: 0, visualY: 0,
            lastVisualX: 0, lastVisualY: 0, // Throttling
            dirty: false
        };
        
        this.swipeTracker = {
            active: false, touchId: null, startX: 0, startY: 0, startTime: 0
        };

        this.maxRadius = 40;
        this.swipeThreshold = 30;
        this.swipeTimeLimit = 300;

        this.isEditMode = false;
        this.draggedElement = null;
        this.dragOffset = { x: 0, y: 0 };

        if (this.controlsZone) {
            this.initTouchControls();
        }
        
        this.initButtons();
        this.initKeyboard();
        this.initGlobalPrevention(); 
        
        this.handleOrientation = this.handleOrientation.bind(this);
    }

    initGlobalPrevention() {
        // Prevents "Hold to Select" context menu
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }, { passive: false });
    }

    // Called by Game Loop: Updates Logic AND Visuals based on Raw Input
    // This runs at 60fps (synced with render), not 120fps (synced with touch)
    updateVisuals() {
        // Process Left Joystick Math
        if (this.joyLeft.active && this.joyLeft.dirty) {
            this.processJoystickMath(this.joyLeft, this.moveVector);
            
            // Throttling & GPU Optimization
            const dx = Math.abs(this.joyLeft.visualX - this.joyLeft.lastVisualX);
            const dy = Math.abs(this.joyLeft.visualY - this.joyLeft.lastVisualY);
            
            if (dx > 0.5 || dy > 0.5) {
                // Use translate3d for GPU acceleration
                this.joyLeft.knob.style.transform = `translate3d(${this.joyLeft.visualX}px, ${this.joyLeft.visualY}px, 0)`;
                this.joyLeft.lastVisualX = this.joyLeft.visualX;
                this.joyLeft.lastVisualY = this.joyLeft.visualY;
            }
            this.joyLeft.dirty = false; // Reset flag
        }
        
        // Process Right Joystick Math
        if (this.joyRight.active && this.joyRight.dirty) {
            this.processJoystickMath(this.joyRight, this.lookVector);
            
            // Throttling & GPU Optimization
            const dx = Math.abs(this.joyRight.visualX - this.joyRight.lastVisualX);
            const dy = Math.abs(this.joyRight.visualY - this.joyRight.lastVisualY);
            
            if (dx > 0.5 || dy > 0.5) {
                // Use translate3d for GPU acceleration
                this.joyRight.knob.style.transform = `translate3d(${this.joyRight.visualX}px, ${this.joyRight.visualY}px, 0)`;
                this.joyRight.lastVisualX = this.joyRight.visualX;
                this.joyRight.lastVisualY = this.joyRight.visualY;
            }
            this.joyRight.dirty = false; // Reset flag
        }

        // Buttons
        for (const action in this.buttonElements) {
            const btn = this.buttonElements[action];
            if (!btn) continue;
            
            const isPressed = this.actions[action];
            // Only touch DOM if state changed
            if (btn.dataset.pressed !== String(isPressed)) {
                // Use scale3d for GPU acceleration
                btn.style.transform = isPressed ? 'scale3d(0.9, 0.9, 1)' : 'scale3d(1.0, 1.0, 1)';
                btn.dataset.pressed = String(isPressed); 
            }
        }
    }
    
    // NEW: Heavy math moved here, called only once per frame
    processJoystickMath(joy, outVector) {
        // NAN PROTECTION
        if (!joy.center || isNaN(joy.center.x) || isNaN(joy.center.y)) return;
        if (isNaN(joy.rawX) || isNaN(joy.rawY)) return;

        let dx = joy.rawX - joy.center.x;
        let dy = joy.rawY - joy.center.y;
        
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > this.maxRadius) {
            const angle = Math.atan2(dy, dx);
            dx = Math.cos(angle) * this.maxRadius;
            dy = Math.sin(angle) * this.maxRadius;
        }

        joy.visualX = dx;
        joy.visualY = dy;

        // DIVISION PROTECTION
        let xNorm = 0;
        let yNorm = 0;
        
        if (this.maxRadius > 0) {
            xNorm = dx / this.maxRadius;
            yNorm = -(dy / this.maxRadius);
        }

        // FINAL NAN CHECK
        if (isNaN(xNorm)) xNorm = 0;
        if (isNaN(yNorm)) yNorm = 0;

        // OPTIMIZATION: Mutate in place
        outVector.x = xNorm;
        outVector.y = yNorm;
    }

    setEditMode(enabled) {
        this.isEditMode = enabled;
        document.body.classList.toggle('ui-edit-mode', enabled);
    }

    initTouchControls() {
        this.controlsZone.addEventListener('touchstart', (e) => {
            if (this.isEditMode) return;
            e.preventDefault(); 
            for (let i = 0; i < e.changedTouches.length; i++) {
                this.handleTouchStart(e.changedTouches[i]);
            }
        }, { passive: false });

        this.controlsZone.addEventListener('touchmove', (e) => {
            if (this.isEditMode) {
                e.preventDefault();
                if (this.draggedElement) {
                    const touch = e.changedTouches[0];
                    this.handleDragMove(touch.clientX, touch.clientY);
                }
                return;
            }
            e.preventDefault(); 
            for (let i = 0; i < e.changedTouches.length; i++) {
                this.handleTouchMove(e.changedTouches[i]);
            }
        }, { passive: false });

        const endTouch = (e) => {
            if (this.isEditMode) {
                e.preventDefault();
                this.draggedElement = null;
                return;
            }
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                this.handleTouchEnd(e.changedTouches[i]);
            }
        };

        this.controlsZone.addEventListener('touchend', endTouch);
        this.controlsZone.addEventListener('touchcancel', endTouch);
        
        // Mouse Dragging for Edit Mode
        window.addEventListener('mousemove', (e) => {
            if (this.isEditMode && this.draggedElement) {
                e.preventDefault();
                this.handleDragMove(e.clientX, e.clientY);
            }
        });
        window.addEventListener('mouseup', () => {
            if (this.isEditMode) this.draggedElement = null;
        });
    }

    handleDragMove(clientX, clientY) {
        if (!this.draggedElement) return;
        const x = clientX - this.dragOffset.x;
        const y = clientY - this.dragOffset.y;
        this.draggedElement.style.left = `${x}px`;
        this.draggedElement.style.top = `${y}px`;
        this.draggedElement.style.bottom = 'auto';
        this.draggedElement.style.right = 'auto';
    }

    handleTouchStart(touch) {
        if (touch.target && touch.target.classList.contains('btn')) return;

        const x = touch.clientX;
        const y = touch.clientY;
        const width = window.innerWidth;

        // SAFEGUARD: Ensure valid coordinates
        if (isNaN(x) || isNaN(y)) return;

        if (x < width / 2) {
            if (!this.joyLeft.active) {
                this.joyLeft.active = true;
                this.joyLeft.touchId = touch.identifier;
                this.joyLeft.center = { x, y };
                this.joyLeft.zone.style.left = `${x}px`;
                this.joyLeft.zone.style.top = `${y}px`;
                this.joyLeft.zone.classList.remove('hidden');
                
                // Initialize raw values
                this.joyLeft.rawX = x;
                this.joyLeft.rawY = y;
                this.joyLeft.visualX = 0;
                this.joyLeft.visualY = 0;
                this.joyLeft.lastVisualX = 0;
                this.joyLeft.lastVisualY = 0;
                this.joyLeft.knob.style.transform = 'translate3d(0, 0, 0)'; // Reset visual
                this.joyLeft.dirty = true;
                
                // OPTIMIZATION: Reset in place
                this.moveVector.x = 0;
                this.moveVector.y = 0;
            }
        } else {
            if (!this.joyRight.active) {
                this.joyRight.active = true;
                this.joyRight.touchId = touch.identifier;
                this.joyRight.center = { x, y };
                this.joyRight.zone.style.left = `${x}px`;
                this.joyRight.zone.style.top = `${y}px`;
                this.joyRight.zone.classList.remove('hidden');
                
                // Initialize raw values
                this.joyRight.rawX = x;
                this.joyRight.rawY = y;
                this.joyRight.visualX = 0;
                this.joyRight.visualY = 0;
                this.joyRight.lastVisualX = 0;
                this.joyRight.lastVisualY = 0;
                this.joyRight.knob.style.transform = 'translate3d(0, 0, 0)'; // Reset visual
                this.joyRight.dirty = true;
                
                // OPTIMIZATION: Reset in place
                this.lookVector.x = 0;
                this.lookVector.y = 0;
                
                this.swipeTracker.active = true;
                this.swipeTracker.touchId = touch.identifier;
                this.swipeTracker.startX = x;
                this.swipeTracker.startY = y;
                this.swipeTracker.startTime = Date.now();
            }
        }
    }

    handleTouchMove(touch) {
        // OPTIMIZATION: Only store raw data. Do NOT calculate here.
        if (touch.identifier === this.joyLeft.touchId) {
            this.joyLeft.rawX = touch.clientX;
            this.joyLeft.rawY = touch.clientY;
            this.joyLeft.dirty = true;
        } else if (touch.identifier === this.joyRight.touchId) {
            this.joyRight.rawX = touch.clientX;
            this.joyRight.rawY = touch.clientY;
            this.joyRight.dirty = true;
        }
    }

    handleTouchEnd(touch) {
        if (touch.identifier === this.joyLeft.touchId) {
            this.joyLeft.active = false;
            this.joyLeft.touchId = null;
            this.joyLeft.zone.classList.add('hidden');
            
            // OPTIMIZATION: Reset in place
            this.moveVector.x = 0;
            this.moveVector.y = 0;
            
        } else if (touch.identifier === this.joyRight.touchId) {
            if (this.swipeTracker.active && this.swipeTracker.touchId === touch.identifier) {
                const dt = Date.now() - this.swipeTracker.startTime;
                const dy = touch.clientY - this.swipeTracker.startY;
                if (dt < this.swipeTimeLimit && Math.abs(dy) > this.swipeThreshold) {
                    const action = dy < 0 ? ACT.JUMP : ACT.RELOAD;
                    this.actions[action] = true;
                    setTimeout(() => this.actions[action] = false, 100);
                }
                this.swipeTracker.active = false;
            }
            this.joyRight.active = false;
            this.joyRight.touchId = null;
            this.joyRight.zone.classList.add('hidden');
            
            // OPTIMIZATION: Reset in place
            this.lookVector.x = 0;
            this.lookVector.y = 0;
        }
    }

    initButtons() {
        const buttons = document.querySelectorAll('.btn');
        buttons.forEach(btn => {
            const action = btn.getAttribute('data-action');
            this.buttonElements[action] = btn; 

            if (action === ACT.GYRO) {
                btn.addEventListener('click', (e) => {
                    if (this.isEditMode) return;
                    e.preventDefault();
                    e.stopPropagation();
                    this.toggleGyro(btn);
                });
            }
            
            btn.addEventListener('touchmove', (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, { passive: false });

            btn.addEventListener('touchstart', (e) => {
                if (this.isEditMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.draggedElement = btn;
                    const rect = btn.getBoundingClientRect();
                    this.dragOffset = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
                    return;
                }
                
                if (action === ACT.GYRO) return;
                
                e.preventDefault(); 
                e.stopPropagation(); 
                
                this.actions[action] = true;
                
                if (action === ACT.TECH) this.gyroRatcheting = true;
            }, { passive: false });

            const release = (e) => {
                if (this.isEditMode) return;
                if (action === ACT.GYRO) return;

                e.preventDefault();
                e.stopPropagation();
                
                this.actions[action] = false;
                if (action === ACT.TECH) this.gyroRatcheting = false;
            };

            btn.addEventListener('touchend', release);
            btn.addEventListener('touchcancel', release);
            
            // Mouse Fallbacks
            btn.addEventListener('mousedown', (e) => {
                if (this.isEditMode) {
                    e.preventDefault(); e.stopPropagation();
                    this.draggedElement = btn;
                    const rect = btn.getBoundingClientRect();
                    this.dragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                    return;
                }
                if (action === ACT.GYRO) return;
                this.actions[action] = true;
                if (action === ACT.TECH) this.gyroRatcheting = true;
            });
            
            btn.addEventListener('mouseup', () => {
                if (this.isEditMode) return;
                this.actions[action] = false;
                if (action === ACT.TECH) this.gyroRatcheting = false;
            });
        });
    }
    
    toggleGyro(btn) {
        if (!this.gyroEnabled && typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(res => res === 'granted' && this.enableGyro(btn))
                .catch(console.error);
        } else if (!this.gyroEnabled) {
            this.enableGyro(btn);
        } else {
            this.disableGyro(btn);
        }
    }
    
    enableGyro(btn) {
        this.gyroEnabled = true;
        btn.classList.add('active');
        window.addEventListener('deviceorientation', this.handleOrientation);
    }
    
    disableGyro(btn) {
        this.gyroEnabled = false;
        btn.classList.remove('active');
        window.removeEventListener('deviceorientation', this.handleOrientation);
    }
    
    handleOrientation(event) {
        if (!this.gyroEnabled) return;
        
        if (this.gyroRatcheting) {
            this.lastGyro = { alpha: event.alpha || 0, beta: event.beta || 0, gamma: event.gamma || 0 };
            return;
        }
        
        const alpha = event.alpha || 0;
        const beta = event.beta || 0;
        const gamma = event.gamma || 0;
        
        if (this.lastGyro.alpha === 0 && this.lastGyro.beta === 0 && this.lastGyro.gamma === 0) {
            this.lastGyro = { alpha, beta, gamma };
            return;
        }
        
        let dAlpha = alpha - this.lastGyro.alpha;
        if (dAlpha > 180) dAlpha -= 360;
        if (dAlpha < -180) dAlpha += 360;
        
        const sens = 1.5;
        const rawDX = dAlpha * sens;
        const rawDY = (gamma - this.lastGyro.gamma) * sens;
        
        this.gyroFilter.x = (this.gyroAlpha * rawDX) + ((1.0 - this.gyroAlpha) * this.gyroFilter.x);
        this.gyroFilter.y = (this.gyroAlpha * rawDY) + ((1.0 - this.gyroAlpha) * this.gyroFilter.y);
        
        this.gyroVector.x += this.gyroFilter.x;
        this.gyroVector.y += this.gyroFilter.y;
        
        this.lastGyro = { alpha, beta, gamma };
    }
    
    getGyroDelta() {
        _gyroDelta.x = this.gyroVector.x;
        _gyroDelta.y = this.gyroVector.y;
        this.gyroVector.x = 0;
        this.gyroVector.y = 0;
        return _gyroDelta;
    }

    initKeyboard() {
        const setKey = (code, state) => {
            if (this.isEditMode) return;
            const mapping = {
                'Space': ACT.JUMP, 'ShiftLeft': ACT.DASH, 'KeyJ': ACT.ATTACK, 
                'KeyK': ACT.BLOCK, 'KeyQ': ACT.SWITCH, 'KeyR': ACT.RELOAD,
                'KeyT': ACT.STYLE, 'KeyL': ACT.LOCK, 'KeyP': ACT.CAM_SWITCH,
                'KeyM': ACT.MISSILE, 'KeyF': ACT.TECH
            };
            if (mapping[code]) this.actions[mapping[code]] = state;
            if (code === 'KeyF') this.gyroRatcheting = state;
        };
        window.addEventListener('keydown', e => setKey(e.code, true));
        window.addEventListener('keyup', e => setKey(e.code, false));
    }

    consumeAction(actionName) {
        return this.actions[actionName];
    }
}</script>
    <script>/**
 * PLAYER MESH GENERATOR - "SCIZOR TYPE" MECH (FINAL FORM)
 * High-Fidelity Mecha Construction based on Scizor Pokemon Design.
 * REVISION: Fixed leg geometry to flow backwards (Digitigrade stance).
 * UPDATED: Implemented "Magic Neon Shell" Shader - Solid Transparent Neon
 * UPDATED: Added Persistent Energy Shield Mesh
 * UPDATED: Custom Scizor Geometry (Blade Pincers, Angular Crest, Sharp Wings)
 * REFACTORED: Extracted Shaders to static constants.
 * CRITICAL FIX: Implemented Tier 3 Two-Pass Rendering with Logarithmic Depth Support.
 * CRITICAL FIX: Feet now point downwards (Zone of the Enders style).
 * CRITICAL FIX: Rotated feet -90 degrees X-axis per user request.
 * UPDATED: Legs are now straight up and down (Orbital Frame Style).
 * UPDATED: Fixed Armor Material to be visible (Solid Neon Shell).
 * UPDATED: Integrated ThrusterPlume for Herculean engine visuals.
 * UPDATED: Thrusters now only visible when thrusting.
 * FIXED: Gun Rotation (Removed 180 deg Y) and Position (Aligned grip to hand).
 * FIXED: Hand and Sword Pivot Points aligned to Wrist Bone (Exact IK Match).
 * FIXED: Sword Grip Offset (Sword was floating, now seated in hand).
 * UPDATED: Secondary Color changed to Charcoal Grey per user request.
 */

const SHADERS = {
    magicShellVert: `
        #include <common>
        #include <logdepthbuf_pars_vertex>
        
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vNormal;
        
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
            
            #include <logdepthbuf_vertex>
        }
    `,
    magicShellFrag: `
        #include <common>
        #include <logdepthbuf_pars_fragment>
        
        uniform sampler2D tMatCap;
        uniform float uTime;
        uniform float uReveal; // 0.0 = Ghost/Faint, 1.0 = Solid Neon
        uniform vec3 uColor;
        uniform vec3 uGlowColor;
        
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vNormal;
        
        void main() {
            #include <logdepthbuf_fragment>
            
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - max(0.0, dot(viewDir, vNormal)), 2.0);
            
            // MatCap approximation or simple color
            vec3 baseColor = uColor * 0.6; 
            float baseAlpha = 0.6 + (uReveal * 0.4); 
            
            vec3 rimColor = uGlowColor * fresnel * 2.5;
            vec3 finalColor = baseColor + rimColor;
            
            float pulse = 0.95 + 0.05 * sin(uTime * 2.0);
            finalColor *= pulse;
            
            float finalAlpha = baseAlpha + (fresnel * 0.5);
            finalAlpha = clamp(finalAlpha, 0.0, 1.0);
            
            finalAlpha *= (0.2 + uReveal * 0.8);

            gl_FragColor = vec4(finalColor, finalAlpha);
        }
    `,
    shieldVert: `
        #include <common>
        #include <logdepthbuf_pars_vertex>
        
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying vec2 vUv;
        void main() {
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            vUv = uv;
            gl_Position = projectionMatrix * mvPosition;
            
            #include <logdepthbuf_vertex>
        }
    `,
    shieldFrag: `
        #include <common>
        #include <logdepthbuf_pars_fragment>
        
        uniform float uTime;
        uniform float uDamage; 
        uniform vec3 uColor;
        
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying vec2 vUv;

        float rand(vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            #include <logdepthbuf_fragment>
            
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - max(0.0, dot(viewDir, vNormal)), 3.0);
            float ripple = sin(vUv.y * 20.0 - uTime * 8.0) * 0.1;
            float crack = 0.0;
            if (uDamage > 0.0) {
                float noise = rand(vUv * 10.0);
                if (noise < uDamage) {
                    crack = 1.0;
                }
            }
            if (crack > 0.5) discard;
            vec3 finalColor = uColor + (fresnel * 2.0);
            finalColor += vec3(ripple);
            if (uDamage > 0.7) {
                finalColor = mix(finalColor, vec3(1.0, 0.0, 0.0), sin(uTime * 20.0) * 0.5 + 0.5);
            }
            float alpha = 0.05 + (fresnel * 0.5);
            gl_FragColor = vec4(finalColor, alpha);
        }
    `,
    depthVert: `
        #include <common>
        #include <logdepthbuf_pars_vertex>
        
        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            #include <logdepthbuf_vertex>
        }
    `,
    depthFrag: `
        #include <common>
        #include <logdepthbuf_pars_fragment>
        
        uniform float uReveal;
        void main() {
            #include <logdepthbuf_fragment>
            if (uReveal < 0.1) discard;
            gl_FragColor = vec4(0.0); 
        }
    `
};

class PlayerMesh {
    static build(player) {
        const scene = player.scene;
        
        // --- MAIN CONTAINER ---
        player.mesh = new THREE.Group();
        player.mesh.position.y = 5; 
        player.mesh.rotation.y = Math.PI; 
        scene.add(player.mesh);

        // --- VISUAL ROOT ---
        player.visualGroup = new THREE.Group();
        player.mesh.add(player.visualGroup);

        this.createMeshStructure(player, player.visualGroup);
    }

    static createMeshStructure(context, rootGroup) {
        // --- SCIZOR PALETTE ---
        const matCapRed = TextureGen.createMatCap(256, '#cc0000', '#550000'); // Crimson
        // UPDATED: Charcoal MatCap for Secondary Parts
        const matCapCharcoal = TextureGen.createMatCap(256, '#36454F', '#1a2226'); // Charcoal
        const matCapFrame = TextureGen.createMatCap(256, '#444444', '#111111');
        
        // 1. CRIMSON ARMOR
        context.matArmor = new THREE.ShaderMaterial({
            uniforms: {
                tMatCap: { value: matCapRed },
                uTime: { value: 0 },
                uReveal: { value: 1.0 },
                uColor: { value: new THREE.Color(0xdd0000) }, // Deep Red
                uGlowColor: { value: new THREE.Color(0xff5555) } // Bright Red Highlight
            },
            vertexShader: SHADERS.magicShellVert,
            fragmentShader: SHADERS.magicShellFrag,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: true, 
            blending: THREE.NormalBlending 
        });
        
        // 2. DARK JOINTS / ABDOMEN (CHARCOAL)
        context.matArmorDark = new THREE.ShaderMaterial({
            uniforms: {
                tMatCap: { value: matCapCharcoal },
                uTime: { value: 0 },
                uReveal: { value: 1.0 },
                uColor: { value: new THREE.Color(0x36454F) }, // Charcoal Grey
                uGlowColor: { value: new THREE.Color(0x536878) } // Lighter Charcoal Highlight
            },
            vertexShader: SHADERS.magicShellVert,
            fragmentShader: SHADERS.magicShellFrag,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: true, 
            blending: THREE.NormalBlending 
        });
        
        // 3. DEPTH PASS
        context.matDepth = new THREE.ShaderMaterial({
            uniforms: { uReveal: { value: 1.0 } },
            vertexShader: SHADERS.depthVert,
            fragmentShader: SHADERS.depthFrag,
            side: THREE.DoubleSide,
            colorWrite: false,
            depthWrite: true,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1
        });
        
        context.matFrame = new THREE.MeshMatcapMaterial({ color: 0x888888, matcap: matCapFrame });

        // 4. YELLOW EYES / SENSORS
        context.matMetatron = new THREE.MeshStandardMaterial({
            color: 0xffcc00,
            emissive: 0xffaa00,
            emissiveIntensity: 3.0,
            roughness: 0.1,
            metalness: 0.8
        });

        context.matEnergy = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8
        });

        context.matBlade = new THREE.MeshStandardMaterial({ 
            color: 0xff0055, emissive: 0xff0055, emissiveIntensity: 2.0,
            transparent: true, opacity: 0.9, metalness: 0.1, roughness: 0.0
        });

        // --- HIPS ---
        context.hips = new THREE.Group();
        context.hips.position.y = 1.4; 
        rootGroup.add(context.hips);
        
        // Angular Hips (Chamfered Box)
        const hipGeo = new THREE.CylinderGeometry(0.25, 0.15, 0.4, 6); // Hexagonal
        const hipMesh = new THREE.Mesh(hipGeo, context.matArmor);
        hipMesh.rotation.z = Math.PI/2;
        context.hips.add(hipMesh);
        PlayerMesh.attachDepthProxy(hipMesh, context.matDepth);

        // --- TORSO ---
        context.spine = new THREE.Group();
        context.hips.add(context.spine);
        
        context.torso = new THREE.Group();
        context.torso.position.y = 0.5; 
        context.spine.add(context.torso);

        // Chest (Angular Carapace)
        const chestGeo = new THREE.CylinderGeometry(0.4, 0.25, 0.7, 6);
        context.chestMesh = new THREE.Mesh(chestGeo, context.matArmor);
        context.chestMesh.position.y = 0.2;
        context.chestMesh.scale.set(1, 1, 0.7); // Flatten slightly
        context.torso.add(context.chestMesh);
        PlayerMesh.attachDepthProxy(context.chestMesh, context.matDepth);
        
        // Neck Collar (Sharp)
        const collar = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.15, 6), context.matArmorDark);
        collar.position.y = 0.6;
        context.torso.add(collar);
        
        // Chest Markings (Black lines)
        const chestDetail = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.05, 0.45), context.matArmorDark);
        chestDetail.position.y = 0.2;
        context.torso.add(chestDetail);

        // --- HEAD (Angular Scizor Shape) ---
        context.head = new THREE.Group();
        context.head.position.y = 0.75; 
        context.torso.add(context.head);
        
        // Main Head (Boxy/Angular)
        const headMainGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.3, 6);
        const headMain = new THREE.Mesh(headMainGeo, context.matArmor);
        headMain.rotation.x = Math.PI/2;
        context.head.add(headMain);
        PlayerMesh.attachDepthProxy(headMain, context.matDepth);
        
        // Center Crest (Triple pronged look - Sharp)
        const crestC = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 0.3), context.matArmor);
        crestC.position.set(0, 0.25, -0.1);
        crestC.rotation.x = -0.3;
        context.head.add(crestC);
        PlayerMesh.attachDepthProxy(crestC, context.matDepth);
        
        // Side Horns (Sharp Cones)
        const hornGeo = new THREE.ConeGeometry(0.05, 0.5, 4);
        const hornL = new THREE.Mesh(hornGeo, context.matArmor);
        hornL.position.set(0.15, 0.2, -0.1);
        hornL.rotation.z = -0.5;
        hornL.rotation.x = -0.3;
        context.head.add(hornL);
        PlayerMesh.attachDepthProxy(hornL, context.matDepth);
        
        const hornR = new THREE.Mesh(hornGeo, context.matArmor);
        hornR.position.set(-0.15, 0.2, -0.1);
        hornR.rotation.z = 0.5;
        hornR.rotation.x = -0.3;
        context.head.add(hornR);
        PlayerMesh.attachDepthProxy(hornR, context.matDepth);
        
        // Eyes (Yellow Slits)
        const eyeGeo = new THREE.BoxGeometry(0.1, 0.05, 0.05);
        const eyeL = new THREE.Mesh(eyeGeo, context.matMetatron);
        eyeL.position.set(0.12, 0.05, 0.15);
        eyeL.rotation.y = 0.3;
        context.head.add(eyeL);
        PlayerMesh.addGlowShell(eyeL, 0.02, 0xffaa00);
        
        const eyeR = new THREE.Mesh(eyeGeo, context.matMetatron);
        eyeR.position.set(-0.12, 0.05, 0.15);
        eyeR.rotation.y = -0.3;
        context.head.add(eyeR);
        PlayerMesh.addGlowShell(eyeR, 0.02, 0xffaa00);

        // --- WINGS (Angular Elytra) ---
        context.binderL = PlayerMesh.createScizorWing(context, 1);
        context.binderL.position.set(0.2, 0.4, -0.25);
        context.binderL.rotation.z = -0.4;
        context.binderL.rotation.y = 0.4;
        context.torso.add(context.binderL);

        context.binderR = PlayerMesh.createScizorWing(context, -1);
        context.binderR.position.set(-0.2, 0.4, -0.25);
        context.binderR.rotation.z = 0.4;
        context.binderR.rotation.y = -0.4;
        context.torso.add(context.binderR);

        // --- ARMS (PINCERS) ---
        context.armL = new THREE.Group();
        context.armL.position.set(0.45, 0.3, 0);
        context.torso.add(context.armL);
        
        context.armR = new THREE.Group();
        context.armR.position.set(-0.45, 0.3, 0);
        context.torso.add(context.armR);
        
        PlayerMesh.buildScizorArm(context, context.armL, 1);
        PlayerMesh.buildScizorArm(context, context.armR, -1);

        // --- WEAPONS MOUNTING ---
        // CRITICAL FIX: Align pivot to wrist bone end (armLen2 = 0.5)
        const wristY = -0.5; 
        
        context.swordGroup = new THREE.Group();
        context.swordGroup.position.set(0, wristY, 0); 
        context.armR.children[2].add(context.swordGroup); 
        
        const bladeModel = AssetFactory.createEnergyBlade(context.matBlade, context.matFrame);
        // FIXED: Offset visual blade to sit correctly in hand (was 0.3, now -0.2 to center grip)
        // The blade handle is centered at (0,0,0) in its local space, but we want the grip point to be at (0,0,0) of swordGroup
        // swordGroup is at the wrist. Pincers extend down (-Y).
        // So we need to push the blade down slightly to align handle with pincer gap.
        bladeModel.position.set(0, -0.2, 0); 
        context.bladeMesh = bladeModel.children[0]; 
        context.swordGroup.add(bladeModel);

        context.handR = new THREE.Group();
        context.handR.position.set(0, wristY, 0);
        context.armR.children[2].add(context.handR);
        
        if (typeof AssetFactory !== 'undefined') {
            context.gunGroup = AssetFactory.createAvengerShotgun(); 
            context.gunGroup.visible = false;
            context.gunGroup.scale.set(0.8, 0.8, 0.8);
            
            // FIXED: Gun Alignment
            // Grip is at (0, -0.08, 0.6) in gun space.
            // We want grip at (0,0,0) in hand space (Wrist Pivot).
            // So we shift gun by (0, 0.08, -0.6).
            // UPDATED: Adjusted X slightly to prevent clipping and ensure center alignment
            context.gunGroup.position.set(0, 0.08, -0.6); 
            context.gunGroup.rotation.set(0, 0, 0);
            
            context.handR.add(context.gunGroup);
            
            context.muzzlePoint = new THREE.Object3D();
            // Muzzle is at the end of the gun model.
            // Barrel length is ~1.0 starting at 0.05. Ends at 1.05.
            // With scale 0.8, it's around 0.84.
            // + Offset -0.6.
            // Let's manually tune: Z=1.4 relative to gun origin seems correct for tip.
            context.muzzlePoint.position.set(0, 0.05, 1.4); 
            context.gunGroup.add(context.muzzlePoint);
        }

        // --- LEGS ---
        if (!context.thighLen) context.thighLen = 0.5;
        if (!context.shinLen) context.shinLen = 0.6; 
        if (!context.hipWidth) context.hipWidth = 0.25;

        context.legL = PlayerMesh.createScizorLeg(context, 1);
        context.legL.root.position.set(context.hipWidth, 0, 0);
        // Rotate OUTWARD to prevent crossing
        context.legL.root.rotation.y = -0.2; 
        context.hips.add(context.legL.root);

        context.legR = PlayerMesh.createScizorLeg(context, -1);
        context.legR.root.position.set(-context.hipWidth, 0, 0);
        // Rotate OUTWARD to prevent crossing
        context.legR.root.rotation.y = 0.2; 
        context.hips.add(context.legR.root);

        // --- SHIELD ---
        PlayerMesh.createShield(context, rootGroup);

        // --- VFX ---
        PlayerMesh.createVFX(context);
    }

    static createStandalone() {
        const dummyContext = {
            thighLen: 0.5,
            shinLen: 0.6,
            hipWidth: 0.25
        };
        const rootGroup = new THREE.Group();
        this.createMeshStructure(dummyContext, rootGroup);
        
        // Pose
        dummyContext.armL.rotation.z = 0.5;
        dummyContext.armR.rotation.z = -0.5;
        dummyContext.legL.root.rotation.x = 0.2;
        dummyContext.legR.root.rotation.x = -0.2;
        
        if (dummyContext.shieldMesh) dummyContext.shieldMesh.visible = false;
        
        return rootGroup;
    }

    static createShield(player, parentGroup) {
        const shieldGeo = new THREE.SphereGeometry(2.2, 32, 32);
        player.matShield = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uDamage: { value: 0.0 },
                uColor: { value: new THREE.Color(0x00ffff) }
            },
            vertexShader: SHADERS.shieldVert,
            fragmentShader: SHADERS.shieldFrag,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        player.shieldMesh = new THREE.Mesh(shieldGeo, player.matShield);
        player.shieldMesh.position.y = 1.2; 
        player.shieldMesh.visible = false; 
        if (parentGroup) parentGroup.add(player.shieldMesh);
        else if (player.visualGroup) player.visualGroup.add(player.shieldMesh);
    }

    static createScizorWing(player, side) {
        const group = new THREE.Group();
        
        // Wing Cover (Elytra) - Angular Plate
        const shellGeo = new THREE.BoxGeometry(0.4, 1.4, 0.05);
        // Taper the box to make it wing-shaped
        const pos = shellGeo.attributes.position;
        for(let i=0; i<pos.count; i++) {
            if(pos.getY(i) < 0) { // Bottom tips
                pos.setX(i, pos.getX(i) * 0.2); // Pointy
            }
        }
        shellGeo.computeVertexNormals();
        
        const shell = new THREE.Mesh(shellGeo, player.matArmor);
        shell.position.y = 0.5;
        group.add(shell);
        PlayerMesh.attachDepthProxy(shell, player.matDepth);
        
        // Inner Wing (Transparent Blade)
        const innerGeo = new THREE.PlaneGeometry(0.5, 1.2);
        const innerMat = new THREE.MeshBasicMaterial({ color: 0xccffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const inner = new THREE.Mesh(innerGeo, innerMat);
        inner.position.set(side * 0.1, 0.4, 0.05);
        inner.rotation.y = side * 0.1;
        group.add(inner);
        
        // Small secondary wing
        const smallGeo = new THREE.PlaneGeometry(0.3, 0.8);
        const small = new THREE.Mesh(smallGeo, innerMat);
        small.position.set(side * 0.2, 0.2, 0.08);
        small.rotation.z = side * 0.3;
        group.add(small);
        
        // Thruster Glow at bottom
        // CLONE MATERIAL for independent control so we can hide it when not thrusting
        const thrusterMat = player.matEnergy.clone();
        const glow = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.4, 4), thrusterMat);
        glow.rotation.x = Math.PI;
        glow.position.y = -0.3;
        glow.visible = false; // Hidden by default
        group.add(glow);
        
        // NEW: Attach Volumetric Thruster Plume
        if (typeof ThrusterPlume !== 'undefined') {
             const plume = new ThrusterPlume(glow, 0x00ffff);
             group.userData.plume = plume;
        }
        
        group.userData.flap = inner;
        group.userData.thruster = glow;
        return group;
    }

    static buildScizorArm(player, group, side) {
        // Shoulder (Large Angular Pad)
        const shoulderGeo = new THREE.DodecahedronGeometry(0.35, 0); // More geometric
        const shoulder = new THREE.Mesh(shoulderGeo, player.matArmor);
        group.add(shoulder);
        PlayerMesh.attachDepthProxy(shoulder, player.matDepth);
        
        // Upper Arm (Thin Box)
        const upper = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), player.matArmorDark);
        upper.position.y = -0.25;
        group.add(upper);
        PlayerMesh.attachDepthProxy(upper, player.matDepth);
        
        // Forearm Group (Includes Pincer)
        const forearmGroup = new THREE.Group();
        forearmGroup.position.y = -0.5;
        group.add(forearmGroup);
        
        // Forearm Base (Angular)
        const foreGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.3, 6);
        const forearm = new THREE.Mesh(foreGeo, player.matArmor);
        forearm.position.y = 0.15;
        forearmGroup.add(forearm);
        PlayerMesh.attachDepthProxy(forearm, player.matDepth);
        
        // PINCER CONSTRUCTION (Sharp Blades)
        const pincerBase = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), player.matArmor);
        pincerBase.position.y = -0.1;
        forearmGroup.add(pincerBase);
        PlayerMesh.attachDepthProxy(pincerBase, player.matDepth);
        
        // The "Eye" spot on the claw (Black circle)
        const spotGeo = new THREE.CircleGeometry(0.08, 16);
        const spot = new THREE.Mesh(spotGeo, player.matArmorDark);
        spot.rotation.y = (side === 1) ? -Math.PI/2 : Math.PI/2;
        spot.position.x = (side === 1) ? -0.11 : 0.11;
        spot.position.y = -0.1;
        forearmGroup.add(spot);
        
        // Upper Jaw (Sharp Blade)
        const jawUGeo = new THREE.ConeGeometry(0.1, 0.8, 4);
        // Flatten
        jawUGeo.scale(1, 1, 0.3);
        const jawU = new THREE.Mesh(jawUGeo, player.matArmor);
        jawU.rotation.x = Math.PI; // Point down
        jawU.rotation.z = side * 0.15; // Angle out
        jawU.position.set(side * 0.05, -0.5, 0.05);
        forearmGroup.add(jawU);
        PlayerMesh.attachDepthProxy(jawU, player.matDepth);
        
        // Add Glow Edge to Upper Jaw
        const edgeU = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.8, 0.02), player.matEnergy);
        edgeU.position.set(0, 0, 0.05);
        jawU.add(edgeU);
        
        // Lower Jaw (Smaller Blade)
        const jawLGeo = new THREE.ConeGeometry(0.08, 0.6, 4);
        jawLGeo.scale(1, 1, 0.3);
        const jawL = new THREE.Mesh(jawLGeo, player.matArmor);
        jawL.rotation.x = Math.PI;
        jawL.rotation.z = side * -0.15;
        jawL.position.set(side * -0.05, -0.4, 0.05);
        forearmGroup.add(jawL);
        PlayerMesh.attachDepthProxy(jawL, player.matDepth);
    }

    static createScizorLeg(player, side) {
        const root = new THREE.Group();
        
        // Thigh (Sleek, Tapered)
        // Straight down - Orbital Frame Style
        const thighGeo = new THREE.CylinderGeometry(0.12, 0.08, player.thighLen, 6);
        const thigh = new THREE.Mesh(thighGeo, player.matArmor);
        thigh.position.y = -player.thighLen / 2;
        
        root.add(thigh);
        PlayerMesh.attachDepthProxy(thigh, player.matDepth);
        
        const knee = new THREE.Group();
        knee.position.y = -player.thighLen; 
        root.add(knee);
        
        // Knee Joint (Mechanical)
        const kneeJoint = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.12), player.matArmorDark);
        knee.add(kneeJoint);
        PlayerMesh.attachDepthProxy(kneeJoint, player.matDepth);
        
        const shinGroup = new THREE.Group();
        // CRITICAL FIX: Ensure shin is straight by default, no pre-bend
        shinGroup.rotation.x = 0; 
        knee.add(shinGroup);
        
        // Knee Guard (Prominent)
        const kneeGuard = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.2, 0.05), player.matArmor);
        kneeGuard.position.set(0, -0.1, 0.08); // Front of knee
        kneeGuard.rotation.x = -0.2;
        shinGroup.add(kneeGuard);

        // Shin (Long, Tapering to a point)
        const shinLen = player.shinLen * 1.2; // Longer shin for elegance
        const shinGeo = new THREE.CylinderGeometry(0.08, 0.02, shinLen, 6); // Tapers to almost point
        const shin = new THREE.Mesh(shinGeo, player.matArmor);
        shin.position.y = -shinLen / 2;
        shinGroup.add(shin);
        PlayerMesh.attachDepthProxy(shin, player.matDepth);
        
        // Calf Thruster / Detail
        const thruster = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.1), player.matArmorDark);
        thruster.position.set(0, -shinLen * 0.3, -0.05); // Back of calf
        shinGroup.add(thruster);
        
        // Foot (The Point) - Orbital Frame Style
        // Just a sharp extension
        const footGeo = new THREE.ConeGeometry(0.04, 0.4, 4);
        const foot = new THREE.Mesh(footGeo, player.matArmor); 
        // CRITICAL FIX: Foot points DOWN by default (X=PI)
        foot.rotation.x = Math.PI; 
        foot.position.set(0, -shinLen, 0); // At end of shin
        
        shinGroup.add(foot);
        PlayerMesh.attachDepthProxy(foot, player.matDepth);
        
        // Heel Spur (The "High Heel" look typical of orbital frames)
        const heelGeo = new THREE.CylinderGeometry(0.02, 0.04, 0.3);
        const heel = new THREE.Mesh(heelGeo, player.matArmorDark);
        heel.rotation.x = -0.8; // Angle back
        heel.position.set(0, -shinLen + 0.1, -0.1);
        shinGroup.add(heel);

        return { root, knee, foot };
    }

    static createVFX(player) {
        const arcGeo = new THREE.RingGeometry(1.5, 3.0, 32, 1, 0, Math.PI);
        const arcMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, transparent: true, opacity: 0, 
            side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending
        });
        player.slashTemplate = new THREE.Mesh(arcGeo, arcMat);
        player.slashTemplate.visible = false; 
        
        const coreArcGeo = new THREE.RingGeometry(1.8, 2.5, 32, 1, 0, Math.PI);
        const coreArcMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, transparent: true, opacity: 0, 
            side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending
        });
        player.slashCoreTemplate = new THREE.Mesh(coreArcGeo, coreArcMat);
        player.slashTemplate.add(player.slashCoreTemplate);

        const spinGeo = new THREE.RingGeometry(1.5, 3.5, 32, 1, 0, Math.PI * 2);
        player.slashSpinTemplate = new THREE.Mesh(spinGeo, arcMat); 
        player.slashSpinTemplate.visible = false;
    }

    static updateWeaponVisuals(player) {
        if (!player.bladeMesh) return;
        let color = 0xff0055; 
        if (player.currentStyle === 1) color = 0x00ff00;
        if (player.currentStyle === 2) color = 0xffaa00;
        
        if (player.matBlade) {
            player.matBlade.emissive.setHex(color);
            player.matBlade.color.setHex(color);
        }
    }
    
    static addGlowShell(mesh, offset, color) {
        const glowGeo = mesh.geometry.clone();
        const mat = new THREE.MeshBasicMaterial({
            color: color, transparent: true, opacity: 0.5,
            blending: THREE.AdditiveBlending, side: THREE.FrontSide, depthWrite: false
        });
        const glowMesh = new THREE.Mesh(glowGeo, mat);
        glowMesh.scale.multiplyScalar(1.1);
        mesh.add(glowMesh);
    }
    
    static attachDepthProxy(mesh, material) {
        if (!material) return;
        const proxy = new THREE.Mesh(mesh.geometry, material);
        proxy.renderOrder = -1; 
        proxy.matrixAutoUpdate = false; 
        mesh.add(proxy);
    }
    
    // NEW: Centralized Thruster Logic
    static updateThrusters(player, dt) {
        // VISUALS: Determine intensity based on state
        // 0.0 = Off (Invisible)
        // 0.8 = Normal Thrust
        // 2.0 = Boost
        const isBoosting = player.isBoosting || player.isDashing;
        // STRICT CHECK: Only active if flag is true
        const baseIntensity = player.isThrusterActive ? 0.8 : 0.0;
        const intensity = isBoosting ? 2.0 : baseIntensity;
        
        // Update Thruster Visuals (Plume + Base Glow)
        const updateSingleThruster = (binder) => {
            if (!binder) return;
            
            const plume = binder.userData.plume;
            const glow = binder.userData.thruster;
            
            // Update Plume and Glow
            if (intensity <= 0.01) {
                if(glow) glow.visible = false;
                if(plume) plume.update(dt, 0); // Tell plume to hide
            } else {
                if(glow) {
                    glow.visible = true;
                    if (glow.material) {
                        glow.material.color.setHex(isBoosting ? 0xffaa00 : 0x00ffff);
                        glow.material.opacity = 0.5 + Math.random() * 0.5; // Flicker
                    }
                    // Scale jitter for effect
                    const j = 1.0 + Math.random() * 0.2;
                    glow.scale.set(1, j, 1);
                }
                if(plume) {
                    plume.update(dt, intensity);
                    plume.setColor(isBoosting ? 0xffaa00 : 0x00ffff);
                }
            }
        };
        
        updateSingleThruster(player.binderL);
        updateSingleThruster(player.binderR);
    }
    
    static transform(player, state, dt = 0.1) {
        const lerpSpeed = 5.0 * dt;
        
        // Call centralized thruster logic
        this.updateThrusters(player, dt);
        
        if (state === 'JET') {
            if (player.binderL) {
                player.binderL.rotation.z = THREE.MathUtils.lerp(player.binderL.rotation.z, 0.8, lerpSpeed);
                player.binderL.rotation.y = THREE.MathUtils.lerp(player.binderL.rotation.y, 0.5, lerpSpeed);
            }
            if (player.binderR) {
                player.binderR.rotation.z = THREE.MathUtils.lerp(player.binderR.rotation.z, -0.8, lerpSpeed);
                player.binderR.rotation.y = THREE.MathUtils.lerp(player.binderR.rotation.y, -0.5, lerpSpeed);
            }
            if (player.legL && player.legL.root) {
                player.legL.root.rotation.x = THREE.MathUtils.lerp(player.legL.root.rotation.x, 1.2, lerpSpeed);
            }
            if (player.legR && player.legR.root) {
                player.legR.root.rotation.x = THREE.MathUtils.lerp(player.legR.root.rotation.x, 1.2, lerpSpeed);
            }
            if (player.armL) player.armL.rotation.z = THREE.MathUtils.lerp(player.armL.rotation.z, 0.1, lerpSpeed);
            if (player.armR) player.armR.rotation.z = THREE.MathUtils.lerp(player.armR.rotation.z, -0.1, lerpSpeed);
            if (player.head) player.head.rotation.x = THREE.MathUtils.lerp(player.head.rotation.x, 0.5, lerpSpeed);

            // Point feet backwards in flight (since they point down now)
            // Initial rot X is Math.PI. Rotating to Math.PI + 1.5 points them back.
            if (player.legL && player.legL.foot) {
                player.legL.foot.rotation.x = THREE.MathUtils.lerp(player.legL.foot.rotation.x, Math.PI + 1.5, lerpSpeed);
            }
            if (player.legR && player.legR.foot) {
                player.legR.foot.rotation.x = THREE.MathUtils.lerp(player.legR.foot.rotation.x, Math.PI + 1.5, lerpSpeed);
            }

        } else {
            if (player.binderL) {
                player.binderL.rotation.z = THREE.MathUtils.lerp(player.binderL.rotation.z, -0.4, lerpSpeed);
                player.binderL.rotation.y = THREE.MathUtils.lerp(player.binderL.rotation.y, 0.4, lerpSpeed);
            }
            if (player.binderR) {
                player.binderR.rotation.z = THREE.MathUtils.lerp(player.binderR.rotation.z, 0.4, lerpSpeed);
                player.binderR.rotation.y = THREE.MathUtils.lerp(player.binderR.rotation.y, -0.4, lerpSpeed);
            }
            if (player.head) player.head.rotation.x = THREE.MathUtils.lerp(player.head.rotation.x, 0, lerpSpeed);
            
            // Reset feet to point down
            if (player.legL && player.legL.foot) {
                player.legL.foot.rotation.x = THREE.MathUtils.lerp(player.legL.foot.rotation.x, Math.PI, lerpSpeed);
            }
            if (player.legR && player.legR.foot) {
                player.legR.foot.rotation.x = THREE.MathUtils.lerp(player.legR.foot.rotation.x, Math.PI, lerpSpeed);
            }
        }
    }
}</script> 
    
    <!-- Photon SDK (Moved here for guaranteed load order before manager) -->
    <script src="https://cdn.jsdelivr.net/npm/photon-javascript-sdk@latest/dist/Photon-Javascript_SDK.min.js"></script>

    <!-- Network Manager (Loaded before Game) -->
    <script>/**
 * PHOTON NETWORK MANAGER
 * Handles connection to Photon Cloud, room management, and event synchronization.
 */
class PhotonNetworkManager {
    constructor(appId) {
        this.appId = appId;
        this.client = null;
        this.connected = false;
        this.myActorNumber = null;
        
        // Callbacks
        this.onPlayerJoined = null;
        this.onPlayerLeft = null;
        this.onPlayerStateUpdate = null;
    }

    get roomName() {
        return (this.client && this.client.myRoom()) ? this.client.myRoom().name : null;
    }

    async connect(playerName, roomCode = null) {
        return new Promise((resolve, reject) => {
            // Ensure Photon SDK is loaded
            if (typeof Photon === 'undefined') {
                console.error("Photon SDK not loaded.");
                reject("Photon SDK missing");
                return;
            }

            this.client = new Photon.LoadBalancing.LoadBalancingClient(
                Photon.ConnectionProtocol.Wss, 
                this.appId, 
                "1.0"
            );

            this.client.onJoinRoom = () => {
                console.log("Photon: Joined Room");
                this.connected = true;
                this.myActorNumber = this.client.myActor().actorNr;
                resolve();
            };

            this.client.onActorJoin = (actor) => {
                console.log("Photon: Actor Joined", actor.actorNr);
                if (this.onPlayerJoined) this.onPlayerJoined(actor);
            };

            this.client.onActorLeave = (actor) => {
                console.log("Photon: Actor Left", actor.actorNr);
                if (this.onPlayerLeft) this.onPlayerLeft(actor);
            };

            this.client.onEvent = (code, content, actorNr) => {
                if (code === 1 && this.onPlayerStateUpdate) {
                    this.onPlayerStateUpdate(actorNr, content);
                }
            };

            this.client.onError = (errorCode, errorMsg) => {
                console.error("Photon Error:", errorCode, errorMsg);
            };

            this.client.setCustomAuthentication("username=" + playerName);
            this.client.connectToRegionMaster("us");
            
            this.client.onStateChange = (state) => {
                console.log("Photon State:", state);
                if (state === Photon.LoadBalancing.LoadBalancingClient.State.JoinedLobby) {
                    if (roomCode) {
                        // Use joinOrCreateRoom to ensure we can create new rooms or join existing ones
                        this.client.joinOrCreateRoom(roomCode, { isVisible: true, isOpen: true, maxPlayers: 4 });
                    } else {
                        this.client.joinRandomOrCreateRoom();
                    }
                }
            };
        });
    }

    sendPosition(x, y, z, rotY) {
        if (!this.connected) return;
        // Event Code 1: Position Update
        this.client.raiseEvent(1, {x, y, z, rotY});
    }

    service() {
        if (this.client) {
            this.client.service();
        }
    }
}</script>

    <!-- Physics & Combat Modules (Loaded before Player) -->
    <script>/**
 * PLAYER PHYSICS MODULE
 * Handles kinematics, collisions, and spring dynamics.
 * Converted to standard global class for compatibility.
 * UPDATED: Added Environmental Physics (Ice, Wind, Void Gravity).
 * UPDATED: Added attack friction to prevent slash-canceling momentum abuse.
 * UPDATED: Removed footstep noise per user request.
 * UPDATED: Adjusted Attack Friction to distinguish between Homing (Low Drag) and Manual (High Drag) slashes.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes.
 * UPDATED: Added Arena Wall Collision Logic.
 * OPTIMIZED: Implemented Static Result Object for Wall Collision to eliminate GC.
 * OPTIMIZED: Smart Wall Checking (Only checks movement direction).
 * CRITICAL FIX: Added NaN Safety Checks for Vector Normalization.
 * OPTIMIZED: Implemented Raycast Caching (Frame Skipping) to prevent freeze.
 * PERF FIX: Velocity-based raycast culling.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _ppVec1 = new THREE.Vector3();
const _ppVec2 = new THREE.Vector3();
const _ppVec3 = new THREE.Vector3();
const _ppUp = new THREE.Vector3(0, 1, 0);
const _ppDown = new THREE.Vector3(0, -1, 0);
const _ppForward = new THREE.Vector3();
const _ppRight = new THREE.Vector3();
const _ppMoveDir = new THREE.Vector3(); // New for smart checking

// Static result object to prevent allocation in loop
const _ppWallResult = { collision: false, normal: new THREE.Vector3() };

class PlayerPhysics {

    static updateSpring(spring, dt) {
        const diff = spring.target - spring.pos;
        const accel = (diff * spring.k) - (spring.vel * spring.d);
        spring.vel += accel * dt;
        spring.pos += spring.vel * dt;
    }

    static checkGround(player, dt) {
        let highestHit = null;
        let groundFound = false;
        const baseX = player.mesh.position.x;
        const baseY = player.mesh.position.y + 1.0;
        const baseZ = player.mesh.position.z;

        const fallDist = Math.abs(player.velocity.y * dt);
        const checkDist = Math.max(1.2, fallDist + 1.2); 

        player.raycaster.far = checkDist;

        // Optimization: Only check center point if moving fast to save CPU
        const loopCount = (player.velocity.lengthSq() > 100) ? 1 : player.groundOffsets.length;

        for (let i = 0; i < loopCount; i++) {
            const off = player.groundOffsets[i];
            player.rayOrigin.set(baseX + off.x, baseY + off.y, baseZ + off.z);
            player.raycaster.set(player.rayOrigin, player.downVector);
            
            if (player.staticGroup && player.staticGroup.children.length > 0) {
                const intersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
                
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    if (hit.distance <= checkDist) {
                        if (!highestHit || hit.point.y > highestHit.point.y) {
                            highestHit = hit;
                            groundFound = true;
                        }
                    }
                }
            }
        }
        return groundFound ? highestHit : null;
    }

    static checkCeiling(player, dt) {
        if (player.velocity.y <= 0) return null;

        const checkDist = Math.max(1.0, (player.velocity.y * dt) + 1.0); 
        player.rayOrigin.copy(player.mesh.position);
        player.rayOrigin.y += 1.0; 
        
        player.raycaster.set(player.rayOrigin, player.upVector);
        player.raycaster.far = checkDist;
        
        if (player.staticGroup && player.staticGroup.children.length > 0) {
            const intersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
            if (intersects.length > 0) {
                return intersects[0];
            }
        }
        return null;
    }

    static checkWallCollision(player, dt) {
        // OPTIMIZATION: If not moving horizontally, DO NOT Raycast.
        const speedSq = player.velocity.x * player.velocity.x + player.velocity.z * player.velocity.z;
        if (speedSq < 0.1) {
            _ppWallResult.collision = false;
            return _ppWallResult;
        }

        const checkDist = 1.5; 
        player.rayOrigin.copy(player.mesh.position);
        player.rayOrigin.y += 1.0; 
        
        // OPTIMIZATION: Smart Direction Check.
        // Instead of checking 7 directions, calculate the actual movement direction.
        _ppMoveDir.set(player.velocity.x, 0, player.velocity.z);
        
        // CRITICAL FIX: Safe Normalize
        if (_ppMoveDir.lengthSq() > 0.00001) {
            _ppMoveDir.normalize();
        } else {
            _ppWallResult.collision = false;
            return _ppWallResult;
        }
        
        // Check 1: Direct Movement Path (Most likely hit)
        player.raycaster.set(player.rayOrigin, _ppMoveDir);
        player.raycaster.far = checkDist;
        
        if (player.staticGroup && player.staticGroup.children.length > 0) {
            let intersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
            if (intersects.length > 0) {
                _ppWallResult.collision = true;
                _ppWallResult.normal.copy(intersects[0].face.normal);
                return _ppWallResult;
            }
            
            // PERF: Skip corner checks if moving slowly
            if (speedSq > 100) {
                // Check 2: 45 degrees Left (Corner prevention)
                _ppVec1.copy(_ppMoveDir).applyAxisAngle(_ppUp, Math.PI/4);
                player.raycaster.set(player.rayOrigin, _ppVec1);
                intersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
                if (intersects.length > 0) {
                    _ppWallResult.collision = true;
                    _ppWallResult.normal.copy(intersects[0].face.normal);
                    return _ppWallResult;
                }

                // Check 3: 45 degrees Right (Corner prevention)
                _ppVec2.copy(_ppMoveDir).applyAxisAngle(_ppUp, -Math.PI/4);
                player.raycaster.set(player.rayOrigin, _ppVec2);
                intersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
                if (intersects.length > 0) {
                    _ppWallResult.collision = true;
                    _ppWallResult.normal.copy(intersects[0].face.normal);
                    return _ppWallResult;
                }
            }
        }
        
        _ppWallResult.collision = false;
        return _ppWallResult;
    }
    
    static applyEnvironmentalForces(player, dt) {
        if (!window.game || !window.game.currentStage) return;
        
        const stage = window.game.currentStage;
        
        if (stage === 'WASTELAND') {
            const windForce = 15.0;
            player.velocity.x += windForce * dt;
            player.velocity.y += (Math.random() - 0.5) * 5.0 * dt;
        }
        
        if (stage === 'VOID') {
            player.gravityScale = 0.4; 
        }
    }

    static applyPhysics(player, dt) {
        // --- OPTIMIZATION: RAYCAST CACHING ---
        // Only perform expensive raycasts every 2nd frame, or every 4th if slow
        const speedSq = player.velocity.lengthSq();
        const skipRate = (speedSq < 1.0 && player.onGround) ? 4 : 2;
        
        player.raycastFrameSkip = (player.raycastFrameSkip + 1) % skipRate;
        const doRaycast = (player.raycastFrameSkip === 0);
        
        this.applyEnvironmentalForces(player, dt);
        
        if (window.game && window.game.currentStage === 'ICE' && player.onGround) {
            // Ice physics handled in drag
        }

        if (player.isDashing) {
            player.dashTime -= dt;
            player.dashTrailTimer -= dt;
            if (player.dashTrailTimer <= 0) {
                player.dashTrailTimer = 0.04; 
            }
            if (player.dashTime <= 0) {
                player.isDashing = false;
                player.velocity.x *= 0.5;
                player.velocity.z *= 0.5;
            }
        }

        if (!player.isDashing) {
            if (player.isAttacking && !player.onGround && player.velocity.y < 0) {
                player.velocity.y *= 0.1; 
            } else {
                player.velocity.y += player.gravity * player.gravityScale * dt;
            }
            
            if (!player.onGround && player.velocity.y < 0) {
                let groundHit = player.cachedGroundHit;
                
                if (doRaycast) {
                    groundHit = this.checkGround(player, dt);
                    // Note: We don't update cachedGroundHit here because we want to save it for the collision step
                    // But if we are falling, this is the most important check.
                    // Let's assume if we check ground here, we can reuse it later if position hasn't changed much.
                    // However, position changes after velocity integration.
                }
                
                if (groundHit) {
                    const distToGround = player.mesh.position.y - groundHit.point.y;
                    const targetH = 2.0; 
                    
                    if (distToGround < 4.0) {
                        const error = targetH - distToGround;
                        player.hoverIntegral += error * dt;
                        const derivative = (error - player.hoverErrorPrior) / dt;
                        
                        const output = (player.hoverKP * error) + (player.hoverKI * player.hoverIntegral) + (player.hoverKD * derivative);
                        player.hoverErrorPrior = error;
                        
                        player.velocity.y += output * dt;
                    }
                }
            }
        }

        if (player.velocity.y > 0) {
            // Ceiling check is rare, can skip optimization or just run it
            const ceilingHit = this.checkCeiling(player, dt);
            if (ceilingHit) {
                player.velocity.y = 0;
            }
        }

        if (player.velocity.lengthSq() > 10000) {
            player.velocity.set(0,0,0); 
        }

        if (!player.isDashing && player.landingLag <= 0) {
             if (window.game && window.game.currentStage === 'ICE' && player.onGround) {
                 player.velocity.x += player.velocity.x * 5.0 * dt; 
                 player.velocity.z += player.velocity.z * 5.0 * dt;
             }
             
             if (player.isAttacking && player.onGround) {
                 const attackDrag = player.isHomingAttack ? 0.9 : 0.6; 
                 player.velocity.x *= attackDrag;
                 player.velocity.z *= attackDrag;
             }
        }

        const nextX = player.mesh.position.x + player.velocity.x * dt;
        const nextZ = player.mesh.position.z + player.velocity.z * dt;
        
        player.tempVec.set(nextX, player.mesh.position.y, nextZ);
        
        // --- ARENA WALL LOGIC ---
        if (player.arenaRadius) {
            const distSq = nextX*nextX + nextZ*nextZ;
            const limitSq = player.arenaRadius * player.arenaRadius;
            
            if (distSq > limitSq) {
                const dist = Math.sqrt(distSq);
                const pushX = -nextX / dist;
                const pushZ = -nextZ / dist;
                
                player.mesh.position.x = (nextX / dist) * (player.arenaRadius - 0.1);
                player.mesh.position.z = (nextZ / dist) * (player.arenaRadius - 0.1);
                
                player.velocity.x += pushX * 500 * dt;
                player.velocity.z += pushZ * 500 * dt;
                
                if (window.flux && window.flux.spawnParticles) {
                     _ppVec1.set(player.mesh.position.x, player.mesh.position.y + 1, player.mesh.position.z);
                     window.flux.spawnParticles(_ppVec1, 5, 0x00ffff, 10);
                }
                return;
            }
        }
        
        // --- WALL COLLISION (CACHED) ---
        let wallHit = player.cachedWallHit;
        if (doRaycast) {
            const res = this.checkWallCollision(player, dt);
            player.cachedWallHit.collision = res.collision;
            player.cachedWallHit.normal.copy(res.normal);
            wallHit = player.cachedWallHit;
        }
        
        if (player.wallMagnetismTimer > 0 && wallHit.normal) {
             // Reuse static vector for pushForce
             _ppVec1.copy(wallHit.normal).multiplyScalar(-250 * dt); 
             player.velocity.add(_ppVec1);
             
             const vDotN = player.velocity.dot(wallHit.normal);
             if (vDotN > 0) {
                 // Reuse vector for subtraction
                 _ppVec2.copy(wallHit.normal).multiplyScalar(vDotN);
                 player.velocity.sub(_ppVec2);
             }
        }
        
        if (wallHit.collision && wallHit.normal) {
            player.touchingWall = true;
            player.wallNormal.copy(wallHit.normal);
            const vDotN = player.velocity.dot(wallHit.normal);
            
            if (vDotN < 0) {
                const slideX = player.velocity.x - (vDotN * wallHit.normal.x);
                const slideZ = player.velocity.z - (vDotN * wallHit.normal.z);
                player.velocity.x = slideX;
                player.velocity.z = slideZ;
                player.mesh.position.x += player.velocity.x * dt;
                player.mesh.position.z += player.velocity.z * dt;
            } else {
                player.mesh.position.x += player.velocity.x * dt;
                player.mesh.position.z += player.velocity.z * dt;
            }
        } else {
            player.touchingWall = false;
            player.isWallRunning = false;
            player.mesh.position.x += player.velocity.x * dt;
            player.mesh.position.z += player.velocity.z * dt;
        }

        const nextY = player.mesh.position.y + player.velocity.y * dt;
        
        // --- GROUND COLLISION (CACHED) ---
        let groundHit = player.cachedGroundHit;
        if (doRaycast) {
            groundHit = this.checkGround(player, dt);
            player.cachedGroundHit = groundHit;
        }
        
        if (groundHit && player.velocity.y <= 0) {
            if (player.velocity.y < -15) {
                player.landingLag = 0.4; 
                player.kinematics.crouch.vel += Math.abs(player.velocity.y) * 1.5; 
                player.kinematics.tiltX.vel += 5.0;
                
                if (window.flux && window.flux.shake) window.flux.shake(0.2);
                if (window.flux.audio) window.flux.audio.play('land_heavy');
            } else if (player.velocity.y < -2) {
                player.kinematics.crouch.vel += 5.0; 
            }
            
            player.mesh.position.y = groundHit.point.y;
            player.velocity.y = 0;
            player.onGround = true;
            player.touchingWall = false;
            player.isWallRunning = false;
            
            player.hoverIntegral = 0;
            player.hoverErrorPrior = 0;
        } else {
            player.onGround = false;
            player.mesh.position.y = nextY;
            
            if (player.mesh.position.y < -20) {
                 player.mesh.position.set(0, 10, 0);
                 player.velocity.set(0,0,0);
            }
        }
    }
}</script>
    <script>/**
 * PLAYER COMBAT SYSTEM
 * Handles attacks, weapons, targeting, and damage logic.
 * Extracted from Player.js to improve modularity.
 * OPTIMIZED: Replaced 'new THREE.Vector3' with static reusable vectors.
 * OPTIMIZED: Used distanceToSquared for hit checks.
 * UPDATED: Implemented distinct Weapon Arts (Katana, Dagger, Greatsword).
 * UPDATED: Added integration for Dynamic Camera Zoom and Impact Stop.
 * UPDATED: Added Kinetic Impact (Stagger) Logic.
 * UPDATED: Removed Debris Spawning.
 * UPDATED: Added collision detection for Background Swarm (InstancedMesh).
 * UPDATED: Added VECTOR COMBO logic for Space Mode (Bonus damage/style).
 * UPDATED: Added HYPER-ARMOR (Efficiency Gate) logic (Style Penalty).
 * UPDATED: Added MOMENTUM-AUGMENTED DAMAGE (Velocity scaling).
 * UPDATED: Added SHIELD BREAK logic for Lag Knight.
 * UPDATED: Added Dagger "Snap" Juice.
 * OPTIMIZED: Auto-Aim now uses static vectors to prevent allocation.
 */

// Static reusable vectors
const _pcVec1 = new THREE.Vector3();
const _pcVec2 = new THREE.Vector3();
const _pcVec3 = new THREE.Vector3();
const _pcVec4 = new THREE.Vector3();
const _pcVec5 = new THREE.Vector3();

class PlayerCombat {

    static update(player, dt, camera) {
        if (player.isDead) return;

        // Update Timers
        if (player.attackTimer > 0) this.updateAttack(player, dt);
        if (player.fireTimer > 0) player.fireTimer -= dt;
        if (player.spaceFireTimer > 0) player.spaceFireTimer -= dt;
        if (player.comboTimer > 0) player.comboTimer -= dt;
        if (player.comboTimer <= 0) player.comboIndex = 0;
        
        if (player.isReloading) {
            player.reloadTimer -= dt * (player.isOverdrive ? 2.0 : 1.0);
            if (player.reloadTimer <= 0) {
                this.finishReload(player);
            }
        }

        // Auto-Aim for FPS mode
        if (player.isFirstPerson && player.targetEnemy && !player.targetEnemy.userData.isDead) {
            // OPTIMIZED: Use static vectors
            _pcVec1.copy(player.targetEnemy.position);
            _pcVec1.y += 1.0;
            _pcVec2.subVectors(_pcVec1, player.mesh.position);
            
            const targetYaw = Math.atan2(_pcVec2.x, _pcVec2.z);
            const targetPitch = Math.atan2(_pcVec2.y - 1.5, Math.sqrt(_pcVec2.x*_pcVec2.x + _pcVec2.z*_pcVec2.z));
            
            let yawDiff = targetYaw - player.mesh.rotation.y;
            while (yawDiff > Math.PI) yawDiff -= Math.PI * 2;
            while (yawDiff < -Math.PI) yawDiff += Math.PI * 2;
            
            player.mesh.rotation.y += yawDiff * 10.0 * dt;
            const clampedPitch = Math.max(-1.4, Math.min(1.4, targetPitch));
            player.camPitch += (clampedPitch - player.camPitch) * 10.0 * dt;
        }
    }

    // --- SPACE COMBAT METHODS ---

    static switchSpaceWeapon(player) {
        if (player.spaceWeapon === 'VULCAN') {
            player.spaceWeapon = 'MISSILE';
            if (window.flux.spawnTechText) window.flux.spawnTechText("WEAPON: MISSILES");
        } else {
            player.spaceWeapon = 'VULCAN';
            if (window.flux.spawnTechText) window.flux.spawnTechText("WEAPON: VULCAN");
        }
        if (window.flux.audio) window.flux.audio.play('switch');
        player.updateHUD();
    }

    static fireSpaceWeapon(player, dt) {
        player.spaceLocks = player.spaceLocks || [];
        this.fireVulcan(player, dt);
    }
    
    static chargeMissiles(player, dt) {
        player.isSpaceLocking = true;
        player.missileChargeTimer = (player.missileChargeTimer || 0) + dt;
        
        if (!player.spaceLocks) player.spaceLocks = [];
        
        const maxDist = 3000; 
        const fov = 0.7; 
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.mesh.quaternion);
        
        const lockInterval = 0.15;
        const maxLocks = 8;
        
        const desiredLocks = Math.min(maxLocks, Math.floor(player.missileChargeTimer / lockInterval) + 1);
        
        if (player.spaceLocks.length < desiredLocks) {
            let bestCandidate = null;
            let bestScore = -Infinity;
            
            const lockCounts = new Map();
            player.spaceLocks.forEach(obj => {
                lockCounts.set(obj, (lockCounts.get(obj) || 0) + 1);
            });
            
            if (window.flux.spaceEnemies) {
                window.flux.spaceEnemies.forEach(obj => {
                    let enemy = obj;
                    while(enemy && !enemy.userData.type && enemy.parent) {
                        enemy = enemy.parent;
                    }
                    
                    if (!enemy || !enemy.userData.type || enemy.userData.isDead) return;
                    
                    const toEnemy = new THREE.Vector3().subVectors(enemy.position, player.mesh.position);
                    const dist = toEnemy.length();
                    
                    if (dist < maxDist) {
                        toEnemy.normalize();
                        const dot = forward.dot(toEnemy);
                        if (dot > fov) {
                            const currentLocks = lockCounts.get(enemy) || 0;
                            let score = (dot * 2000) - (dist * 0.5) - (currentLocks * 200);
                            if (enemy.userData.enemyType === 'subsystem') score += 500;
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestCandidate = enemy;
                            }
                        }
                    }
                });
            }
            
            if (bestCandidate) {
                player.spaceLocks.push(bestCandidate);
                if (window.flux.audio) window.flux.audio.play('lock');
            }
        }
    }
    
    static releaseSpaceWeapon(player) {
        // No-op
    }

    static fireVulcan(player, dt) {
        if (player.spaceFireTimer > 0) return;
        
        player.spaceFireTimer = 0.08; 
        
        if (window.flux.audio) window.flux.audio.play('shotgun'); 
        
        const startPos = player.mesh.position.clone();
        const offset = new THREE.Vector3(
            (Math.random() > 0.5 ? 0.5 : -0.5), 
            0, 
            -2.0
        ).applyQuaternion(player.mesh.quaternion);
        startPos.add(offset);
        
        const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(player.mesh.quaternion);
        direction.x += (Math.random() - 0.5) * 0.02;
        direction.y += (Math.random() - 0.5) * 0.02;
        direction.z += (Math.random() - 0.5) * 0.02;
        direction.normalize();
        
        // --- VECTOR COMBO LOGIC ---
        // Check if decoupled and moving fast
        if (player.flightMode === 'DECOUPLED' && player.velocity.length() > 50) {
            const velDir = player.velocity.clone().normalize();
            const dot = velDir.dot(direction);
            // If angle is significant (drifting sideways/backwards while shooting)
            if (Math.abs(dot) < 0.8) {
                if (Math.random() > 0.8) { // Don't spam text
                    if (window.flux.spawnTechText) window.flux.spawnTechText("VECTOR SHOT");
                    if (window.flux.addCombo) window.flux.addCombo(); // Bonus combo
                }
            }
        }
        
        if (window.flux.spawnSpaceTracer) {
            window.flux.spawnSpaceTracer(startPos, direction);
        }
        
        player.raycaster.set(startPos, direction);
        player.raycaster.far = 2000; 
        
        let hitObject = null;
        let hitPoint = null;
        
        if (window.flux.spaceEnemies) {
            const intersects = player.raycaster.intersectObjects(window.flux.spaceEnemies, true);
            if (intersects.length > 0) {
                hitObject = intersects[0].object;
                hitPoint = intersects[0].point;
            }
        }
        
        if (hitObject) {
            let enemy = hitObject;
            while(enemy.parent && !enemy.userData.type) {
                enemy = enemy.parent;
            }
            
            if (enemy.userData.type === 'enemy' && !enemy.userData.isDead) {
                let damage = 15;
                
                // Vector Bonus
                if (player.flightMode === 'DECOUPLED' && player.velocity.length() > 50) {
                    damage *= 1.5;
                }
                
                enemy.userData.hp -= damage;
                
                if (window.flux.spawnHitParticles) window.flux.spawnHitParticles(hitPoint, direction.clone().negate());
                if (window.flux.showDamage) window.flux.showDamage(hitPoint, Math.floor(damage), false);
                
                if (enemy.userData.hp <= 0) {
                    if (window.flux.killEnemy) window.flux.killEnemy(enemy);
                } else {
                    if (enemy.traverse) {
                        enemy.traverse((child) => {
                            if (child.isMesh && child.material && child.material.emissive) {
                                child.material.emissive.setHex(0xffffff);
                                setTimeout(() => {
                                    if (child.material) child.material.emissive.setHex(child.userData.origEmissive || 0x000000);
                                }, 50);
                            }
                        });
                    }
                }
            }
        }
    }

    static fireMissiles(player) {
        player.isSpaceLocking = false;
        player.missileChargeTimer = 0;
        
        const targets = player.spaceLocks || [];
        
        if (targets.length === 0) {
            return;
        }
        
        for (let i = 0; i < targets.length; i++) {
            const target = targets[i];
            if (target.userData.isDead) continue;
            
            const startPos = player.mesh.position.clone();
            const offset = new THREE.Vector3(
                (i % 2 === 0 ? 2 : -2), 
                (i % 4 < 2 ? 1 : -1), 
                0
            ).applyQuaternion(player.mesh.quaternion);
            startPos.add(offset);
            
            setTimeout(() => {
                if (window.flux.spawnLaser) {
                    window.flux.spawnLaser(startPos, target.position, target);
                }
                if (window.flux.audio) window.flux.audio.play('missile_deploy');
            }, i * 50);
        }
        
        if (window.flux.spawnTechText) window.flux.spawnTechText(`SALVO: ${targets.length}`);
        
        player.spaceLocks = [];
    }

    // --- GROUND COMBAT METHODS ---

    static performAttack(player, isMassive = false) {
        const wallCheck = this.checkWallProximity(player, 3.5); 
        const isWallSlash = wallCheck.found;

        if (isWallSlash) {
            player.canWallJump = true; 
            player.velocity.set(0,0,0); 
            player.gravityScale = 0; 
            player.lastWallNormal.copy(wallCheck.normal);
            player.isDashing = false;
            player.dashTime = 0;
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("WALL SLASH");
        }

        if (player.isWallRunning || player.wasWallJump) {
            player.touchingWall = false;
            player.isWallRunning = false;
            player.wasWallJump = false; 
            player.velocity.x *= 0.1;
            player.velocity.z *= 0.1;
            if (player.velocity.y < 0) player.velocity.y = 0; 
            player.dashCooldown = 0; 
        }

        if (!player.onGround) {
            player.dashCooldown = 0; 
        }

        player.isAttacking = true;
        player.isHomingAttack = false; // Default to false
        player.hitEnemies.clear();
        player.currentSwingId += 1; 
        
        // CLEANUP PREVIOUS MESH
        if(player.activeSlashMesh) {
            if (player.activeSlashMesh.parent) player.activeSlashMesh.parent.remove(player.activeSlashMesh);
            player.activeSlashMesh = null;
        }

        if (isWallSlash) {
            player.attackType = 'WALL'; 
            player.activeComboStep = 0;
        } else if (player.isDashing) {
            player.attackType = 'DASH';
            player.isDashing = false; 
            player.activeComboStep = 99; 
            player.comboIndex = 0; 
        } else if (isMassive) {
            player.attackType = 'MASSIVE';
            player.activeComboStep = 100;
        } else {
            // Treat AIR same as GROUND for combo logic
            player.attackType = player.onGround ? 'GROUND' : 'AIR';
            player.activeComboStep = player.comboIndex; 
            
            if (!player.onGround) {
                player.gravityScale = 0.0; 
                player.velocity.y *= 0.5; 
            }
        }
        
        let target = player.targetEnemy;
        let isMagnetized = false;
        
        if (!target && window.flux && window.flux.enemies) {
            let nearestEnemy = null;
            let minDist = 10.0; 
            window.flux.enemies.forEach(e => {
                if (!e.userData.isDead) {
                    const dist = e.position.distanceTo(player.mesh.position);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestEnemy = e;
                    }
                }
            });
            if (nearestEnemy) target = nearestEnemy;
        }
        
        if (target && !target.userData.isDead && !isWallSlash) {
            const dist = player.mesh.position.distanceTo(target.position);
            
            // Force face target instantly
            const targetDir = new THREE.Vector3().subVectors(target.position, player.mesh.position);
            targetDir.y = 0; 
            if (targetDir.lengthSq() > 0.001) {
                targetDir.normalize();
                const targetAngle = Math.atan2(targetDir.x, targetDir.z);
                player.mesh.rotation.y = targetAngle;
            }

            // UPDATED: Increased height threshold to 4.0 to ensure player only uppercuts air enemies
            if (player.onGround && target.position.y > player.mesh.position.y + 4.0 && dist < 15.0) {
                player.attackType = 'LAUNCHER';
                player.activeComboStep = 77; 
                player.comboIndex = 0; // Reset combo so next air hit starts at 1
                player.velocity.y = 45; 
                player.onGround = false;
                const dir = new THREE.Vector3().subVectors(target.position, player.mesh.position).normalize();
                player.velocity.x = dir.x * 40; 
                player.velocity.z = dir.z * 40;
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("RISING SLASH");
            }
            // UPDATED: Reduced homing distance to 12.0 to prevent cross-map dashing
            else if (dist < 12.0) {
                 const dir = new THREE.Vector3().subVectors(target.position, player.mesh.position).normalize();
                 const targetDist = dist - 1.5; 
                 
                 if (targetDist > 0) {
                     const speed = targetDist / 0.15; 
                     const maxSpeed = 120; // Faster homing speed
                     const finalSpeed = Math.min(speed, maxSpeed);
                     
                     player.velocity.x = dir.x * finalSpeed;
                     player.velocity.z = dir.z * finalSpeed;
                     isMagnetized = true;
                     player.isHomingAttack = true; // Flag for physics to allow distance
                     
                     if (target.position.y > player.mesh.position.y + 1.0) {
                         player.velocity.y += 15; 
                     }
                 }
            }
        }
        
        if (isMassive) {
            if(window.flux.audio) window.flux.audio.play('slash_heavy');
        } else if (player.attackType === 'LAUNCHER') {
            if(window.flux.audio) window.flux.audio.play('launcher');
        } else {
            if (player.comboIndex === 2) {
                if(window.flux.audio) window.flux.audio.play('slash_finisher');
            } else if (player.comboIndex === 1) {
                if(window.flux.audio) window.flux.audio.play('slash_heavy');
            } else {
                if(window.flux.audio) window.flux.audio.play('slash_light');
            }
        }

        if (player.comboIndex > 2) player.comboIndex = 0;
        if (player.activeComboStep > 2 && (player.attackType === 'GROUND' || player.attackType === 'AIR')) player.activeComboStep = 0;
        
        let templateToClone = player.slashTemplate;
        if (((player.attackType === 'GROUND' || player.attackType === 'AIR') && player.activeComboStep === 2) || isMassive) {
            templateToClone = player.slashSpinTemplate;
        }

        player.activeSlashMesh = templateToClone.clone(true);
        player.activeSlashMesh.visible = true;
        player.activeSlashMesh.material = player.slashTemplate.material.clone();
        player.activeSlashMesh.material.opacity = 1.0;
        player.activeSlashMesh.material.transparent = true;
        
        player.activeSlashMesh.userData = {
            radius: 2.25, 
            sweepDirection: 1 
        };
        
        // ATTACH TO PLAYER MESH (LOCAL SPACE)
        player.mesh.add(player.activeSlashMesh);
        player.activeSlashMesh.position.set(0, 0, 0);
        player.activeSlashMesh.rotation.set(0, 0, 0);
        
        // Local Velocity (relative to player facing)
        player.slashVelocity.set(0,0,0);

        let dmgMult = 1.0;
        let speedMult = 1.0;
        
        // --- STYLE CONFIGURATION ---
        if (player.currentStyle === player.STYLE_DAGGER) {
            dmgMult = 0.6;
            speedMult = 1.5; // Fast
        } else if (player.currentStyle === player.STYLE_GREATSWORD) {
            dmgMult = 2.5;
            speedMult = 0.6; // Slow
        }
        
        if (player.isOverdrive) {
            speedMult *= 1.3;
            dmgMult *= 1.5;
        }

        // --- ATTACK TYPE LOGIC ---
        if (player.attackType === 'MASSIVE') {
            player.attackTotalDuration = 0.6 * (1/speedMult);
            player.activeSlashMesh.position.set(0, 1.0, 0);
            player.activeSlashMesh.rotateX(-Math.PI/2);
            player.activeSlashMesh.scale.set(3,3,3); 
            player.activeSlashMesh.userData.radius = 4.5;
            player.activeSlashMesh.material.color.setHex(0xffaa00); 
            
            // Impulse (World Space)
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(player.mesh.quaternion);
            player.velocity.addScaledVector(forward, 40); 
            player.kinematics.crouch.vel += 10; 
            
            if (window.flux && window.flux.spawnMassiveImpact) {
                window.flux.spawnMassiveImpact(player.mesh.position.clone().addScaledVector(forward, 2));
            }
        }
        else if (player.attackType === 'LAUNCHER') {
             player.attackTotalDuration = 0.4 * (1/speedMult);
             player.activeSlashMesh.position.set(0, 2.0, 0);
             player.activeSlashMesh.rotateX(-Math.PI/2); 
             player.activeSlashMesh.rotateZ(Math.PI/2); 
             player.activeSlashMesh.scale.set(2.5, 2.5, 2.5);
             player.activeSlashMesh.userData.radius = 3.75;
             player.activeSlashMesh.material.color.setHex(0xff00ff);
        }
        else if (player.attackType === 'DASH') {
            player.attackTotalDuration = 0.3 * (1/speedMult);
            const rotY = player.mesh.rotation.y;
            player.velocity.x = Math.sin(rotY) * 40; 
            player.velocity.z = Math.cos(rotY) * 40; 
            player.velocity.y = 5; 
            
            player.activeSlashMesh.position.set(0, 1.2, 1.5);
            player.activeSlashMesh.rotateY(Math.PI/2);
            player.activeSlashMesh.rotateZ(Math.PI/2); 
            
            // Local Z velocity for the slash mesh
            player.slashVelocity.z = 20; 
        } 
        else if (player.attackType === 'WALL') {
            player.attackTotalDuration = 0.35 * (1/speedMult);
            
            player.activeSlashMesh.position.set(0, 1.0, 1.0);
            player.activeSlashMesh.rotateY(-Math.PI/2); 
            player.activeSlashMesh.rotateZ(-Math.PI/4);
            player.activeSlashMesh.scale.set(2,2,2);
            player.activeSlashMesh.userData.radius = 3.0;
            player.slashVelocity.y = -2; 
        }
        else {
            // --- COMBO LOGIC (GROUND AND AIR) ---
            const durationMap = [0.25, 0.25, 0.45];
            player.attackTotalDuration = durationMap[player.comboIndex] * (1/speedMult);
            const rotY = player.mesh.rotation.y;
            
            // Lunge speed based on style
            let lungeSpeed = (player.comboIndex === 2 ? 80 : 60); 
            if (player.currentStyle === player.STYLE_DAGGER) lungeSpeed = 40; // Shorter lunges
            if (player.currentStyle === player.STYLE_GREATSWORD) lungeSpeed = 100; // Heavy momentum
            
            if (!isMagnetized) { 
                player.velocity.x += Math.sin(rotY) * lungeSpeed;
                player.velocity.z += Math.cos(rotY) * lungeSpeed;
            }
            player.kinematics.tiltX.vel += 2.0; 
            
            const currentStep = player.comboIndex;

            // --- WEAPON ARTS (MESH CONFIG) ---
            if (player.currentStyle === player.STYLE_DAGGER) {
                // RAPID STABS
                player.activeSlashMesh.scale.set(0.5, 3.0, 1.0); // Long thin thrust
                player.activeSlashMesh.position.set(0, 1.2, 1.5);
                player.activeSlashMesh.rotateX(Math.PI/2); // Point forward
                player.activeSlashMesh.userData.radius = 2.0;
                // Alternate hands visually (simulated by offset)
                player.activeSlashMesh.position.x = (currentStep % 2 === 0) ? 0.5 : -0.5;

                // --- JUICE: DAGGER SNAPPY THRUST ---
                if (window.flux && window.flux.shake) window.flux.shake(0.2); // Light percussive shake
                if (window.game && window.game.camPosSpring) {
                    window.game.camPosSpring.add(new THREE.Vector3(0, 0, -0.5).applyQuaternion(player.mesh.quaternion)); // Push camera forward briefly
                }
            } 
            else if (player.currentStyle === player.STYLE_GREATSWORD) {
                // HEAVY CLEAVES
                player.activeSlashMesh.scale.set(3.0, 3.0, 2.0); // Massive
                player.activeSlashMesh.userData.radius = 4.0;
                
                if (currentStep === 2) {
                    // Vertical Slam
                    player.activeSlashMesh.position.set(0, 2.0, 2.0);
                    player.activeSlashMesh.rotateY(Math.PI/2);
                } else {
                    // Wide Horizontal
                    player.activeSlashMesh.position.set(0, 1.0, 0);
                    player.activeSlashMesh.rotateX(-Math.PI/2);
                }
            }
            else {
                // KATANA (Standard)
                if (currentStep === 0) {
                    player.activeSlashMesh.position.set(0, 1.4, 1.0);
                    player.activeSlashMesh.rotateY(-Math.PI/2);
                    player.activeSlashMesh.rotateZ(-Math.PI/3);
                    player.activeSlashMesh.scale.set(1.5, 1.5, 1.5);
                    player.activeSlashMesh.userData.radius = 2.25;
                    player.slashVelocity.z = 5;
                } else if (currentStep === 1) {
                    player.activeSlashMesh.position.set(0, 1.2, 1.0);
                    player.activeSlashMesh.rotateX(-Math.PI/2);
                    player.activeSlashMesh.rotateZ(Math.PI);
                    player.activeSlashMesh.scale.set(1.5, 1.5, 1.5);
                    player.activeSlashMesh.userData.radius = 2.25;
                    player.slashVelocity.z = 5;
                } else {
                    player.activeSlashMesh.position.set(0, 1.0, 0);
                    player.activeSlashMesh.rotateX(-Math.PI/2); 
                    player.activeSlashMesh.rotateZ(Math.PI);
                    player.activeSlashMesh.scale.set(2.0, 2.0, 2.0);
                    player.activeSlashMesh.userData.radius = 3.0;
                }
            }
        }
        
        player.attackTimer = player.attackTotalDuration;
        
        if (player.attackType !== 'MASSIVE' && player.attackType !== 'LAUNCHER') {
            const isHeavy = (player.comboIndex === 2 || player.attackType === 'DASH');
            let slashColor = isHeavy ? 0xff0000 : 0x00ffff;
            if (player.currentStyle === player.STYLE_DAGGER) slashColor = 0x00ff00;
            if (player.currentStyle === player.STYLE_GREATSWORD) slashColor = 0xffaa00;
            if (player.isOverdrive) slashColor = 0xff0055; 
            player.activeSlashMesh.material.color.setHex(slashColor);
        }
        
        if (player.attackType === 'GROUND' || player.attackType === 'AIR') {
            player.comboIndex += 1;
        }
        player.comboTimer = player.comboMaxTime;
    }

    static updateAttack(player, dt) {
        if (!player.isAttacking) return;

        player.attackTimer -= dt;
        const progress = 1.0 - (player.attackTimer / player.attackTotalDuration);
        
        // Calculate Tip Position in World Space
        const tipLocal = new THREE.Vector3(0, 0, 3.5); 
        player.handR.updateMatrixWorld(true);
        const handWorld = player.handR.matrixWorld; 
        player.currentTipPos.copy(tipLocal).applyMatrix4(handWorld);
        
        if (player.activeSlashMesh) {
            if (progress > 0.5) {
                const fade = 1.0 - ((progress - 0.5) * 2);
                player.activeSlashMesh.material.opacity = fade;
            }
            // Move locally
            player.activeSlashMesh.position.add(player.slashVelocity.clone().multiplyScalar(dt));
            
            const scaleUp = 1.0 + (dt * 0.5); 
            player.activeSlashMesh.scale.multiplyScalar(scaleUp);
        }

        const hitStart = 0.05; 
        const hitEnd = 0.7;
        
        if (progress >= hitStart && progress <= hitEnd) {
            this.checkHitsSweeping(player);
            if (window.flux && window.flux.spawnTrail) {
                window.flux.spawnTrail(player.prevTipPos, player.currentTipPos);
            }
        }
        
        // Apply Friction toward end of attack to prevent momentum abuse
        if (progress > 0.6) {
             // Strong damping at the end of the slash
             player.velocity.multiplyScalar(0.6); 
        }

        if (player.attackTimer <= 0) {
            player.isAttacking = false;
            player.isHomingAttack = false; // Reset homing flag
            player.gravityScale = 1.0; 
            
            // STOP MOVEMENT COMPLETELY - Prevent abuse of staying airborne
            player.velocity.set(0, 0, 0);
            
            if(player.activeSlashMesh) {
                if(player.activeSlashMesh.parent) player.activeSlashMesh.parent.remove(player.activeSlashMesh);
                player.activeSlashMesh = null;
            }
        }
        
        player.prevTipPos.copy(player.currentTipPos);
    }

    static checkHitsSweeping(player) {
        const playerPos = player.mesh.position;
        const lineStart = player.prevTipPos;
        const lineEnd = player.currentTipPos;
        
        // Use static vectors to avoid GC
        _pcVec1.subVectors(lineEnd, lineStart); // lineVec
        const lineLenSq = _pcVec1.lengthSq();
        
        if (lineLenSq < 0.01) return; 

        // --- NEW: BACKGROUND SWARM COLLISION ---
        if (window.flux.spawnSystem && window.flux.spawnSystem.backgroundSwarmMesh && window.flux.spawnSystem.backgroundSwarmMesh.visible) {
            const sys = window.flux.spawnSystem;
            if (sys.currentSwarmPositions && sys.swarmAlive) {
                // Iterate through background instances
                for(let i=0; i<sys.swarmTotal; i++) {
                    if (sys.swarmAlive[i] === 0) continue; // Skip dead
                    
                    // Get position from array
                    _pcVec2.set(sys.currentSwarmPositions[i*3], sys.currentSwarmPositions[i*3+1], sys.currentSwarmPositions[i*3+2]);
                    
                    // Project point onto line segment
                    _pcVec3.subVectors(_pcVec2, lineStart); // toEnemy
                    const t = Math.max(0, Math.min(1, _pcVec3.dot(_pcVec1) / lineLenSq));
                    
                    // Closest point on line
                    _pcVec4.copy(lineStart).addScaledVector(_pcVec1, t);
                    
                    const distSq = _pcVec4.distanceToSquared(_pcVec2);
                    const hitDistSq = 16.0; // 4.0 radius for easy hitting

                    if (distSq < hitDistSq) {
                        // KILL IT
                        sys.killBackgroundInstance(i);
                        
                        // Feedback
                        if (window.flux.spawnHitParticles) {
                            window.flux.spawnHitParticles(_pcVec2, new THREE.Vector3(0,1,0));
                        }
                        if (window.flux.hitStop) window.flux.hitStop(0.05);
                    }
                }
            }
        }

        if (player.staticGroup) {
             player.staticGroup.traverse(obj => {
                 if (obj.userData.type === 'barrel' && obj.visible) {
                     if (obj.position.distanceToSquared(playerPos) < 16.0) { // 4.0^2
                         if (window.flux && window.flux.explode) {
                             window.flux.explode(obj.position.clone());
                             obj.position.y = -500;
                             obj.visible = false;
                         }
                     }
                 }
             });
        }

        if (!window.flux || !window.flux.enemies) return;
        const enemies = window.flux.enemies;

        for(let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            
            if (!enemy || !enemy.userData) continue;
            if (enemy.userData.isDead || (enemy.userData.lastHitBySwing === player.currentSwingId)) continue;

            // Reuse vectors for distance check
            _pcVec2.copy(enemy.position); // enemyPos
            _pcVec2.y += 1.0; 
            
            // Project point onto line segment
            _pcVec3.subVectors(_pcVec2, lineStart); // toEnemy
            const t = Math.max(0, Math.min(1, _pcVec3.dot(_pcVec1) / lineLenSq));
            
            // Closest point on line
            _pcVec4.copy(lineStart).addScaledVector(_pcVec1, t);
            
            const distSq = _pcVec4.distanceToSquared(_pcVec2);
            const hitDistSq = (player.attackType === 'MASSIVE') ? 25.0 : 12.25; // 5.0^2 or 3.5^2

            if (distSq < hitDistSq) {
                enemy.userData.lastHitBySwing = player.currentSwingId;
                
                player.hitDirection.subVectors(enemy.position, playerPos).normalize();
                if (player.hitDirection.lengthSq() < 0.001) player.hitDirection.set(0, 0, 1);
                player.hitDirection.y = 0.2;
                player.hitDirection.normalize();

                let isCrit = (player.attackType === 'DASH' || player.comboIndex === 3 || player.attackType === 'MASSIVE');

                if (enemy.userData.hp !== undefined) {
                    let dmg = 100; 
                    let staggerPower = 20; // Default poise damage
                    
                    if (player.currentStyle === player.STYLE_DAGGER) { dmg = 60; staggerPower = 10; }
                    if (player.currentStyle === player.STYLE_GREATSWORD) { dmg = 240; staggerPower = 60; }

                    if (player.attackType === 'DASH') { dmg *= 1.5; staggerPower += 20; }
                    if (player.comboIndex === 3) { dmg *= 2.0; staggerPower += 30; }
                    if (player.attackType === 'MASSIVE') { dmg *= 3.0; staggerPower = 100; } 
                    
                    // --- MOMENTUM-AUGMENTED DAMAGE (DROPKICK) ---
                    // Explicit check for high downward velocity
                    if (player.velocity.y < -15) {
                        const momentumBonus = Math.abs(player.velocity.y) * 3.0; // Significant scaling
                        dmg += momentumBonus;
                        staggerPower += 50; // Guaranteed heavy stagger
                        isCrit = true;
                        
                        // Visual Feedback
                        if (window.flux.spawnTechText) window.flux.spawnTechText("GRAVITY CRUSH");
                        if (window.flux.shake) window.flux.shake(1.0);
                        if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(enemy.position);
                    }
                    
                    if (player.isOverdrive) dmg *= 1.5; 

                    if (enemy.userData.enemyType) {
                        if (enemy.userData.enemyType === 'standard') {
                             dmg = enemy.userData.maxHp + 1; 
                             isCrit = true;
                        } else if (enemy.userData.enemyType === 'gargantua') {
                             dmg *= 0.5; 
                             if (Math.random() > 0.8 && window.flux && window.flux.showDamage) {
                                 window.flux.showDamage(enemy.position, "RESIST", false);
                             }
                        }
                    }
                    
                    // --- SHIELD DAMAGE LOGIC ---
                    let shieldAbsorbed = false;
                    if (enemy.userData.shieldHp > 0) {
                        enemy.userData.shieldHp -= dmg;
                        shieldAbsorbed = true;
                        
                        // Visual Feedback for Shield Hit
                        if (window.flux.spawnParticles) window.flux.spawnParticles(enemy.position, 5, 0x00ffff, 15); // Blue sparks
                        
                        if (enemy.userData.shieldHp <= 0) {
                            // SHIELD BREAK!
                            enemy.userData.shieldHp = 0;
                            if (window.flux.spawnTechText) window.flux.spawnTechText("SHIELD BREAK");
                            if (window.flux.audio) window.flux.audio.play('massive_impact');
                            
                            // Force Stagger
                            if (enemy.userData.controller && typeof enemy.userData.controller.stagger === 'function') {
                                enemy.userData.controller.stagger(100);
                            }
                            
                            // Overflow damage to HP? Let's say no for now, break consumes the hit.
                            dmg = 0; 
                        } else {
                            // Shield held
                            dmg = 0; // No HP damage
                            if (window.flux.showDamage) window.flux.showDamage(enemy.position, "SHIELD", false);
                        }
                    }
                    
                    // --- HYPER-ARMOR (EFFICIENCY GATE) LOGIC ---
                    if (!shieldAbsorbed && enemy.userData.controller && enemy.userData.controller.config && enemy.userData.controller.config.hyperArmor) {
                        // If attack is light (dagger or basic combo), reduce damage and style
                        if (staggerPower < 40) { // Threshold for breaking armor
                            dmg *= 0.2; // Massive damage reduction
                            isCrit = false;
                            if (window.flux.spawnTechText) window.flux.spawnTechText("ARMOR DEFLECT");
                            if (window.flux.audio) window.flux.audio.play('block'); // Clank sound
                            
                            // Penalty: Reduce style rank (simulated by NOT adding combo)
                            // We don't increment combo here to punish spamming light attacks
                            if (window.flux.addCombo) window.flux.addCombo(0.1); // Poor quality
                            
                        } else {
                            // Break armor!
                            if (window.flux.spawnTechText) window.flux.spawnTechText("ARMOR BREAK");
                            if (window.flux.audio) window.flux.audio.play('massive_impact');
                            enemy.userData.controller.stagger(100); // Force stagger
                            if (window.flux.addCombo) window.flux.addCombo(1.0);
                        }
                    } else {
                        // Normal Stagger
                        if (enemy.userData.controller && typeof enemy.userData.controller.stagger === 'function') {
                            enemy.userData.controller.stagger(staggerPower);
                        }
                        if (window.flux.addCombo) window.flux.addCombo(1.0);
                    }
                    
                    // Apply HP Damage (if any left after shield/armor)
                    if (dmg > 0) {
                        enemy.userData.hp -= dmg;
                        
                        if (enemy.userData.springs) {
                            enemy.userData.springs.scale.vel = -5.0; 
                            enemy.userData.springs.tiltX.vel = 5.0; 
                        }

                        if(window.flux && window.flux.showDamage) {
                            window.flux.showDamage(enemy.position, Math.floor(dmg), isCrit);
                        }
                        
                        if (enemy.userData.hp <= 0) {
                            if (window.flux && window.flux.killEnemy) {
                                window.flux.killEnemy(enemy);
                            }
                        } else {
                            if (typeof flashEnemy === 'function') flashEnemy(enemy);
                            if(window.flux.audio && !enemy.userData.controller?.config?.hyperArmor) window.flux.audio.play('hit_flesh');
                            if (window.flux.hitStop) window.flux.hitStop(0.08); 
                            if (window.flux.shake) window.flux.shake(0.3); 
                            
                            // NEW: JUICE ON CRIT/FINISHER
                            if (isCrit || player.attackType === 'MASSIVE') {
                                if (window.flux.triggerZoom) window.flux.triggerZoom(0.85, 0.2); // Zoom in
                                if (window.flux.impactStop) window.flux.impactStop(0.15); // Hard freeze
                            }
                        }
                    }
                }
                
                let force = 0.5; 
                let upForce = 10;
                if (player.attackType === 'DASH') { force = 2.0; upForce = 10; }
                if (player.attackType === 'LAUNCHER') { force = 0.1; upForce = 40; } 
                if (player.attackType === 'MASSIVE') { force = 8.0; upForce = 50; } 
                
                // Style specific knockback
                if (player.currentStyle === player.STYLE_DAGGER) { force *= 0.5; upForce *= 0.5; }
                if (player.currentStyle === player.STYLE_GREATSWORD) { force *= 2.0; upForce *= 1.5; }
                
                // Hyper Armor resists knockback
                if (enemy.userData.controller?.config?.hyperArmor) {
                    force *= 0.1;
                    upForce = 0;
                }
                
                if (enemy.userData.velocity) {
                    player.tempVec.copy(player.hitDirection).multiplyScalar(force * 25); 
                    enemy.userData.velocity.add(player.tempVec);
                    enemy.userData.velocity.y += upForce; 
                    enemy.userData.onGround = false; 
                }
                
                if (distSq < 25.0) { // 5.0^2
                    player.velocity.x *= 0.1;
                    player.velocity.z *= 0.1;
                    
                    if (!player.onGround) {
                        player.velocity.y += 10; 
                    }
                }
                
                if (!player.onGround && player.velocity.y > -10.0 && enemy.userData.hp > 0) {
                    player.dashCooldown = 0;
                    player.jumpBufferTimer = player.jumpBufferMax; 
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("AIR JUGGLE");
                }

                if (window.flux && window.flux.spawnHitParticles) {
                    window.flux.spawnHitParticles(enemy.position, player.hitDirection);
                }
                
                // Heavy Hit Effect
                if (isCrit || player.currentStyle === player.STYLE_GREATSWORD) {
                    if (window.flux.spawnDistortion) window.flux.spawnDistortion(enemy.position);
                }
            }
        }
    }

    static checkBlockCollision(player) {
        if (!window.flux || !window.flux.enemies) return;
        const enemies = window.flux.enemies;
        const playerPos = player.mesh.position;

        for(let i=0; i<enemies.length; i++) {
            const enemy = enemies[i];
            if(!enemy || enemy.userData.isDead) continue;
            
            player.tempVec.copy(enemy.position).sub(playerPos);
            const distSq = player.tempVec.lengthSq();
            if (distSq < 4.0) { // 2.0^2
                player.tempVec.normalize().multiplyScalar(0.5);
                enemy.position.add(player.tempVec); 
                if (window.flux && window.flux.spawnBlockParticles) {
                    player.tempOrigin.copy(playerPos).add(player.tempVec); 
                    window.flux.spawnBlockParticles(player.tempOrigin);
                }
            }
        }
    }

    static checkWallProximity(player, distance) {
        const rotY = player.mesh.rotation.y;
        const forward = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
        
        player.raycaster.set(player.mesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)), forward);
        player.raycaster.far = distance;
        
        if (player.staticGroup && player.staticGroup.children.length > 0) {
            const intersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
            if (intersects.length > 0) {
                return { found: true, normal: intersects[0].face.normal.clone(), distance: intersects[0].distance };
            }
        }
        return { found: false, normal: new THREE.Vector3() };
    }

    static shoot(player, camera) {
        if (player.ammo <= 0) {
             if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("RELOAD");
             if (window.flux.audio) window.flux.audio.play('switch');
             return;
        }

        if (player.currentWeapon === player.WEAPON_BEAM) {
            player.ammo--;
            player.fireTimer = 0.8; 
            player.updateHUD();

            if (window.flux && window.flux.shake) window.flux.shake(1.2); 
            if (window.flux.audio) window.flux.audio.play('laser_fire'); 
            
            player.kinematics.weaponSwayX.vel += 5.0; 
            player.kinematics.tiltX.vel += 3.0;
            player.velocity.add(new THREE.Vector3(0, 0, 1).applyQuaternion(player.mesh.quaternion).multiplyScalar(5.0));

            if (!player.muzzlePoint) return;
            
            const rayOrigin = player.muzzlePoint.position.clone();
            player.muzzlePoint.updateWorldMatrix(true, false);
            player.muzzlePoint.getWorldPosition(rayOrigin);

            // CONVERGENT AIMING LOGIC
            let targetPoint;
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            
            const farAim = camera.position.clone().add(camDir.multiplyScalar(100.0));
            
            player.raycaster.set(camera.position, camDir);
            player.raycaster.far = 2000;
            
            let camHit = null;
            let minDist = 9999;
            
            if (player.enemyGroup && player.enemyGroup.children.length > 0) {
                const intersects = player.raycaster.intersectObjects(player.enemyGroup.children, true);
                if (intersects.length > 0) {
                    camHit = intersects[0];
                    minDist = camHit.distance;
                }
            }
            
            if (player.staticGroup && player.staticGroup.children.length > 0) {
                const worldIntersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
                if (worldIntersects.length > 0) {
                    if (worldIntersects[0].distance < minDist) {
                        camHit = worldIntersects[0];
                    }
                }
            }
            
            if (camHit) {
                const isFloor = camHit.face && camHit.face.normal.y > 0.5;
                if (isFloor && camHit.distance < 50.0) {
                    targetPoint = farAim; 
                } else {
                    targetPoint = camHit.point;
                }
            } else {
                targetPoint = farAim;
            }
            
            if (player.targetEnemy) {
                 targetPoint = player.targetEnemy.position.clone().add(new THREE.Vector3(0, 0.5, 0));
            } else if (!player.isFirstPerson) {
                 const rotY = player.mesh.rotation.y;
                 const forward = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
                 targetPoint = rayOrigin.clone().add(forward.multiplyScalar(100));
            }
            
            const gunForward = new THREE.Vector3().subVectors(targetPoint, rayOrigin).normalize();

            player.raycaster.set(rayOrigin, gunForward);
            player.raycaster.far = 2000;
            
            let hitPoint = rayOrigin.clone().add(gunForward.clone().multiplyScalar(100));
            let hitEnemy = null;
            minDist = 9999;

            if (player.enemyGroup && player.enemyGroup.children.length > 0) {
                const intersects = player.raycaster.intersectObjects(player.enemyGroup.children, true);
                if (intersects.length > 0) {
                    if (intersects[0].distance < minDist) {
                        minDist = intersects[0].distance;
                        hitPoint = intersects[0].point;
                        let obj = intersects[0].object;
                        while(obj.parent && !obj.userData.type) {
                            obj = obj.parent;
                        }
                        if (obj.userData.type === 'enemy') hitEnemy = obj;
                    }
                }
            }
            
            if (player.staticGroup && player.staticGroup.children.length > 0) {
                const worldIntersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
                if (worldIntersects.length > 0) {
                    if (worldIntersects[0].distance < minDist) {
                        minDist = worldIntersects[0].distance;
                        hitPoint = worldIntersects[0].point;
                        hitEnemy = null; 
                    }
                }
            }

            if (window.flux && window.flux.firePlayerBeam) {
                window.flux.firePlayerBeam(rayOrigin, hitPoint);
            }

            if (hitEnemy && !hitEnemy.userData.isDead) {
                let damage = 80; 
                if (player.isOverdrive) damage = 120;
                
                hitEnemy.userData.hp -= damage;
                
                if (window.flux && window.flux.showDamage) {
                    window.flux.showDamage(hitPoint, Math.floor(damage), true);
                }
                
                if (window.flux && window.flux.spawnHitParticles) window.flux.spawnHitParticles(hitPoint, gunForward.clone().multiplyScalar(-1));
                
                if (hitEnemy.userData.hp <= 0) {
                    if (window.flux && window.flux.killEnemy) window.flux.killEnemy(hitEnemy);
                } else {
                    if (typeof flashEnemy === 'function') flashEnemy(hitEnemy);
                }
            } else {
                if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(hitPoint, 10, 0x00ffff, 20);
            }

            return;
        }

        player.ammo--;
        player.fireTimer = player.fireRate;
        player.updateHUD();

        if (window.flux && window.flux.shake) window.flux.shake(0.8); 
        if (window.flux.audio) window.flux.audio.play('shotgun');
        
        if (window.flux && window.flux.flickerPlayerLight) {
            window.flux.flickerPlayerLight(0xffaa00, 0.1);
        }

        player.kinematics.weaponSwayX.vel += 2.0; 
        player.kinematics.tiltX.vel += 1.0;

        if (!player.muzzlePoint) return;
        
        const rayOrigin = player.muzzlePoint.position.clone();
        player.muzzlePoint.updateWorldMatrix(true, false);
        player.muzzlePoint.getWorldPosition(rayOrigin);

        let targetPoint;
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        
        const farAim = camera.position.clone().add(camDir.multiplyScalar(100.0));
        
        player.raycaster.set(camera.position, camDir);
        player.raycaster.far = 2000;
        
        let camHit = null;
        let minDist = 9999;
        
        if (player.enemyGroup && player.enemyGroup.children.length > 0) {
            const intersects = player.raycaster.intersectObjects(player.enemyGroup.children, true);
            if (intersects.length > 0) {
                camHit = intersects[0];
                minDist = camHit.distance;
            }
        }
        
        if (player.staticGroup && player.staticGroup.children.length > 0) {
            const worldIntersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
            if (worldIntersects.length > 0) {
                if (worldIntersects[0].distance < minDist) {
                    camHit = worldIntersects[0];
                }
            }
        }
        
        if (camHit) {
            const isFloor = camHit.face && camHit.face.normal.y > 0.5;
            if (isFloor && camHit.distance < 50.0) {
                targetPoint = farAim; 
            } else {
                targetPoint = camHit.point;
            }
        } else {
            targetPoint = farAim;
        }

        if (player.targetEnemy) {
             targetPoint = player.targetEnemy.position.clone().add(new THREE.Vector3(0, 1, 0));
        } else if (!player.isFirstPerson) {
             const rotY = player.mesh.rotation.y;
             const forward = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
             targetPoint = rayOrigin.clone().add(forward.multiplyScalar(100));
        }
        
        const gunForward = new THREE.Vector3().subVectors(targetPoint, rayOrigin).normalize();

        if (window.flux && window.flux.spawnShell) {
            const shellDir = new THREE.Vector3(1, 0.5, 0).applyQuaternion(player.mesh.quaternion);
            window.flux.spawnShell(rayOrigin, shellDir);
        }

        if (window.flux && window.flux.spawnParticles) {
            window.flux.spawnParticles(rayOrigin, 15, 0xffffaa, 8); 
        }

        const pelletCount = 8; 
        const pelletDamage = 25; 
        
        for(let i=0; i<pelletCount; i++) {
            player.pelletOrigin.copy(rayOrigin);
            player.pelletDir.copy(gunForward);
            
            const spread = 0.08; 
            player.pelletDir.x += (Math.random() - 0.5) * spread;
            player.pelletDir.y += (Math.random() - 0.5) * spread;
            player.pelletDir.z += (Math.random() - 0.5) * spread;
            player.pelletDir.normalize();

            player.raycaster.set(player.pelletOrigin, player.pelletDir);
            player.raycaster.far = 1000;

            let hitEnemy = null;
            let hitPoint = null;
            let minDist = 999;

            if (player.enemyGroup && player.enemyGroup.children.length > 0) {
                const intersects = player.raycaster.intersectObjects(player.enemyGroup.children, true);
                if (intersects.length > 0) {
                    if (intersects[0].distance < minDist) {
                        minDist = intersects[0].distance;
                        hitPoint = intersects[0].point;
                        let obj = intersects[0].object;
                        while(obj.parent && !obj.userData.type) {
                            obj = obj.parent;
                        }
                        if (obj.userData.type === 'enemy') hitEnemy = obj;
                    }
                }
            }
            
            if (player.staticGroup && player.staticGroup.children.length > 0) {
                const worldIntersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
                if (worldIntersects.length > 0) {
                    if (worldIntersects[0].distance < minDist) {
                        minDist = worldIntersects[0].distance;
                        hitPoint = worldIntersects[0].point;
                        let obj = worldIntersects[0].object;
                        while(obj.parent && !obj.userData.type) {
                            obj = obj.parent;
                        }
                        if (obj.userData.type === 'barrel') {
                            if (window.flux && window.flux.explode) {
                                window.flux.explode(obj.position.clone());
                                obj.position.y = -500; 
                                obj.visible = false; 
                            }
                        }
                        hitEnemy = null; 
                    }
                }
            }

            if (window.flux && window.flux.spawnTrail && Math.random() > 0.3) {
                const endPos = hitPoint ? hitPoint : player.pelletOrigin.clone().add(player.pelletDir.clone().multiplyScalar(100));
                window.flux.spawnTrail(rayOrigin, endPos);
            }

            if (hitEnemy && !hitEnemy.userData.isDead) {
                let actualDamage = pelletDamage;
                if (hitEnemy.userData.enemyType === 'gargantua') {
                    actualDamage *= 0.5; 
                    if (Math.random() > 0.9 && window.flux && window.flux.showDamage) {
                        window.flux.showDamage(hitEnemy.position, "RESIST", false);
                    }
                }
                
                // Hyper-Armor Check for Pellets
                if (hitEnemy.userData.controller?.config?.hyperArmor) {
                    actualDamage *= 0.5; // Resists small arms
                }
                
                // --- SHIELD DAMAGE ---
                if (hitEnemy.userData.shieldHp > 0) {
                    hitEnemy.userData.shieldHp -= actualDamage;
                    if (hitEnemy.userData.shieldHp <= 0) {
                        hitEnemy.userData.shieldHp = 0;
                        if (window.flux.spawnTechText) window.flux.spawnTechText("SHIELD BREAK");
                    }
                    if (window.flux.spawnParticles) window.flux.spawnParticles(hitEnemy.position, 2, 0x00ffff, 10);
                    actualDamage = 0; // Absorbed
                }
                
                if (actualDamage > 0) {
                    hitEnemy.userData.hp -= actualDamage;
                    
                    if (hitEnemy.userData.springs) {
                        hitEnemy.userData.springs.scale.vel = -5.0; 
                        hitEnemy.userData.springs.tiltX.vel = 5.0; 
                    }

                    if (window.flux && window.flux.showDamage) {
                        const dmgPos = hitPoint ? hitPoint.clone() : hitEnemy.position.clone();
                        dmgPos.x += (Math.random() - 0.5) * 0.5;
                        dmgPos.y += (Math.random() - 0.5) * 0.5;
                        window.flux.showDamage(dmgPos, Math.floor(actualDamage), false);
                    }
                    
                    if (window.flux && window.flux.spawnHitParticles) window.flux.spawnHitParticles(hitPoint || hitEnemy.position, player.pelletDir.clone().multiplyScalar(-1));
                    if (window.flux.audio) window.flux.audio.play('hit_flesh');
                    
                    if (hitEnemy.userData.hp <= 0) {
                        if (window.flux && window.flux.killEnemy) window.flux.killEnemy(hitEnemy);
                    } else {
                        if (typeof flashEnemy === 'function') flashEnemy(hitEnemy);
                    }
                }
            } else if (hitPoint) {
                if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(hitPoint, 3, 0xcccccc, 10);
                // REMOVED DEBRIS SPAWN
                if (window.flux.audio) window.flux.audio.play('hit_wall');
            }
        }
    }

    static chargeHomingLasers(player, dt) {
        if (player.ammo <= 0) {
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("RELOAD");
            return;
        }

        player.isCharging = true;
        player.attackHoldTimer = (player.attackHoldTimer || 0) + dt * (player.isOverdrive ? 2.0 : 1.0);
        
        const maxLocks = 8;
        const lockInterval = 0.25;
        
        const desiredLocks = Math.min(maxLocks, Math.floor(player.attackHoldTimer / lockInterval) + 1);
        
        if (player.spaceLocks.length < desiredLocks) {
            this.acquireNewLock(player);
        }
        
        if (window.flux.spawnTechText && window.flux.audio) {
             if (player.spaceLocks.length === 0) {
                 window.flux.spawnTechText("ACQUIRING TARGETS");
             } else {
                 window.flux.spawnTechText(`LOCKS: ${player.spaceLocks.length}`);
             }
        }
        
        player.attackHoldTimer = Math.min(2.0, player.attackHoldTimer);
    }
    
    static acquireNewLock(player) {
        const lockRange = 80;
        let nearestEnemy = null;
        let minDist = lockRange;
        
        const lockedEnemies = player.spaceLocks.map(l => l.uuid);
        
        if (window.flux.enemies) {
            window.flux.enemies.forEach(e => {
                if (!e.userData.isDead && e.position.distanceTo(player.mesh.position) < lockRange) {
                    const dist = e.position.distanceTo(player.mesh.position);
                    
                    let score = dist;
                    if (lockedEnemies.includes(e.uuid)) score += 5; 
                    
                    if (score < minDist) {
                        minDist = score;
                        nearestEnemy = e;
                    }
                }
            });
        }
        
        if (nearestEnemy) {
            player.spaceLocks.push(nearestEnemy);
            player.ammo--;
            player.updateHUD();
            if (window.flux.audio) window.flux.audio.play('lock');
        }
    }
    
    static releaseHomingLasers(player) {
        player.isCharging = false;
        player.attackHoldTimer = 0;
        
        const targets = player.spaceLocks || [];
        
        if (targets.length === 0) {
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("LOCK FAILED");
            return;
        }
        
        if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText(`SALVO: ${targets.length}`);
        
        for (let i = 0; i < targets.length; i++) {
            const target = targets[i];
            if (target.userData.isDead) continue;
            
            const startPos = player.mesh.position.clone();
            const offset = new THREE.Vector3(
                (i % 2 === 0 ? 0.5 : -0.5), 
                2, 
                0
            ).applyQuaternion(player.mesh.quaternion);
            startPos.add(offset);
            
            setTimeout(() => {
                if (window.flux.spawnLaser) {
                    window.flux.spawnLaser(startPos, target.position, target);
                }
                if (window.flux.audio) window.flux.audio.play('missile_deploy');
            }, i * 50);
        }
        
        player.kinematics.tiltX.vel += 5.0 * targets.length * 0.1;
        player.velocity.y += 2 * targets.length * 0.1;
        
        player.spaceLocks = [];
    }

    static startReload(player) {
        player.isReloading = true;
        player.reloadTimer = player.reloadDuration;
        player.fireTimer = 0;
        if(window.flux.audio) window.flux.audio.play('reload');
        player.updateHUD();
    }
    
    static finishReload(player) {
        player.isReloading = false;
        player.ammo = player.maxAmmo;
        player.updateHUD();
    }

    static switchWeapon(player) {
        if (player.currentWeapon === player.WEAPON_MELEE) {
            player.currentWeapon = player.WEAPON_RANGED;
        } else if (player.currentWeapon === player.WEAPON_RANGED) {
            player.currentWeapon = player.WEAPON_BEAM;
        } else {
            player.currentWeapon = player.WEAPON_MELEE;
        }
        
        if(window.flux.audio) window.flux.audio.play('switch');
        
        if (player.isAttacking) {
            player.isAttacking = false;
            if(player.activeSlashMesh) {
                if(player.activeSlashMesh.parent) player.activeSlashMesh.parent.remove(player.activeSlashMesh);
                player.activeSlashMesh = null;
            }
            player.attackTimer = 0;
            player.fireTimer = 0; 
        }
        
        if (player.isReloading) {
            player.isReloading = false;
        }
        
        if (player.landingLag > 0) {
            player.landingLag = 0;
        }

        if (!player.onGround) {
            player.velocity.x *= 0.8; 
            player.velocity.z *= 0.8;
        }

        if (!player.isFirstPerson) {
            if (player.swordGroup) player.swordGroup.visible = (player.currentWeapon === player.WEAPON_MELEE);
            if (player.gunGroup) player.gunGroup.visible = (player.currentWeapon !== player.WEAPON_MELEE);
        }
        
        player.updateHUD();
    }

    static updateLockOn(player, lockPressed) {
        if (lockPressed) {
            if (window.flux.audio) window.flux.audio.play('lock');
            if (player.targetEnemy) {
                player.targetEnemy = null;
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("LOCK-OFF");
            } else {
                let nearestEnemy = null;
                let minDist = player.lockOnRange; 
                
                const enemies = (player.isSpaceMode && window.flux.spaceEnemies) ? window.flux.spaceEnemies : window.flux.enemies;
                
                if (enemies) {
                    enemies.forEach(e => {
                        let target = e;
                        if (player.isSpaceMode) {
                            while(target && !target.userData.type && target.parent) target = target.parent;
                        }
                        
                        if (target && target.userData && !target.userData.isDead && target.visible) {
                            const dist = target.position.distanceTo(player.mesh.position);
                            if (dist < minDist) {
                                if (!player.isSpaceMode) {
                                    player.raycaster.set(player.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0)), new THREE.Vector3().subVectors(target.position, player.mesh.position).normalize());
                                    const intersects = player.raycaster.intersectObjects(player.staticGroup.children, true);
                                    if (intersects.length === 0 || intersects[0].distance > dist) {
                                        minDist = dist;
                                        nearestEnemy = target;
                                    }
                                } else {
                                    minDist = dist;
                                    nearestEnemy = target;
                                }
                            }
                        }
                    });
                }
                
                if (nearestEnemy) {
                    player.targetEnemy = nearestEnemy;
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("TARGET LOCKED");
                } else {
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("NO TARGET");
                }
            }
            return;
        }

        if (player.targetEnemy && player.targetEnemy.userData.isDead) {
            if (!player.isFirstPerson) {
                player.targetEnemy = null;
            } else {
                player.targetEnemy = null;
            }
        }
    }

    static cycleStyle(player) {
        player.currentStyle++;
        if (player.currentStyle > 2) player.currentStyle = 0;
        
        if (typeof PlayerMesh !== 'undefined') {
            PlayerMesh.updateWeaponVisuals(player);
        }
        
        const names = ["KATANA", "DAGGER", "GREATSWORD"];
        if (window.flux && window.flux.spawnTechText) {
            window.flux.spawnTechText("STYLE: " + names[player.currentStyle]);
        }
        player.updateHUD();
    }
}</script>
    
    <!-- NEW: IK System -->
    <script>/**
 * INVERSE KINEMATICS SYSTEM
 * Analytic 3D 2-Bone Solver for Herculean Mechanics.
 * Provides mathematically perfect joint rotations to reach a target in 3D space.
 * Optimized for real-time performance with minimal GC.
 * UPDATED: Added 'alpha' (stiffness) parameter to solve() for damped/weighted IK.
 * UPDATED: Added robust solveLookAt for head tracking.
 * UPDATED: Clamped max extension to 99% to prevent singularity jitter.
 */
class IKSystem {
    constructor() {
        this.tempPos = new THREE.Vector3();
        this.tempQuat = new THREE.Quaternion();
        this.tempEuler = new THREE.Euler();
        
        // Reusable vectors to reduce GC
        this.rootPos = new THREE.Vector3();
        this.toTarget = new THREE.Vector3();
        this.rootToPole = new THREE.Vector3();
        this.planeNormal = new THREE.Vector3();
        this.targetDir = new THREE.Vector3();
        this.bone1Dir = new THREE.Vector3();
        this.bone1Basis = new THREE.Vector3(0, -1, 0); // Bone points down -Y by default
        this.parentQuat = new THREE.Quaternion();
        this.invParent = new THREE.Quaternion();
        this.q1 = new THREE.Quaternion();
        
        // Orientation helpers
        this.targetUp = new THREE.Vector3();
        this.currentUp = new THREE.Vector3();
        this.lookPos = new THREE.Vector3();
        this.lookDir = new THREE.Vector3();
        this.localDir = new THREE.Vector3();
    }

    /**
     * Solves 2-Bone IK
     * @param {THREE.Object3D} bone1 - The Upper Arm/Thigh (Shoulder/Hip)
     * @param {THREE.Object3D} bone2 - The Forearm/Shin (Elbow/Knee)
     * @param {THREE.Vector3} targetPos - World position to reach
     * @param {THREE.Vector3} polePos - World position for joint direction (Pole Vector)
     * @param {number} len1 - Length of bone 1
     * @param {number} len2 - Length of bone 2
     * @param {number} alpha - Stiffness/Blend factor (0.0 - 1.0). 1.0 = Instant, Lower = Stiffer/Damped.
     */
    solve(bone1, bone2, targetPos, polePos, len1, len2, alpha = 1.0) {
        if (!bone1 || !bone2) return;

        // 1. Get World Position of Root
        bone1.updateWorldMatrix(true, false);
        bone1.getWorldPosition(this.rootPos);

        // 2. Calculate Vector to Target
        this.toTarget.subVectors(targetPos, this.rootPos);
        const dist = this.toTarget.length();

        // 3. Clamp Distance (Prevent hyper-extension singularity)
        // CRITICAL FIX: Cap at 99.9% length to prevent unstable flipping at full extension
        const maxLen = (len1 + len2) * 0.999; 
        if (dist > maxLen) {
            this.toTarget.normalize().multiplyScalar(maxLen);
        } else if (dist < 0.001) {
            this.toTarget.set(0, -0.001, 0); 
        }
        
        // 4. Law of Cosines for Interior Angles
        const distSq = this.toTarget.lengthSq();
        const len1Sq = len1 * len1;
        const len2Sq = len2 * len2;

        // Alpha: Angle at Shoulder/Hip
        let cosAlpha = (len1Sq + distSq - len2Sq) / (2 * len1 * Math.sqrt(distSq));
        cosAlpha = Math.max(-1, Math.min(1, cosAlpha));
        const angleA = Math.acos(cosAlpha);

        // Beta: Angle at Elbow/Knee (Interior)
        let cosBeta = (len1Sq + len2Sq - distSq) / (2 * len1 * len2);
        cosBeta = Math.max(-1, Math.min(1, cosBeta));
        const angleB = Math.acos(cosBeta);

        // 5. Orientation Calculation
        
        // Plane Normal defined by Root, Target, and Pole
        this.rootToPole.subVectors(polePos, this.rootPos);
        this.planeNormal.crossVectors(this.toTarget, this.rootToPole).normalize();
        
        // Fallback if pole is collinear
        if (this.planeNormal.lengthSq() < 0.001) {
            this.planeNormal.crossVectors(this.toTarget, new THREE.Vector3(0, 0, 1)).normalize();
        }

        // 6. Apply Rotations
        
        // -- Bone 1 (Upper) --
        this.targetDir.copy(this.toTarget).normalize();
        
        // Rotate alpha radians away from targetDir around planeNormal
        // We rotate "up" towards the pole.
        this.bone1Dir.copy(this.targetDir).applyAxisAngle(this.planeNormal, angleA);
        
        // Calculate Quaternion to align Bone (-Y axis) with bone1Dir
        this.q1.setFromUnitVectors(this.bone1Basis, this.bone1Dir);
        
        // Convert World Space Quaternion to Local Space
        if (bone1.parent) {
            bone1.parent.updateWorldMatrix(true, false);
            bone1.parent.getWorldQuaternion(this.parentQuat);
            this.invParent.copy(this.parentQuat).invert();
            this.q1.premultiply(this.invParent);
        }
        
        // APPLY STIFFNESS (Damping)
        // If alpha is high, snap. If low, interpolate.
        if (alpha >= 0.99) {
            bone1.quaternion.copy(this.q1);
        } else {
            bone1.quaternion.slerp(this.q1, alpha);
        }
        
        // -- Bone 2 (Lower) --
        // In local space of Bone 1, Bone 2 is at -Y.
        // We rotate around the bend axis (X axis for standard rigging where Z is forward/side).
        // Angle is PI - beta (exterior angle).
        const kneeAngle = Math.PI - angleB;
        
        if (alpha >= 0.99) {
            bone2.rotation.set(kneeAngle, 0, 0);
        } else {
            // Lerp the single axis for stability
            const currentX = bone2.rotation.x;
            // Simple lerp for scalar angle
            bone2.rotation.set(
                currentX + (kneeAngle - currentX) * alpha,
                0,
                0
            );
        }
        
        // Update matrices immediately for children
        bone1.updateMatrix();
        bone2.updateMatrix();
    }

    /**
     * Aligns an object's up vector to a target normal.
     * Useful for feet conforming to terrain.
     */
    alignToNormal(object, normal, speed = 0.1) {
        if (!object || !normal) return;
        
        // Get current up in world space
        this.currentUp.set(0, 1, 0).applyQuaternion(object.quaternion);
        
        // Calculate rotation needed
        this.tempQuat.setFromUnitVectors(this.currentUp, normal);
        
        // Dampen the delta quaternion
        const identity = new THREE.Quaternion();
        this.tempQuat.slerp(identity, 1.0 - speed); // Reduce effect by speed
        
        object.quaternion.premultiply(this.tempQuat);
    }

    /**
     * Makes a bone look at a target position in world space.
     * Handles parent transforms and clamps angles.
     */
    solveLookAt(bone, targetPos, limitY = 1.5, limitX = 1.0, lerpSpeed = 1.0) {
        if (!bone) return;

        bone.updateWorldMatrix(true, false);
        bone.getWorldPosition(this.rootPos);
        
        this.lookDir.subVectors(targetPos, this.rootPos).normalize();
        
        // Convert target direction to local space
        if (bone.parent) {
            bone.parent.updateWorldMatrix(true, false);
            bone.parent.getWorldQuaternion(this.parentQuat);
            this.invParent.copy(this.parentQuat).invert();
            this.localDir.copy(this.lookDir).applyQuaternion(this.invParent);
        } else {
            this.localDir.copy(this.lookDir);
        }
        
        // Convert direction to Euler angles
        const yaw = Math.atan2(this.localDir.x, this.localDir.z);
        const pitch = Math.asin(-this.localDir.y); // Negate for standard pitch
        
        // Clamp
        const clampedYaw = Math.max(-limitY, Math.min(limitY, yaw));
        const clampedPitch = Math.max(-limitX, Math.min(limitX, pitch));
        
        // Smoothly Interpolate
        bone.rotation.y += (clampedYaw - bone.rotation.y) * lerpSpeed;
        bone.rotation.x += (clampedPitch - bone.rotation.x) * lerpSpeed;
        
        // Zero out roll
        bone.rotation.z *= 0.9;
    }
}</script>

    <!-- NEW: Player Modules (Refactored) -->
    <script>/**
 * PLAYER ANIMATION SYSTEM
 * Handles Procedural Animation, Inverse Kinematics (IK), and Kinematic Spring Dynamics.
 * UPDATED: Increased IK Stiffness for Weapon Handling (Gun/Sword).
 * UPDATED: Hand rotation overrides for solid aiming/holding.
 * UPDATED: "Glide" Leg IK - Legs straight down when idle, trailing when moving.
 * UPDATED: High-Precision Arm IK for Gun Aiming.
 * UPDATED: Sword now aligns with the slash curve tangent for accurate cutting visuals.
 * UPDATED: Refined Sword Grip and Slash Arc for more natural wrist movement.
 * UPDATED: Idle Sword Stance adjusted to CROSS BODY (Left Hip) per user request ("Opposite way").
 * FIXED: Removed independent sword rotation that caused "floating/broken wrist" visual.
 * FIXED: Sword now stays rigidly attached to the forearm/pincer mesh.
 * FIXED: Adjusted Idle Hand Position and Rotation to point sword ACROSS body.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes.
 * CRITICAL FIX: Added NaN Safety Checks for Vector Normalization.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _paVec1 = new THREE.Vector3();
const _paVec2 = new THREE.Vector3();
const _paVec3 = new THREE.Vector3();
const _paQuat = new THREE.Quaternion();
const _paCamDir = new THREE.Vector3();
const _paHipL = new THREE.Vector3();
const _paHipR = new THREE.Vector3();
const _paShoulderPos = new THREE.Vector3();
const _paShoulderLPos = new THREE.Vector3();
const _paForearmQuat = new THREE.Quaternion();
const _paInvForearm = new THREE.Quaternion();
const _paTargetQuat = new THREE.Quaternion();
const _paEdgeCorrection = new THREE.Quaternion();

class PlayerAnimation {

    static updateSpring(spring, dt) {
        const diff = spring.target - spring.pos;
        const accel = (diff * spring.k) - (spring.vel * spring.d);
        spring.vel += accel * dt;
        spring.pos += spring.vel * dt;
    }

    static update(player, dt, camera) {
        // Use static vector for velocity calculation
        _paVec1.copy(player.velocity).applyQuaternion(player.mesh.quaternion.clone().invert());
        const localVel = _paVec1;
        const speed = Math.sqrt(player.velocity.x**2 + player.velocity.z**2);
        
        // 1. Procedural Body Tilt
        player.kinematics.tiltX.target = (localVel.z * 0.01); 
        player.kinematics.tiltZ.target = -(localVel.x * 0.01); 
        player.kinematics.crouch.target = 0; 
        player.kinematics.recoil.target = 0;
        
        const currentRotY = player.mesh.rotation.y;
        let deltaRot = currentRotY - player.lastRotY;
        while (deltaRot > Math.PI) deltaRot -= Math.PI * 2;
        while (deltaRot < -Math.PI) deltaRot += Math.PI * 2;
        player.lastRotY = currentRotY;
        player.kinematics.spineLean.target = -deltaRot * 10.0; 
        
        for(let k in player.kinematics) {
            this.updateSpring(player.kinematics[k], dt);
        }
        
        // 2. Apply Body Transform
        if (player.visualGroup) {
            player.visualGroup.position.set(0, 0, 0);
            player.visualGroup.rotation.set(0, 0, 0);
            player.visualGroup.rotation.x = player.kinematics.tiltX.pos;
            player.visualGroup.rotation.z = player.kinematics.tiltZ.pos;
            
            // Hover Bob
            const bobFreq = player.onGround ? 0.005 : 0.002;
            const bobAmp = player.onGround ? 0.05 : 0.1;
            player.visualGroup.position.y += Math.sin(Date.now() * bobFreq) * bobAmp;
            
            const squash = Math.max(0, player.kinematics.crouch.pos * 0.01);
            const stretch = 1.0 - squash;
            const bulge = 1.0 + (squash * 0.5);
            player.visualGroup.scale.set(bulge, stretch, bulge);
            player.visualGroup.position.y -= squash; 
        }
        
        // 3. Torso Twist
        if(player.spine) {
            let slashTwist = 0;
            if (player.isAttacking) {
                const progress = 1.0 - (player.attackTimer / player.attackTotalDuration);
                slashTwist = Math.sin(progress * Math.PI) * (player.comboIndex % 2 === 0 ? 1.0 : -1.0);
            }
            
            const recoilTwist = player.kinematics.recoil.pos * 0.2;
            
            player.spine.rotation.y = player.kinematics.spineLean.pos * 0.5 + player.kinematics.chestTwist.pos + slashTwist + recoilTwist;
            player.spine.rotation.z = player.kinematics.tiltZ.pos * 0.3; 
            
            if (player.currentWeapon !== player.WEAPON_MELEE && camera) {
                camera.getWorldDirection(_paCamDir);
                const pitch = Math.asin(_paCamDir.y);
                player.spine.rotation.x = -pitch * 0.3; 
            }
        }
        
        // 4. Head Look
        if(player.head) {
            player.head.rotation.x = -player.kinematics.tiltX.pos * 0.5;
            player.head.rotation.z = -player.kinematics.tiltZ.pos * 0.5;
            
            if (player.targetEnemy && !player.targetEnemy.userData.isDead) {
                if (player.ikSolver) player.ikSolver.solveLookAt(player.head, player.targetEnemy.position, 1.5, 0.8, dt * 10);
            } else if (camera) {
                camera.getWorldDirection(_paCamDir);
                // Reuse _paVec2 for lookTarget
                _paVec2.copy(camera.position).add(_paCamDir.multiplyScalar(20));
                if (player.ikSolver) player.ikSolver.solveLookAt(player.head, _paVec2, 1.0, 0.8, dt * 5);
            }
        }
        
        // 5. Wing Animation
        if (player.binderL && player.binderR) {
            const wingOpen = Math.min(1.0, speed / 15) + (player.isDashing ? 1.0 : 0);
            const targetRot = 0.2 + (wingOpen * 0.6);
            player.binderL.rotation.z = -targetRot;
            player.binderR.rotation.z = targetRot;
            if (player.binderL.userData.flap) player.binderL.userData.flap.rotation.z = -wingOpen * 0.8;
            if (player.binderR.userData.flap) player.binderR.userData.flap.rotation.z = wingOpen * 0.8;
            player.binderL.rotation.x = 0.2 + (localVel.z * 0.015);
            player.binderR.rotation.x = 0.2 + (localVel.z * 0.015);
        }
        
        player.animTime += dt * 2; 
        
        // 6. Leg IK
        this.updateLegIK(player, dt, localVel);
        
        // 7. Arm IK
        this.updateArmIK(player, dt, camera);
        
        // 8. Thruster Visuals
        if (typeof PlayerMesh !== 'undefined' && PlayerMesh.updateThrusters) {
            PlayerMesh.updateThrusters(player, dt);
        }
    }

    static updateLegIK(player, dt, localVel) {
        if (!player.legL || !player.legR || !player.ikSolver) return;

        // Use static vectors for hip positions
        player.legL.root.getWorldPosition(_paHipL);
        player.legR.root.getWorldPosition(_paHipR);
        
        const down = _paVec1.set(0, -1, 0);
        const fwd = _paVec2.set(0, 0, 1).applyQuaternion(player.mesh.quaternion);
        
        const maxLegLen = player.legLen1 + player.legLen2;
        const legExtension = maxLegLen * 0.98; 
        
        // Calculate targets using static vectors
        // targetL
        const targetL = _paVec3.copy(_paHipL).add(down.clone().multiplyScalar(legExtension));
        // Need another vector for targetR since we use targetL simultaneously?
        // Actually we can just process one leg then the other, but lerp targets are stored on player object.
        // Let's use local variables for calculation then update player properties.
        
        // targetR (reuse _paVec1 temporarily, careful with 'down')
        // Re-set down just in case
        down.set(0, -1, 0);
        const targetR = new THREE.Vector3().copy(_paHipR).add(down.clone().multiplyScalar(legExtension)); // Allocation here is minor compared to loop, but let's optimize if possible.
        // Actually, let's just use the player.ikTargetLegL/R as the destination for lerping, 
        // and calculate the "Ideal" target into a temp vector.
        
        const idealL = _paVec3.copy(_paHipL).add(down.clone().multiplyScalar(legExtension));
        
        const speed = localVel.length();
        if (speed > 0.1) {
            const dragAmt = Math.min(2.0, speed * 0.08);
            // Reuse _paVec1 for dragVec
            _paVec1.copy(player.velocity);
            
            // CRITICAL FIX: Safe Normalize
            if (_paVec1.lengthSq() > 0.00001) {
                _paVec1.normalize().multiplyScalar(-dragAmt);
                idealL.add(_paVec1);
                targetR.add(_paVec1);
            }
            
            if (speed > 15) {
                idealL.y += 0.1;
                targetR.y += 0.1;
            }
        }
        
        const adjustToFloor = (target) => {
            // Reuse _paVec2 for ray origin
            _paVec2.copy(target).add(new THREE.Vector3(0, 2, 0));
            player.footRaycaster.set(_paVec2, down);
            const intersects = player.footRaycaster.intersectObjects(player.staticGroup.children, true);
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (target.y < hit.point.y + 0.1) {
                    target.y = hit.point.y + 0.1;
                }
            }
        };
        
        if (player.onGround) {
            adjustToFloor(idealL);
            adjustToFloor(targetR);
        }

        // Pole targets
        const poleL = _paHipL.clone().add(fwd.clone().multiplyScalar(5.0));
        const poleR = _paHipR.clone().add(fwd.clone().multiplyScalar(5.0));

        player.ikTargetLegL.lerp(idealL, dt * 20.0);
        player.ikTargetLegR.lerp(targetR, dt * 20.0);
        player.ikPoleLegL.lerp(poleL, dt * 10.0);
        player.ikPoleLegR.lerp(poleR, dt * 10.0);

        // Legs use high stiffness (0.8) to look mechanical but responsive
        const legStiffness = 1.0 - Math.exp(-20.0 * dt);
        
        player.ikSolver.solve(player.legL.root, player.legL.knee, player.ikTargetLegL, player.ikPoleLegL, player.legLen1, player.legLen2, legStiffness);
        player.ikSolver.solve(player.legR.root, player.legR.knee, player.ikTargetLegR, player.ikPoleLegR, player.legLen1, player.legLen2, legStiffness);
        
        if (player.onGround && speed < 1.0) {
            player.ikSolver.alignToNormal(player.legL.foot, player.footLNorm);
            player.ikSolver.alignToNormal(player.legR.foot, player.footRNorm);
        } else {
            player.legL.foot.rotation.set(0,0,0);
            player.legR.foot.rotation.set(0,0,0);
            const toePoint = Math.PI / 2 + 0.5; 
            player.legL.foot.rotateX(toePoint);
            player.legR.foot.rotateX(toePoint);
        }
    }

    static updateArmIK(player, dt, camera) {
        if (!player.armR || !player.armL || !player.ikSolver) return;

        player.armR.getWorldPosition(_paShoulderPos);
        
        let targetPos = _paVec1; // Use static vector
        let polePos = _paVec2;   // Use static vector
        let desiredSwordTangent = null; 
        
        // STIFFNESS CONTROL - UPDATED FOR "OVERRIDE" FEEL
        // 0.0 = Loose, 1.0 = Rigid
        let armStiffness = 0.95; // Default high stiffness for solid feel
        
        // 1. AIMING LOGIC (Gun)
        if (player.currentWeapon !== player.WEAPON_MELEE && camera) {
            if (player.isFirstPerson) {
                armStiffness = 1.0; // Absolute Stiffness for aiming (No lag)
                
                camera.getWorldDirection(_paCamDir);
                
                // Aim at point far in front of camera
                const aimDist = 50.0;
                // Reuse _paVec3 for aimPoint
                const aimPoint = _paVec3.copy(camera.position).add(_paCamDir.clone().multiplyScalar(aimDist));
                
                // Calculate direction from shoulder to aim point
                const shoulderToAim = new THREE.Vector3().subVectors(aimPoint, _paShoulderPos).normalize();
                
                // UPDATED: Use 98% extension for stiffer, straighter arm when shooting
                const extension = (player.armLen1 + player.armLen2) * 0.98;
                targetPos.copy(_paShoulderPos).add(shoulderToAim.multiplyScalar(extension));
                
                targetPos.add(_paCamDir.multiplyScalar(-player.kinematics.recoil.pos * 0.2));
                
                const right = new THREE.Vector3(1,0,0).applyQuaternion(player.mesh.quaternion);
                const down = new THREE.Vector3(0,-1,0).applyQuaternion(player.mesh.quaternion);
                polePos.copy(_paShoulderPos).add(down).add(right.multiplyScalar(0.5));
                
                if (player.swordGroup) {
                    player.swordGroup.quaternion.slerp(new THREE.Quaternion(), dt * 10.0);
                }
                
                // Fast tracking for aiming
                player.ikTargetHandR.lerp(targetPos, dt * 40.0); 
                player.ikPoleHandR.lerp(polePos, dt * 30.0);

                // CRITICAL FIX: Stabilize Hand Up Vector
                // Use player's up vector to prevent wrist twisting when looking up/down
                const playerUp = new THREE.Vector3(0, 1, 0).applyQuaternion(player.mesh.quaternion);
                player.handR.up.copy(playerUp); 
                
                // LookAt logic for aiming - OVERRIDE IK ROTATION
                player.handR.lookAt(aimPoint);
            } else {
                // TPS: Just hold gun forward relative to body, but further out
                armStiffness = 1.0;
                const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(player.mesh.quaternion);
                
                // Push gun out further (1.2x arm length)
                const extension = (player.armLen1 + player.armLen2) * 1.2; 
                targetPos.copy(_paShoulderPos).add(forward.multiplyScalar(extension));
                // Adjust height slightly up
                targetPos.y = _paShoulderPos.y + 0.2; 
                
                // Pole vector
                const right = new THREE.Vector3(1,0,0).applyQuaternion(player.mesh.quaternion);
                const down = new THREE.Vector3(0,-1,0).applyQuaternion(player.mesh.quaternion);
                polePos.copy(_paShoulderPos).add(down).add(right.multiplyScalar(0.5));

                // Fast tracking
                player.ikTargetHandR.lerp(targetPos, dt * 40.0); 
                player.ikPoleHandR.lerp(polePos, dt * 30.0);

                // Override Hand Rotation
                const playerUp = new THREE.Vector3(0, 1, 0).applyQuaternion(player.mesh.quaternion);
                player.handR.up.copy(playerUp);
                player.handR.lookAt(targetPos.clone().add(forward.multiplyScalar(10))); // Look forward
            }
        } 
        // 2. MELEE LOGIC (MESH-GUIDED IK)
        else if (player.isAttacking && player.activeSlashMesh) {
            armStiffness = 1.0; // Max stiffness for snappy attacks
            
            const progress = 1.0 - (player.attackTimer / player.attackTotalDuration);
            
            const radius = player.activeSlashMesh.userData.radius || 2.25;
            const sweepDir = player.activeSlashMesh.userData.sweepDirection || 1; 
            
            let angle = (sweepDir === 1) ? (progress * Math.PI) : (Math.PI * (1.0 - progress));
            
            const localPos = new THREE.Vector3(
                radius * Math.cos(angle),
                radius * Math.sin(angle),
                0
            );
            
            const localTangent = new THREE.Vector3(
                -Math.sin(angle) * sweepDir,
                Math.cos(angle) * sweepDir,
                0
            ).normalize();

            // Transform to World Space
            player.activeSlashMesh.updateMatrixWorld(); 
            targetPos.copy(localPos).applyMatrix4(player.activeSlashMesh.matrixWorld);
            
            // --- STABILITY FIX: CLAMP REACH ---
            const armLength = player.armLen1 + player.armLen2;
            const distToTarget = targetPos.distanceTo(_paShoulderPos);
            if (distToTarget > armLength * 0.98) {
                const dir = new THREE.Vector3().subVectors(targetPos, _paShoulderPos).normalize();
                targetPos.copy(_paShoulderPos).add(dir.multiplyScalar(armLength * 0.98));
            }
            
            const rotMat = new THREE.Matrix4().extractRotation(player.activeSlashMesh.matrixWorld);
            desiredSwordTangent = localTangent.applyMatrix4(rotMat).normalize();
            
            // Pole Vector perpendicular to tangent (Up vector of the slash plane)
            const meshUp = new THREE.Vector3(0, 0, 1).applyQuaternion(player.activeSlashMesh.quaternion);
            
            // STABILITY: Bias pole vector outwards from body to prevent flipping
            const bodyRight = new THREE.Vector3(1, 0, 0).applyQuaternion(player.mesh.quaternion);
            const stablePole = meshUp.clone().add(bodyRight).normalize();
            
            polePos.copy(_paShoulderPos).add(stablePole.multiplyScalar(5.0));
            
            // --- STABILITY FIX: SMOOTHING ---
            // Increased smoothing (lower factor) to reduce jitter
            player.ikTargetHandR.lerp(targetPos, 0.4); 
            player.ikPoleHandR.lerp(polePos, 0.2); 
        } 
        // 3. IDLE / BLOCK
        else {
            armStiffness = 0.95; // Very stiff holding pose
            
            // Dynamic Idle Pose (Running vs Standing)
            const speed = player.velocity.length();
            const runFactor = Math.min(1.0, speed / 20.0);
            
            // Base Idle: Hand "Cross Body" / Iaido Stance
            // Right hand moves to Left Hip (X = -0.4)
            // X=-0.4 (Left/Across), Y=-0.5 (Waist), Z=0.35 (Forward)
            const idleOffset = new THREE.Vector3(-0.4, -0.5, 0.35);
            
            // Run Pose: Hand moves back and out
            const runOffset = new THREE.Vector3(0.5, -0.6, -0.3);
            
            const currentOffset = new THREE.Vector3().lerpVectors(idleOffset, runOffset, runFactor);
            targetPos.copy(_paShoulderPos).add(currentOffset.applyQuaternion(player.mesh.quaternion));
            
            // Pole Vector: Point elbow OUT to the right and slightly back
            polePos.copy(_paShoulderPos).add(new THREE.Vector3(1.0, 0, -0.2).applyQuaternion(player.mesh.quaternion));
            
            if (player.isBlocking) {
                armStiffness = 1.0; // Rigid block
                targetPos.copy(_paShoulderPos).add(new THREE.Vector3(-0.2, 0.2, 0.5).applyQuaternion(player.mesh.quaternion));
                polePos.copy(_paShoulderPos).add(new THREE.Vector3(-1.0, -0.5, 0).applyQuaternion(player.mesh.quaternion));
            }
            
            // FIX: Rotate sword to point Right (Across body)
            if (player.swordGroup) {
                // Blade is +Z. 
                // We want it pointing Right (+X) to cross the body from the left hand position
                // Euler Y = -1.7 (Points Right), Z = 0.0 (Flat)
                _paTargetQuat.setFromEuler(new THREE.Euler(0.0, -1.7, 0.0));
                player.swordGroup.quaternion.slerp(_paTargetQuat, dt * 10.0);
            }
            
            player.ikTargetHandR.lerp(targetPos, dt * 20.0);
            player.ikPoleHandR.lerp(polePos, dt * 15.0);
        }
        
        // Convert stiffness to frame-rate independent alpha
        // If stiffness is 1.0, alpha is 1.0 (instant).
        let alpha = 1.0;
        if (armStiffness < 0.99) {
            // Map 0.1 -> Slow, 0.9 -> Fast
            // Increased multiplier to 60.0 for very snappy response
            const speed = armStiffness * 60.0; 
            alpha = 1.0 - Math.exp(-speed * dt);
        }
        
        const forearm = player.armR.children[2]; 
        if (forearm) {
            player.ikSolver.solve(player.armR, forearm, player.ikTargetHandR, player.ikPoleHandR, player.armLen1, player.armLen2, alpha);
            
            player.armR.updateMatrixWorld(true); 
            
            // --- HAND ROTATION OVERRIDES ---
            
            if (player.currentWeapon !== player.WEAPON_MELEE && camera && !player.isFirstPerson) {
                 // TPS Hand already handled in the IK block above
            }
            else if (player.isAttacking && desiredSwordTangent && player.swordGroup) {
                forearm.getWorldQuaternion(_paForearmQuat);
                
                _paInvForearm.copy(_paForearmQuat).invert();
                const localTangentForArm = desiredSwordTangent.clone().applyQuaternion(_paInvForearm);
                
                _paTargetQuat.setFromUnitVectors(new THREE.Vector3(0,0,1), localTangentForArm);
                _paEdgeCorrection.setFromAxisAngle(new THREE.Vector3(0,0,1), Math.PI/2);
                _paTargetQuat.multiply(_paEdgeCorrection);
                
                // Smoother rotation blend
                player.swordGroup.quaternion.slerp(_paTargetQuat, 0.8); // Faster blend for attacks
                
                player.handR.rotation.set(0,0,0);
            }
            else if (player.isAttacking) {
                player.handR.rotation.set(0, 0, 0); 
                player.handR.rotation.x = -player.kinematics.weaponSwayX.pos;
            }
            else {
                // IDLE/RUNNING: Lock Hand Rotation to Forearm with specific offset for "Cross Body" Stance
                // Twist wrist for cross-body grip
                player.handR.rotation.set(0, -0.5, 1.0);
                
                // Optional: Add slight sway based on movement
                if (player.velocity.length() > 1.0) {
                    player.handR.rotation.z += Math.sin(Date.now() * 0.01) * 0.1;
                }
            }
        }
        
        // --- LEFT ARM (Balance) ---
        player.armL.getWorldPosition(_paShoulderLPos);
        
        let targetL = _paShoulderLPos.clone().add(new THREE.Vector3(0.3, -0.8, 0.2).applyQuaternion(player.mesh.quaternion));
        let poleL = _paShoulderLPos.clone().add(new THREE.Vector3(1.0, 0, 0).applyQuaternion(player.mesh.quaternion));
        
        if (player.currentWeapon !== player.WEAPON_MELEE) {
             targetL = _paShoulderLPos.clone().add(new THREE.Vector3(0.4, -0.5, 0.5).applyQuaternion(player.mesh.quaternion));
        }
        
        player.ikTargetHandL.lerp(targetL, dt * 10.0);
        player.ikPoleHandL.lerp(poleL, dt * 10.0);
        
        const forearmL = player.armL.children[2];
        if (forearmL) {
            // Left arm is usually loose/balancing
            const leftAlpha = 1.0 - Math.exp(-5.0 * dt);
            player.ikSolver.solve(player.armL, forearmL, player.ikTargetHandL, player.ikPoleHandL, player.armLen1, player.armLen2, leftAlpha);
        }
    }
}</script>
    <script>/**
 * PLAYER SPACE PHYSICS
 * Handles zero-g movement, 6DOF flight, and space-specific inputs.
 * Extracted from Player.js.
 * UPDATED: Sets isThrusterActive based on input for visual feedback.
 * UPDATED: Uses ACT constants from input.js.
 */
class PlayerSpace {
    
    static updateSpring(spring, dt) {
        const diff = spring.target - spring.pos;
        const accel = (diff * spring.k) - (spring.vel * spring.d);
        spring.vel += accel * dt;
        spring.pos += spring.vel * dt;
    }

    static update(player, dt, input) {
        if (!input) return;
        
        const lockPressed = input.actions[ACT.LOCK] && !player.wasLockDown;
        const camSwitchPressed = input.actions[ACT.CAM_SWITCH] && !player.wasCamSwitchDown;
        const missileHeld = input.actions[ACT.MISSILE];
        
        if (camSwitchPressed) { 
            player.isFirstPerson = !player.isFirstPerson;
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText(player.isFirstPerson ? "VIEW: FPS" : "VIEW: TPS");
            if (window.flux.audio) window.flux.audio.play('switch');
        }
        
        if (lockPressed) {
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.updateLockOn(player, true);
        }
        
        if (missileHeld) {
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.chargeMissiles(player, dt);
        } else if (player.wasMissileDown) {
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.fireMissiles(player);
        }
        
        player.wasLockDown = input.actions[ACT.LOCK];
        player.wasCamSwitchDown = input.actions[ACT.CAM_SWITCH];
        player.wasMissileDown = input.actions[ACT.MISSILE];
        
        const lookX = input.lookVector ? input.lookVector.x : 0;
        const lookY = input.lookVector ? input.lookVector.y : 0;
        
        player.mesh.rotateX(lookY * player.rotSpeed * dt);
        player.mesh.rotateY(-lookX * player.rotSpeed * dt);
        
        if (player.spaceLocks && player.spaceLocks.length > 0 && player.spaceLocks[0] && !player.spaceLocks[0].userData.isDead) {
            const target = player.spaceLocks[0];
            const targetPos = target.position.clone();
            const toTarget = new THREE.Vector3().subVectors(targetPos, player.mesh.position).normalize();
            
            const currentQuat = player.mesh.quaternion.clone();
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), toTarget);
            
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(currentQuat);
            if (forward.dot(toTarget) > 0.5) {
                player.mesh.quaternion.slerp(targetQuat, 2.0 * dt);
            }
        }
        
        const moveVec = input.moveVector || { x: 0, y: 0 };
        const surge = moveVec.y; 
        const sway = moveVec.x;  
        const heave = (input.actions[ACT.JUMP] ? 1 : 0) - (input.actions[ACT.TECH] ? 1 : 0); 
        
        let currentThrust = player.thrustSpeed;
        player.isBoosting = false;
        
        if (input.actions[ACT.DASH] && !player.wasDashDown && Math.abs(sway) > 0.5 && player.barrelRollTimer <= 0 && player.ap > 10) {
            player.barrelRollTimer = 0.3; 
            player.ap -= 10;
            
            const rollDir = new THREE.Vector3(Math.sign(sway), 0, 0).applyQuaternion(player.mesh.quaternion);
            player.velocity.add(rollDir.multiplyScalar(100)); 
            
            if (window.flux.spawnTechText) window.flux.spawnTechText("BARREL ROLL");
            if (window.flux.audio) window.flux.audio.play('teleport');
            
            player.mesh.rotateZ(-Math.sign(sway) * Math.PI * 2); 
        }
        else if (input.actions[ACT.DASH] && player.ap > 0) {
            player.isBoosting = true;
            currentThrust *= player.boostMultiplier; 
            player.ap -= 10 * dt; 
            if (player.ap < 0) player.ap = 0;
            
            if (window.flux.shake) window.flux.shake(0.1); 
        } else {
            if (player.ap < 50) player.ap += 5 * dt;
        }
        
        player.wasDashDown = input.actions[ACT.DASH];
        
        const thrust = new THREE.Vector3(sway, heave, -surge); 
        
        // VISUALS: Determine if thrusters should be active
        player.isThrusterActive = (thrust.lengthSq() > 0.01) || player.isBoosting;

        thrust.applyQuaternion(player.mesh.quaternion);
        thrust.multiplyScalar(currentThrust * dt);
        
        player.velocity.add(thrust);
        
        if (input.actions[ACT.BLOCK]) {
            const brakeFactor = 1.0 - (5.0 * dt);
            player.velocity.multiplyScalar(Math.max(0, brakeFactor));
        } else {
            if (player.flightMode === 'COUPLED') {
                const dragVal = player.isBoosting ? 0.5 : player.spaceDrag;
                const dragFactor = 1.0 - (dragVal * dt);
                player.velocity.multiplyScalar(dragFactor);
            }
        }
        
        player.mesh.position.add(player.velocity.clone().multiplyScalar(dt));
        
        player.kinematics.tiltX.target = surge * 0.5;
        player.kinematics.tiltZ.target = -sway * 0.5;
        
        for(let k in player.kinematics) {
            this.updateSpring(player.kinematics[k], dt);
        }
        
        if (player.visualGroup) {
            player.visualGroup.rotation.x = player.kinematics.tiltX.pos;
            player.visualGroup.rotation.z = player.kinematics.tiltZ.pos;
        }
        
        if (input.actions[ACT.TECH] && !player.wasTechDown) {
            player.flightMode = (player.flightMode === 'COUPLED') ? 'DECOUPLED' : 'COUPLED';
            if (window.flux.spawnTechText) window.flux.spawnTechText(`FLIGHT MODE: ${player.flightMode}`);
        }
        player.wasTechDown = input.actions[ACT.TECH];
        
        if (input.actions[ACT.ATTACK]) {
            player.spaceWeapon = 'VULCAN';
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.fireSpaceWeapon(player, dt);
        }
        
        player.wasSwitchDown = input.actions[ACT.SWITCH];
        
        player.updateHUD();
    }
}</script>

    <script>/**
 * PLAYER CONTROLLER - MODULAR CORE
 * Handles State, Input Delegation, and Stats.
 * Physics delegated to PlayerPhysics.
 * Combat delegated to PlayerCombat.
 * Animation delegated to PlayerAnimation.
 * Space Flight delegated to PlayerSpace.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes.
 * OPTIMIZED: Separated Logic/Physics from Animation for Render Loop synchronization.
 * CRITICAL FIX: Added NaN Safety Checks for Input Vectors.
 * UPDATED: Added Raycast Caching variables for Performance Optimization.
 * PERF FIX: Audio Loop Throttling, Ghost Spawn Throttling, Crosshair Optimization.
 * CRITICAL FIX: Fixed Lock-On Movement (Strafing was broken).
 * CRITICAL FIX: Rewrote Lock-On Movement to be Camera-Relative.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _pVec1 = new THREE.Vector3();
const _pVec2 = new THREE.Vector3();
const _pVec3 = new THREE.Vector3();
const _pQuat = new THREE.Quaternion();
const _pAxisY = new THREE.Vector3(0, 1, 0);
const _pForward = new THREE.Vector3();
const _pRight = new THREE.Vector3();

class Player {
    constructor(scene, staticGroup, enemyGroup) {
        this.scene = scene;
        this.staticGroup = staticGroup; 
        this.enemyGroup = enemyGroup;   
        
        // --- STATS ---
        this.maxHp = 100;
        this.hp = 100;
        this.ap = 50; // Energy
        this.isDead = false;
        this.isFlashing = false; 
        this.isFirstPerson = false; 
        this.camPitch = 0; 
        this.camRotationY = 0; 
        this.moveReferenceAngle = null; 
        
        // --- IK SYSTEM ---
        this.ikSolver = new IKSystem();
        
        // Targets (World Space)
        this.ikTargetHandR = new THREE.Vector3(); 
        this.ikPoleHandR = new THREE.Vector3();   
        this.ikTargetHandL = new THREE.Vector3();
        this.ikPoleHandL = new THREE.Vector3();
        
        this.ikTargetLegL = new THREE.Vector3();
        this.ikPoleLegL = new THREE.Vector3();
        this.ikTargetLegR = new THREE.Vector3();
        this.ikPoleLegR = new THREE.Vector3();
        
        // Terrain Adaptation
        this.footRaycaster = new THREE.Raycaster();
        this.footRaycaster.far = 2.0;
        this.footLPos = new THREE.Vector3();
        this.footRPos = new THREE.Vector3();
        this.footLNorm = new THREE.Vector3(0, 1, 0);
        this.footRNorm = new THREE.Vector3(0, 1, 0);
        
        // Bone Lengths
        this.armLen1 = 0.4;
        this.armLen2 = 0.5;
        this.legLen1 = 0.45; 
        this.legLen2 = 0.6;  
        
        // --- SPACE FLIGHT STATS ---
        this.isSpaceMode = false;
        this.flightMode = 'COUPLED'; 
        this.spaceVelocity = new THREE.Vector3();
        this.spaceRotVelocity = new THREE.Vector3();
        this.thrustSpeed = 60.0; 
        this.boostMultiplier = 5.0; 
        this.rotSpeed = 1.8; 
        this.spaceDrag = 1.5; 
        this.isBoosting = false; 
        this.spaceWeapon = 'VULCAN'; 
        this.spaceFireTimer = 0;
        this.spaceLocks = []; 
        this.isSpaceLocking = false;
        this.missileChargeTimer = 0; 
        this.barrelRollTimer = 0; 
        
        // --- SHIELD SYSTEM ---
        this.shieldMaxHp = 100;
        this.shieldHp = 100;
        this.shieldCooldown = 0;
        this.shieldRegenDelay = 5.0;
        this.isShieldBroken = false;
        this.isShieldDisabled = false; 
        
        // --- MAGIC SHELL ANIMATION ---
        this.shellReveal = 1.0; 
        this.shellRevealSpeed = 0.5;
        
        // --- OVERDRIVE SYSTEM ---
        this.isOverdrive = false;
        this.overdriveTimer = 0;
        this.overdriveThreshold = 15;

        // --- LEVELING SYSTEM ---
        this.level = 1;
        this.xp = 0;
        this.xpReq = 100;
        this.statMultiplier = 1.0;

        // --- PHYSICS CONFIG ---
        this.gravity = -80; 
        this.gravityScale = 1.0; 
        
        this.acceleration = 35;  
        this.drag = 1.5;         
        this.brakingDrag = 3.0;  
        this.airDrag = 0.5;      
        
        this.moveSpeed = 24; 
        this.dashSpeed = 85; 
        this.jumpForce = 38; 
        this.wallJumpForce = 45;
        
        // Dimensions
        this.height = 2.0;
        this.radius = 0.5;
        
        // --- ARENA BOUNDARY ---
        this.arenaRadius = null; 
        
        // --- HOVER PID CONTROLLER ---
        this.hoverTargetHeight = 0; 
        this.hoverIntegral = 0;
        this.hoverErrorPrior = 0;
        this.hoverKP = 8.0;  
        this.hoverKI = 0.0;  
        this.hoverKD = 2.0;  
        
        // --- STATE MACHINE ---
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.onGround = false;
        this.isDashing = false;
        this.isAttacking = false;
        this.isBlocking = false;
        this.isWallRunning = false;
        this.isCharging = false;
        this.isKnockedDown = false; 
        this.isThrusterActive = false;
        this.landingLag = 0;
        
        // --- WEAPON STATE ---
        this.WEAPON_MELEE = 0;
        this.WEAPON_RANGED = 1; 
        this.WEAPON_BEAM = 2;   
        this.currentWeapon = this.WEAPON_MELEE;
        this.ammo = 12; 
        this.maxAmmo = 12;
        this.fireRate = 0.5; 
        this.fireTimer = 0;
        this.isReloading = false;
        this.reloadTimer = 0;
        this.reloadDuration = 1.5;
        
        this.STYLE_KATANA = 0;
        this.STYLE_DAGGER = 1;
        this.STYLE_GREATSWORD = 2;
        this.currentStyle = this.STYLE_KATANA;
        
        // --- INPUT TRACKING & BUFFER ---
        this.inputBuffer = { action: null, time: 0 };
        this.BUFFER_WINDOW = 0.2; 
        
        this.wasJumpDown = false; 
        this.wasDashDown = false;
        this.wasAttackDown = false;
        this.wasBlockDown = false;
        this.wasSwitchDown = false;
        this.wasReloadDown = false;
        this.wasStyleDown = false;
        this.wasLockDown = false;
        this.wasCamSwitchDown = false;
        this.wasMissileDown = false; 
        this.attackHoldTimer = 0;
        this.CHARGE_THRESHOLD = 0.35; 
        
        // --- TIMERS ---
        this.dashTime = 0;
        this.dashDuration = 0.08; 
        this.dashCooldown = 0;
        this.dashTrailTimer = 0;
        this.perfectDodgeWindow = 0; 
        
        this.jumpBufferTimer = 0;
        this.jumpBufferMax = 0.15; 
        this.coyoteTimer = 0;
        this.coyoteMax = 0.1; 
        this.wallRunSoundTimer = 0; 
        this.wasWallJump = false; 
        this.parryWindow = 0;
        
        // Wall Slash Logic
        this.canWallJump = false; 
        this.wallMagnetismTimer = 0; 
        this.lastWallNormal = new THREE.Vector3(); 
        
        // --- COMBO SYSTEM ---
        this.comboIndex = 0;
        this.comboTimer = 0;
        this.comboMaxTime = 0.8; 
        this.activeComboStep = 0;
        
        // --- ATTACK STATE ---
        this.attackTimer = 0;
        this.attackTotalDuration = 0;
        this.currentSwingId = 0;
        this.hitEnemies = new Set(); 
        this.attackType = 'GROUND'; 
        
        // --- KINEMATICS ---
        this.kinematics = {
            tiltX: { pos: 0, vel: 0, target: 0, k: 180, d: 15 }, 
            tiltZ: { pos: 0, vel: 0, target: 0, k: 180, d: 15 },
            crouch: { pos: 0, vel: 0, target: 0, k: 250, d: 20 }, 
            spineLean: { pos: 0, vel: 0, target: 0, k: 120, d: 12 },
            weaponSwayX: { pos: 0, vel: 0, target: 0, k: 100, d: 15 },
            weaponSwayY: { pos: 0, vel: 0, target: 0, k: 100, d: 15 },
            chestTwist: { pos: 0, vel: 0, target: 0, k: 150, d: 15 },
            recoil: { pos: 0, vel: 0, target: 0, k: 200, d: 20 }
        };

        this.animTime = 0;
        this.lastRotY = 0; 
        this.lastStepPhase = 0; 

        this.thighLen = 0.45;
        this.shinLen = 0.45;
        this.hipWidth = 0.15;
        
        // --- RAYCASTING ---
        this.raycaster = new THREE.Raycaster();
        this.downVector = new THREE.Vector3(0, -1, 0);
        this.upVector = new THREE.Vector3(0, 1, 0); 
        this.rayOrigin = new THREE.Vector3();
        this.tempVec = new THREE.Vector3();
        this.tempDir = new THREE.Vector3();
        this.tempOrigin = new THREE.Vector3();
        this.hitDirection = new THREE.Vector3();
        
        // --- PERFORMANCE: RAYCAST CACHING ---
        this.raycastFrameSkip = 0;
        this.cachedGroundHit = null;
        this.cachedWallHit = { collision: false, normal: new THREE.Vector3() };
        
        this.pelletOrigin = new THREE.Vector3();
        this.pelletDir = new THREE.Vector3();
        
        this.prevTipPos = new THREE.Vector3();
        
        // --- TARGETING ---
        this.targetEnemy = null;
        this.lockOnRange = 40;
        this.lockTimer = 0;
        
        this.currentTipPos = new THREE.Vector3();
        
        this.groundOffsets = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(this.radius * 0.8, 0, 0),
            new THREE.Vector3(-this.radius * 0.8, 0, 0),
            new THREE.Vector3(0, 0, this.radius * 0.8),
            new THREE.Vector3(0, 0, -this.radius * 0.8)
        ];
        
        this.touchingWall = false;
        this.wallNormal = new THREE.Vector3();

        this.activeSlashMesh = null;
        this.slashVelocity = new THREE.Vector3();
        
        // PERF: Audio state tracking
        this.isRunningAudio = false;

        if (typeof PlayerMesh !== 'undefined') {
            PlayerMesh.build(this);
        }
        
        if (typeof updateHUD === 'function') {
            updateHUD();
        }
    }

    addXp(amount) {
        if (this.isDead) return;
        this.xp += amount;
        
        if (window.flux && window.flux.updateXpBar) window.flux.updateXpBar(this.xp, this.xpReq, this.level);
        
        if (this.xp >= this.xpReq) {
            this.xp -= this.xpReq;
            this.level++;
            this.xpReq = Math.floor(this.xpReq * 1.5);
            this.statMultiplier += 0.1;
            
            this.hp = this.maxHp;
            this.ap = 50;
            this.isOverdrive = true;
            this.overdriveTimer = 10.0; 
            
            if (window.flux.spawnTechText) window.flux.spawnTechText(`LEVEL ${this.level} - OVERCLOCK ACTIVATED`);
            if (window.flux.audio) window.flux.audio.play('charge');
            if (window.flux.shake) window.flux.shake(0.5);
            if (this.updateHUD) this.updateHUD();
            
            this.addXp(0);
        }
    }

    updateSpring(spring, dt) {
        const diff = spring.target - spring.pos;
        const accel = (diff * spring.k) - (spring.vel * spring.d);
        spring.vel += accel * dt;
        spring.pos += spring.vel * dt;
    }

    checkOverdrive() {
        if (this.overdriveTimer > 0) {
            this.overdriveTimer -= 0.016; 
            if (this.overdriveTimer <= 0 && this.isOverdrive) {
                if (!window.flux || window.flux.comboCount < this.overdriveThreshold) {
                    this.isOverdrive = false;
                    if (window.flux.spawnTechText) window.flux.spawnTechText("OVERDRIVE OFFLINE");
                    if (this.matBlade) this.matBlade.emissive.setHex(0x00ffff);
                    if (this.matMetatron) this.matMetatron.emissive.setHex(0xff3300);
                }
            }
            return;
        }

        if (!window.flux) return;
        const combo = window.flux.comboCount || 0;
        
        if (combo >= this.overdriveThreshold && !this.isOverdrive) {
            this.isOverdrive = true;
            if (window.flux.spawnTechText) window.flux.spawnTechText("OVERDRIVE ENGAGED");
            if (window.flux.audio) window.flux.audio.play('charge');
            if (window.flux.shake) window.flux.shake(0.5);
            if (this.matBlade) this.matBlade.emissive.setHex(0xff0055);
            if (this.matMetatron) this.matMetatron.emissive.setHex(0xff0055);
            this.shellReveal = 0.5; 
        } else if (combo < this.overdriveThreshold && this.isOverdrive && this.overdriveTimer <= 0) {
            this.isOverdrive = false;
            if (window.flux.spawnTechText) window.flux.spawnTechText("OVERDRIVE OFFLINE");
            if (this.matBlade) this.matBlade.emissive.setHex(0x00ffff);
            if (this.matMetatron) this.matMetatron.emissive.setHex(0xff3300);
        }
    }

    takeDamage(amount) {
        if (this.isDead) return;
        if (this.perfectDodgeWindow > 0) {
            if (window.flux && window.flux.spawnPhaseShift) window.flux.spawnPhaseShift(this.mesh.position);
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("PHASE SHIFT");
            if (window.flux.audio) window.flux.audio.play('teleport');
            this.ap = Math.min(50, this.ap + 20);
            this.perfectDodgeWindow = 0;
            return;
        }
        
        if (this.isOverdrive) amount *= 0.5;
        
        if (this.isBlocking && !this.isShieldBroken && !this.isShieldDisabled) {
            if (this.parryWindow > 0) {
                if (window.flux && window.flux.showParry) window.flux.showParry(this.mesh.position.clone().add(_pVec1.set(0,2,0)));
                if (window.flux && window.flux.spawnBlockParticles) window.flux.spawnBlockParticles(this.mesh.position);
                if (window.flux && window.flux.slowMotion) window.flux.slowMotion(0.5, 0.1); 
                if (window.flux.audio) window.flux.audio.play('block'); 
                
                this.ap = Math.min(50, this.ap + 20);
                if (window.flux.spawnTechText) window.flux.spawnTechText("PERFECT PARRY");
                
                this.updateHUD();
                return; 
            }
            
            const energyCost = amount * 0.5; 
            
            if (this.ap >= energyCost) {
                this.ap -= energyCost;
                if (window.flux && window.flux.spawnBlockParticles) window.flux.spawnBlockParticles(this.mesh.position);
                if (window.flux.audio) window.flux.audio.play('block');
            } else {
                this.ap = 0;
                this.isShieldBroken = true;
                this.shieldCooldown = this.shieldRegenDelay;
                this.isBlocking = false; 
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("SHIELD SHATTERED");
                if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 30, 0x00ffff, 20); 
                if (window.flux.audio) window.flux.audio.play('massive_impact'); 
                if (window.flux.shake) window.flux.shake(0.5);
                
                _pVec1.set(0, 0, 10).applyQuaternion(this.mesh.quaternion);
                this.velocity.add(_pVec1);
            }
            
            this.updateHUD();
            return;
        }

        let finalDamage = amount;
        if (this.ap > 0 && !this.isShieldDisabled) {
            const absorption = Math.min(this.ap, amount * 0.2); 
            this.ap -= absorption;
            finalDamage -= absorption;
        }

        this.hp -= finalDamage;
        if (this.hp < 0) this.hp = 0;
        this.shellReveal = 0.2; 
        const vig = document.querySelector('.vignette');
        if (vig) {
            if (this.hp < 30) vig.classList.add('danger');
            else vig.classList.remove('danger');
        }
        this.kinematics.tiltX.vel += 5.0; 
        this.kinematics.crouch.vel += 2.0; 
        if(window.flux.audio) window.flux.audio.play('hit_flesh');
        if (amount > 20 && !this.isOverdrive) { 
            this.isKnockedDown = true;
            this.velocity.y = 15; 
            _pVec1.set(0, 0, 10).applyQuaternion(this.mesh.quaternion);
            this.velocity.add(_pVec1); 
        }
        if (!this.isFlashing) {
            this.isFlashing = true;
            this.mesh.traverse((child) => {
                if (child.isMesh && child.material.emissive) {
                    child.material.emissive.setHex(0xff0000);
                }
            });
            setTimeout(() => {
                if (!this.mesh) return; 
                if (this.matMetatron) this.matMetatron.emissive.setHex(this.isOverdrive ? 0xff0055 : 0xff3300);
                if (this.matBlade) this.matBlade.emissive.setHex(this.isOverdrive ? 0xff0055 : 0x00ffff);
                this.isFlashing = false;
            }, 100);
        }
        if (window.flux && window.flux.shake) window.flux.shake(0.4);
        
        this.updateHUD();
        
        if (this.hp <= 0) this.die();
    }

    die() {
        this.isDead = true;
        this.visible = false; 
        this.targetEnemy = null; 
        if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 50, 0x00f3ff, 20);
        if (window.flux && window.flux.onPlayerDeath) window.flux.onPlayerDeath();
        if (this.weaponContainer) this.weaponContainer.visible = false;
        if (window.flux.audio && window.flux.audio.stopLoop) window.flux.audio.stopLoop('run_loop');
        this.isRunningAudio = false;
    }

    reset() {
        this.hp = this.maxHp;
        this.ap = 50;
        this.shieldHp = this.shieldMaxHp;
        this.isShieldBroken = false;
        this.isShieldDisabled = false;
        this.isDead = false;
        this.mesh.position.set(0, 5, 0);
        this.velocity.set(0,0,0);
        this.mesh.rotation.set(0, Math.PI, 0); 
        this.camRotationY = Math.PI; 
        this.moveReferenceAngle = null; 
        
        if (this.weaponContainer) this.weaponContainer.visible = true;
        this.ammo = this.maxAmmo;
        this.landingLag = 0;
        this.isReloading = false;
        this.isKnockedDown = false;
        this.isOverdrive = false;
        this.shellReveal = 1.0; 
        const vig = document.querySelector('.vignette');
        if (vig) vig.classList.remove('danger');
        this.updateHUD();
    }

    // --- SEPARATED UPDATE LOOPS FOR SYNC ---
    
    update(dt, input, camera) {
        if (this.isDead || dt === 0) return; 

        if (this.spaceFireTimer > 0) this.spaceFireTimer -= dt;
        if (this.barrelRollTimer > 0) this.barrelRollTimer -= dt;

        if (this.isSpaceMode) {
            if (typeof PlayerSpace !== 'undefined') {
                PlayerSpace.update(this, dt, input);
            }
            return;
        }

        this.checkOverdrive();
        this.gravityScale = 1.0;
        
        // --- SHIELD REGEN ---
        if (this.isShieldDisabled) {
            this.shieldHp = 0;
            this.isShieldBroken = true;
        } else {
            if (this.isShieldBroken) {
                this.shieldCooldown -= dt;
                if (this.shieldCooldown <= 0) {
                    this.isShieldBroken = false;
                    this.shieldHp = this.shieldMaxHp; 
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("SHIELD RESTORED");
                    if (window.flux.audio) window.flux.audio.play('charge');
                }
            } else if (this.shieldHp < this.shieldMaxHp && !this.isBlocking) {
                this.shieldHp += dt * 5;
                if (this.shieldHp > this.shieldMaxHp) this.shieldHp = this.shieldMaxHp;
            }
        }
        
        this.updateHUD();
        
        if (this.shieldMesh && this.matShield) {
            this.shieldMesh.visible = (this.isBlocking && !this.isShieldBroken && !this.isShieldDisabled);
            if (this.shieldMesh.visible) {
                this.matShield.uniforms.uTime.value += dt;
                const damage = 1.0 - (this.shieldHp / this.shieldMaxHp);
                this.matShield.uniforms.uDamage.value = damage;
            }
        }

        if (this.isFirstPerson && this.targetEnemy && !this.targetEnemy.userData.isDead) {
            _pVec1.copy(this.targetEnemy.position);
            _pVec1.y += 1.0; 
            _pVec2.subVectors(_pVec1, this.mesh.position); 
            
            const targetYaw = Math.atan2(_pVec2.x, _pVec2.z);
            const targetPitch = Math.atan2(_pVec2.y - 1.5, Math.sqrt(_pVec2.x*_pVec2.x + _pVec2.z*_pVec2.z));
            
            let yawDiff = targetYaw - this.mesh.rotation.y;
            while (yawDiff > Math.PI) yawDiff -= Math.PI * 2;
            while (yawDiff < -Math.PI) yawDiff += Math.PI * 2;
            
            this.mesh.rotation.y += yawDiff * 10.0 * dt;
            const clampedPitch = Math.max(-1.4, Math.min(1.4, targetPitch));
            this.camPitch += (clampedPitch - this.camPitch) * 10.0 * dt;
        }

        this.handleInput(dt, input, camera);
        
        if (this.inputBuffer.action) {
            this.inputBuffer.time -= dt;
            if (this.inputBuffer.time <= 0) {
                this.inputBuffer.action = null;
            }
        }
        
        if (this.parryWindow > 0) this.parryWindow -= dt;
        if (this.wallMagnetismTimer > 0) this.wallMagnetismTimer -= dt;
        if (this.perfectDodgeWindow > 0) this.perfectDodgeWindow -= dt;

        if (typeof PlayerPhysics !== 'undefined') {
            PlayerPhysics.applyPhysics(this, dt);
        }
        
        if (typeof PlayerCombat !== 'undefined') {
            PlayerCombat.update(this, dt, camera);
        }
        
        // NOTE: Animation update is now called separately via updateAnimation()
        // to ensure Camera is updated BEFORE IK solves.
        
        this.updateCrosshair();
        
        if (this.landingLag > 0) {
            this.landingLag -= dt;
        }
        
        if (this.isWallRunning) {
            this.wallRunSoundTimer -= dt;
            if (this.wallRunSoundTimer <= 0) {
                if(window.flux.audio) window.flux.audio.play('wall_run');
                this.wallRunSoundTimer = 0.15; 
            }
        }
        
        if (input && input.actions) {
            this.wasJumpDown = input.actions.jump;
            this.wasDashDown = input.actions.dash;
            this.wasAttackDown = input.actions.attack;
            this.wasBlockDown = input.actions.block;
            this.wasSwitchDown = input.actions.switch;
            this.wasReloadDown = input.actions.reload;
            this.wasStyleDown = input.actions.style;
            this.wasLockDown = input.actions.lock;
            this.wasCamSwitchDown = input.actions['cam-switch']; 
            this.wasMissileDown = input.actions.missile;
        }

        const isMoving = input && input.moveVector && (Math.abs(input.moveVector.x) > 0.1 || Math.abs(input.moveVector.y) > 0.1);
        
        // PERF: Audio Loop Spam Fix
        if (this.onGround && isMoving && !this.isDashing && !this.isKnockedDown) {
            if (!this.isRunningAudio) {
                if (window.flux.audio && window.flux.audio.startLoop) window.flux.audio.startLoop('run_loop');
                this.isRunningAudio = true;
            }
        } else {
            if (this.isRunningAudio) {
                if (window.flux.audio && window.flux.audio.stopLoop) window.flux.audio.stopLoop('run_loop');
                this.isRunningAudio = false;
            }
        }
        
        // PERF: Throttled Ghost Spawn (15 frames instead of 5)
        if (this.isOverdrive && (this.isDashing || isMoving) && window.game && window.game.frameCount % 15 === 0) {
            if (window.flux && window.flux.spawnGhost) {
                window.flux.spawnGhost(this.visualGroup, true); 
            }
        }
    }
    
    // NEW: Separate Animation Update
    updateAnimation(dt, camera) {
        if (this.isDead || this.isSpaceMode) return;
        if (typeof PlayerAnimation !== 'undefined') {
            PlayerAnimation.update(this, dt, camera);
        }
    }

    updateCrosshair() {
        const chCircle = document.querySelector('.ch-circle');
        if (!chCircle) return;
        
        let spread = 20; 
        const speed = this.velocity.length();
        if (speed > 1) spread += speed * 0.5;
        if (this.isAttacking || this.fireTimer > 0) spread += 20;
        if (this.currentWeapon !== this.WEAPON_MELEE) spread += 10;
        if (!this.onGround) spread += 15;
        if (this.currentWeapon === this.WEAPON_BEAM) spread = 10;
        
        // PERF: Only update DOM if spread changed significantly
        if (!this.lastSpread || Math.abs(this.lastSpread - spread) > 2) {
            chCircle.style.width = `${spread}px`;
            chCircle.style.height = `${spread}px`;
            this.lastSpread = spread;
        }
        
        if (this.currentWeapon !== this.WEAPON_MELEE) {
            chCircle.style.borderColor = "rgba(255, 255, 255, 0.8)";
        } else {
            chCircle.style.borderColor = "rgba(255, 255, 255, 0.2)";
        }
    }

    bufferAction(actionName) {
        this.inputBuffer.action = actionName;
        this.inputBuffer.time = this.BUFFER_WINDOW;
    }

    handleInput(dt, input, camera) {
        if (!input || !input.actions) return;
        
        const jumpIntent = (this.inputBuffer.action === 'jump');
        const dashIntent = (this.inputBuffer.action === 'dash');
        const attackIntent = (this.inputBuffer.action === 'attack');

        const blockPressed = input.actions.block; 
        const switchPressed = input.actions.switch && !this.wasSwitchDown;
        const reloadPressed = input.actions.reload && !this.wasReloadDown;
        const stylePressed = input.actions.style && !this.wasStyleDown;
        const lockPressed = input.actions.lock && !this.wasLockDown; 
        const camSwitchPressed = input.actions['cam-switch'] && !this.wasCamSwitchDown; 
        const techHeld = input.actions.tech; 
        
        if (input.actions.jump && !this.wasJumpDown) this.bufferAction('jump');
        if (input.actions.dash && !this.wasDashDown) this.bufferAction('dash');
        if (input.actions.attack && !this.wasAttackDown) this.bufferAction('attack'); 
        
        if (this.jumpBufferTimer > 0) this.jumpBufferTimer -= dt;
        if (this.dashCooldown > 0) this.dashCooldown -= dt;
        if (this.comboTimer > 0) this.comboTimer -= dt;
        if (this.comboTimer <= 0) this.comboIndex = 0; 
        if (this.fireTimer > 0) this.fireTimer -= dt;

        if (stylePressed) {
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.cycleStyle(this);
        }
        if (switchPressed) {
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.switchWeapon(this);
        }
        
        if (camSwitchPressed) { 
            this.isFirstPerson = !this.isFirstPerson;
            if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText(this.isFirstPerson ? "VIEW: FPS" : "VIEW: TPS");
            if (window.flux.audio) window.flux.audio.play('switch');
        }
        
        if (reloadPressed) {
            this.fireTimer = 0;
            if (this.currentWeapon !== this.WEAPON_MELEE) {
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("R-SHOT");
                if (this.ammo < this.maxAmmo) {
                    if (typeof PlayerCombat !== 'undefined') PlayerCombat.startReload(this);
                }
            }
        }

        if (typeof PlayerCombat !== 'undefined') PlayerCombat.updateLockOn(this, lockPressed);
        
        if (this.currentWeapon !== this.WEAPON_MELEE) {
            if (attackIntent && !this.isReloading) {
                if (typeof PlayerCombat !== 'undefined') PlayerCombat.shoot(this, camera);
                this.inputBuffer.action = null;
            }
        } else {
            if (attackIntent && !this.isReloading && this.landingLag <= 0) {
                if (!this.isBlocking && !this.isAttacking) {
                    if (typeof PlayerCombat !== 'undefined') PlayerCombat.performAttack(this, false);
                    this.inputBuffer.action = null; 
                }
            }
        }

        const missileHeld = input.actions.missile;
        if (missileHeld) {
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.chargeHomingLasers(this, dt);
        } else if (this.wasMissileDown && this.isCharging) {
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.releaseHomingLasers(this);
            this.inputBuffer.action = null;
        } else if (this.wasMissileDown && !this.isCharging) {
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.releaseHomingLasers(this);
        }
        
        if (!missileHeld && this.isCharging) {
             this.isCharging = false;
             this.attackHoldTimer = 0;
        }

        if (blockPressed && this.currentWeapon === this.WEAPON_MELEE && !this.isShieldBroken && !this.isShieldDisabled) {
            if (this.currentStyle === this.STYLE_DAGGER) return; 
            if (this.isAttacking) {
                const progress = 1.0 - (this.attackTimer / this.attackTotalDuration);
                if (progress > 0.2) { 
                    this.isAttacking = false; 
                    if(this.activeSlashMesh) {
                        if(this.activeSlashMesh.parent) this.activeSlashMesh.parent.remove(this.activeSlashMesh);
                        this.activeSlashMesh = null;
                    }
                    this.attackTimer = 0;
                    if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 5, 0xffff00, 10);
                    if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("GUARD CANCEL");
                    if (!this.isBlocking) {
                        if (window.flux.audio) window.flux.audio.play('block');
                        this.parryWindow = 0.2; 
                        if (window.flux.spawnVectorTrap) window.flux.spawnVectorTrap(this.mesh.position);
                    }
                    this.isBlocking = true;
                }
            } else if (!this.isBlocking) {
                if (window.flux.audio) window.flux.audio.play('block');
                this.parryWindow = 0.2; 
                if (window.flux.spawnVectorTrap) window.flux.spawnVectorTrap(this.mesh.position);
                this.isBlocking = true;
            } else {
                this.isBlocking = true; 
            }
            this.isCharging = false;
            if (typeof PlayerCombat !== 'undefined') PlayerCombat.checkBlockCollision(this);
        } else {
            this.isBlocking = false;
        }

        if (techHeld) {
            if (dashIntent && this.dashCooldown <= 0) {
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("BUTTERFLY");
                this.velocity.y = this.jumpForce;
                this.onGround = false;
                this.coyoteTimer = 0;
                this.startDash(input, camera, false);
                setTimeout(() => { if (!this.isDead && typeof PlayerCombat !== 'undefined') PlayerCombat.performAttack(this, false); }, 50);
                setTimeout(() => { if (!this.isDead && this.isAttacking) { this.isAttacking = false; this.isBlocking = true; if (window.flux && window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 5, 0xffff00, 10); } }, 200); 
                this.inputBuffer.action = null;
                return; 
            }
            if (jumpIntent && this.touchingWall) {
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("WALL CLIMB");
                const normal = this.lastWallNormal.lengthSq() > 0 ? this.lastWallNormal : _pAxisY; 
                const horizontalPush = 25; 
                this.velocity.copy(normal).multiplyScalar(horizontalPush);
                this.velocity.y = this.jumpForce * 1.2; 
                const angle = Math.atan2(-normal.z, normal.x) + (Math.PI/2);
                this.mesh.rotation.y = angle;
                this.isWallRunning = false;
                this.wasWallJump = true;
                this.wallMagnetismTimer = 0;
                setTimeout(() => { if (!this.isDead && typeof PlayerCombat !== 'undefined') PlayerCombat.performAttack(this, false); }, 50);
                setTimeout(() => { if (!this.isDead) { this.isAttacking = false; const dashDir = normal.clone().negate(); this.velocity.x = dashDir.x * 60; this.velocity.z = dashDir.z * 60; this.isDashing = true; this.dashTime = this.dashDuration; } }, 250);
                this.inputBuffer.action = null;
                return; 
            }
        }

        if (dashIntent && this.dashCooldown <= 0 && !this.isCharging) {
            if (this.isReloading) { 
                this.isReloading = false; 
                this.ammo = this.maxAmmo; 
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("ACTIVE RELOAD");
                this.updateHUD(); 
            }
            
            let isSilent = false;
            if (this.isAttacking) isSilent = true;
            this.isAttacking = false;
            this.isBlocking = false;
            if(this.activeSlashMesh) { 
                if(this.activeSlashMesh.parent) this.activeSlashMesh.parent.remove(this.activeSlashMesh);
                this.activeSlashMesh = null; 
            }
            this.startDash(input, camera, isSilent);
            this.inputBuffer.action = null; 
        }

        if (!this.isSpaceMode && !this.onGround && input.actions.jump && this.ap > 0) {
             this.isThrusterActive = true;
             this.velocity.y += 120 * dt; 
             if (this.velocity.y > 15) this.velocity.y = 15; 
             this.ap -= 15 * dt; 
             if (window.flux.spawnParticles && Math.random() > 0.5) {
                 _pVec1.copy(this.mesh.position).add(_pAxisY);
                 window.flux.spawnParticles(_pVec1, 1, 0x00ffff, 10);
             }
        } else {
             this.isThrusterActive = false;
        }

        if (!this.isDashing && this.landingLag <= 0) {
            let speedMod = 1.0;
            if (this.currentStyle === this.STYLE_DAGGER) speedMod = 1.2;
            if (this.currentStyle === this.STYLE_GREATSWORD) speedMod = 0.8;
            if (this.isOverdrive) speedMod *= 1.3; 

            const lookX = input.lookVector ? input.lookVector.x : 0;
            const lookY = input.lookVector ? input.lookVector.y : 0;
            
            if (this.isFirstPerson) {
                if (Math.abs(lookX) > 0.05) this.mesh.rotation.y -= lookX * 3.0 * dt;
                if (Math.abs(lookY) > 0.05) {
                    this.camPitch += lookY * 2.0 * dt; 
                    this.camPitch = Math.max(-1.4, Math.min(1.4, this.camPitch));
                }
                if (input.gyroEnabled && input.getGyroDelta) {
                    const gyro = input.getGyroDelta();
                    const gyroSens = 0.05; 
                    if (Math.abs(gyro.x) > 0.01) this.mesh.rotation.y -= gyro.x * gyroSens;
                    if (Math.abs(gyro.y) > 0.01) {
                        this.camPitch -= gyro.y * gyroSens; 
                        this.camPitch = Math.max(-1.4, Math.min(1.4, this.camPitch));
                    }
                }
            } else {
                if (Math.abs(lookX) > 0.05) {
                    this.camRotationY -= lookX * 3.0 * dt;
                    while (this.camRotationY > Math.PI) this.camRotationY -= Math.PI * 2;
                    while (this.camRotationY < -Math.PI) this.camRotationY += Math.PI * 2;
                }
            }

            const moveVec = input.moveVector || { x: 0, y: 0 };
            const mx = moveVec.x || 0;
            const my = moveVec.y || 0;
            
            _pVec1.set(0,0,0); 
            let isMoving = (Math.abs(mx) > 0.1 || Math.abs(my) > 0.1);
            
            let targetRotationY = this.mesh.rotation.y;
            let shouldRotate = false;

            if (isMoving) {
                // CRITICAL FIX: Allow movement even when locked on
                // If locked on, we strafe relative to camera/target
                // If not locked on, we rotate to face movement direction
                
                if (this.isFirstPerson) {
                    this.moveReferenceAngle = null; 
                    const rotY = this.mesh.rotation.y;
                    _pForward.set(Math.sin(rotY), 0, Math.cos(rotY));
                    _pRight.crossVectors(_pForward, _pAxisY);
                    _pVec1.addScaledVector(_pForward, my).addScaledVector(_pRight, mx);
                    
                    // CRITICAL FIX: Safe Normalize to prevent NaN Poisoning
                    if (_pVec1.lengthSq() > 0.0001) _pVec1.normalize();
                } else {
                    // TPS Movement Logic
                    if (this.targetEnemy && !this.targetEnemy.userData.isDead) {
                        // LOCKED ON: Strafing Logic
                        // Movement is relative to CAMERA, but player faces TARGET
                        
                        // 1. Calculate Camera-Relative Movement Vector
                        // We use camRotationY as reference frame
                        // Note: camRotationY is updated by right stick in Game.js
                        // But when locked on, camera looks at target.
                        // We need the camera's actual yaw.
                        
                        // Get camera forward vector projected on XZ plane
                        // We can approximate this using the vector from camera to player
                        if (window.game && window.game.camera) {
                            const camPos = window.game.camera.position;
                            const pPos = this.mesh.position;
                            const camFwd = new THREE.Vector3().subVectors(pPos, camPos);
                            camFwd.y = 0;
                            camFwd.normalize();
                            
                            const camRight = new THREE.Vector3().crossVectors(camFwd, _pAxisY).normalize();
                            
                            // Construct movement vector based on input (mx, my) relative to camera
                            // mx is left/right, my is forward/back
                            _pVec1.set(0,0,0)
                                .addScaledVector(camFwd, my)
                                .addScaledVector(camRight, mx);
                            
                            if (_pVec1.lengthSq() > 0.0001) _pVec1.normalize();
                            
                            // Force player to face target (override rotation)
                            const targetDir = new THREE.Vector3().subVectors(this.targetEnemy.position, this.mesh.position);
                            targetDir.y = 0;
                            if (targetDir.lengthSq() > 0.001) {
                                targetDir.normalize();
                                targetRotationY = Math.atan2(targetDir.x, targetDir.z);
                                shouldRotate = true;
                            }
                        }
                    } else {
                        // FREE ROAM: Face movement direction
                        if (this.moveReferenceAngle === null) {
                            this.moveReferenceAngle = this.camRotationY;
                        }
                        const refAngle = this.moveReferenceAngle;
                        _pForward.set(Math.sin(refAngle), 0, Math.cos(refAngle));
                        _pRight.crossVectors(_pForward, _pAxisY);
                        _pVec1.addScaledVector(_pForward, my).addScaledVector(_pRight, mx);
                        
                        if (_pVec1.lengthSq() > 0.0001) {
                            _pVec1.normalize();
                            targetRotationY = Math.atan2(_pVec1.x, _pVec1.z);
                            shouldRotate = true;
                        }
                    }
                }
            } else if (!isMoving) {
                this.moveReferenceAngle = null;
                // If locked on but not moving, still face target
                if (this.targetEnemy && !this.targetEnemy.userData.isDead) {
                     const targetDir = new THREE.Vector3().subVectors(this.targetEnemy.position, this.mesh.position);
                     targetDir.y = 0;
                     if (targetDir.lengthSq() > 0.001) {
                         targetDir.normalize();
                         targetRotationY = Math.atan2(targetDir.x, targetDir.z);
                         shouldRotate = true;
                     }
                }
            }

            if (shouldRotate) {
                let angleDiff = targetRotationY - this.mesh.rotation.y;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                this.mesh.rotation.y += angleDiff * 10.0 * dt;
            }

            if (isMoving) {
                // Apply Movement Vector (_pVec1) calculated above
                // Note: _pVec1 is already normalized direction of travel
                
                _pVec1.multiplyScalar(this.acceleration * speedMod * dt);
                this.velocity.x += _pVec1.x;
                this.velocity.z += _pVec1.z;
                const dragFactor = this.onGround ? this.drag : this.airDrag;
                this.velocity.x *= (1 - (dragFactor * dt));
                this.velocity.z *= (1 - (dragFactor * dt));
            } else {
                const friction = this.onGround ? this.brakingDrag : this.airDrag;
                this.velocity.x -= this.velocity.x * friction * dt;
                this.velocity.z -= this.velocity.z * friction * dt;
                this.kinematics.chestTwist.target = 0;
            }
        } else if (this.landingLag > 0) {
            this.velocity.x *= 0.8;
            this.velocity.z *= 0.8;
        }

        if (this.onGround && this.landingLag <= 0) {
            this.coyoteTimer = this.coyoteMax;
            this.isKnockedDown = false; 
            this.wasWallJump = false; 
            this.canWallJump = false; 
        } else {
            if (this.coyoteTimer > 0) this.coyoteTimer -= dt;
        }

        if (jumpIntent) this.jumpBufferTimer = this.jumpBufferMax;

        if (this.jumpBufferTimer > 0) {
            let jumped = false;
            if (this.isKnockedDown) {
                this.isKnockedDown = false;
                this.velocity.y = this.jumpForce * 0.8;
                this.kinematics.tiltX.vel = -20;
                if(window.flux.audio) window.flux.audio.play('jump');
                window.flux.spawnParticles(this.mesh.position, 10, 0x00ff00, 10);
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("SAFE FALL");
                jumped = true;
            }
            else if (this.canWallJump) { 
                const normal = this.lastWallNormal.lengthSq() > 0 ? this.lastWallNormal : _pAxisY;
                const horizontalPush = 25; 
                this.velocity.copy(normal).multiplyScalar(horizontalPush);
                this.velocity.y = this.jumpForce * 1.2; 
                const angle = Math.atan2(normal.x, normal.z);
                this.mesh.rotation.y = angle;
                this.dashTime = 0;
                this.isDashing = false;
                this.isWallRunning = false;
                this.landingLag = 0;
                this.wasWallJump = true; 
                this.canWallJump = false; 
                this.wallMagnetismTimer = 0;
                this.dashCooldown = 0;
                this.isAttacking = false;
                if(this.activeSlashMesh) { 
                    if(this.activeSlashMesh.parent) this.activeSlashMesh.parent.remove(this.activeSlashMesh);
                    this.activeSlashMesh = null; 
                }
                this.kinematics.crouch.vel = -10; 
                if(window.flux && window.flux.shake) window.flux.shake(0.5);
                if(window.flux.audio) window.flux.audio.play('jump');
                if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("WALL JUMP");
                jumped = true;
            } 
            else if (this.coyoteTimer > 0) {
                this.velocity.y = this.jumpForce;
                this.onGround = false;
                this.coyoteTimer = 0;
                if (this.isDashing) { this.isDashing = false; this.velocity.x *= 1.2; this.velocity.z *= 1.2; }
                this.kinematics.crouch.vel = -15;
                if(window.flux.audio) window.flux.audio.play('jump');
                jumped = true;
            }
            if (jumped) {
                this.jumpBufferTimer = 0; 
                this.inputBuffer.action = null; 
            }
        }
        
        if (!this.isThrusterActive && !this.isDashing && !this.isBlocking && this.ap < 50) {
            this.ap += 10 * dt; 
        }
    }
    
    startDash(input, camera, isSilent = false) {
        if (this.ap < 10) return; 
        this.ap -= 10; 
        
        this.isDashing = true;
        this.dashTime = this.dashDuration;
        this.dashCooldown = 0.2; 
        if (this.isOverdrive) this.dashCooldown = 0.1;
        this.perfectDodgeWindow = 0.15; 
        
        if (!isSilent) { if(window.flux.audio) window.flux.audio.play('teleport'); }
        if (window.flux && window.flux.spawnGhost) window.flux.spawnGhost(this.visualGroup, isSilent);
        this.kinematics.tiltX.vel += 5.0; 
        this.kinematics.crouch.vel += 3.0; 
        
        _pVec1.set(0,0,0);
        
        const moveVec = (input && input.moveVector) ? input.moveVector : { x: 0, y: 0 };
        const mx = moveVec.x || 0;
        const my = moveVec.y || 0;
        
        if (Math.abs(mx) > 0.1 || Math.abs(my) > 0.1) {
             if (this.isFirstPerson) {
                 const rotY = this.mesh.rotation.y;
                 _pForward.set(Math.sin(rotY), 0, Math.cos(rotY));
                 _pRight.crossVectors(_pForward, _pAxisY);
                 _pVec1.addScaledVector(_pForward, my).addScaledVector(_pRight, mx);
                 if (_pVec1.lengthSq() > 0.0001) _pVec1.normalize();
             } else {
                 const refAngle = (this.moveReferenceAngle !== null) ? this.moveReferenceAngle : this.camRotationY;
                 _pForward.set(Math.sin(refAngle), 0, Math.cos(refAngle));
                 _pRight.crossVectors(_pForward, _pAxisY);
                 _pVec1.addScaledVector(_pForward, my).addScaledVector(_pRight, mx);
                 if (_pVec1.lengthSq() > 0.0001) _pVec1.normalize();
             }
        } else {
            const rotY = this.mesh.rotation.y;
            _pVec1.set(Math.sin(rotY), 0, Math.cos(rotY));
        }
        
        let dashDist = 12.0; 
        if (this.isOverdrive) dashDist = 18.0;
        
        _pVec2.copy(this.mesh.position);
        
        let targetPos;
        if (this.targetEnemy && !this.targetEnemy.userData.isDead) {
            _pVec3.subVectors(this.targetEnemy.position, _pVec2);
            const distToTarget = _pVec3.length();
            
            _pVec1.copy(_pVec3).normalize();
            
            const travelDist = Math.min(distToTarget - 2.0, dashDist);
            if (travelDist > 0) {
                targetPos = _pVec2.clone().add(_pVec1.clone().multiplyScalar(travelDist));
                
                this.velocity.x = _pVec1.x * 30;
                this.velocity.z = _pVec1.z * 30;
                this.velocity.y = _pVec1.y * 30; 
                
                this.onGround = false; 
            } else {
                targetPos = _pVec2.clone().add(_pVec1.clone().multiplyScalar(dashDist));
                this.velocity.x = _pVec1.x * 30;
                this.velocity.z = _pVec1.z * 30;
                this.velocity.y = _pVec1.y * 30;
            }
        } else {
            targetPos = _pVec2.clone().add(_pVec1.clone().multiplyScalar(dashDist));
            
            this.velocity.x = _pVec1.x * 30;
            this.velocity.z = _pVec1.z * 30;
            this.velocity.y = 0; 
        }
        
        _pVec3.copy(_pVec2).add(_pAxisY); 
        this.raycaster.set(_pVec3, _pVec1);
        this.raycaster.far = dashDist;
        
        let finalPos = targetPos;
        if (this.staticGroup) {
            const intersects = this.raycaster.intersectObjects(this.staticGroup.children, true);
            if (intersects.length > 0) {
                const hitDist = intersects[0].distance;
                finalPos = _pVec2.clone().add(_pVec1.clone().multiplyScalar(hitDist - 1.5));
            }
        }
        this.mesh.position.copy(finalPos);
        
        if (window.flux && window.flux.spawnGhost) window.flux.spawnGhost(this.visualGroup, true);
        if(window.flux && window.flux.shake) window.flux.shake(0.2);
    }

    updateHUD() {
        if (typeof updateHUD === 'function') {
            updateHUD();
        }
    }
}</script>
    
    <!-- ENEMY MODULES (Refactored from enemies.js) -->
    <script>/**
 * MECH DRONE ENEMY CLASS
 * Extracted from enemies.js
 * Handles Standard, Sniper, Assault, Bomber, Support, Gargantua, Scyther, Lag Knight, and Zealot.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes in update loops.
 * OPTIMIZED: Implemented reset() for Object Pooling.
 * UPDATED: Added Logic for Lag Knight (Shield) and Neural Zealot (Glitch).
 * UPDATED: Added HYPER-ARMOR config for Enforcer Mech (Gargantua).
 * UPDATED: Added SHIELD REGENERATION logic for Lag Knight.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _dVec1 = new THREE.Vector3();
const _dVec2 = new THREE.Vector3();
const _dVec3 = new THREE.Vector3();
const _dVec4 = new THREE.Vector3();
const _dQuat = new THREE.Quaternion();
const _dUp = new THREE.Vector3(0, 1, 0);

class MechDroneEnemy {
    constructor(scene, type = 'standard', position = new THREE.Vector3()) {
        this.scene = scene;
        this.type = type;
        this.group = new THREE.Group();
        
        // Base stats
        this.config = this.getDroneConfig(type);
        
        // Initialize UserData (Critical for Player.js compatibility)
        this.group.userData = {
            type: 'enemy',
            enemyType: type,
            hp: this.config.maxHp,
            maxHp: this.config.maxHp,
            shieldHp: this.config.maxShield || 0, // NEW: Shield HP
            maxShield: this.config.maxShield || 0,
            velocity: new THREE.Vector3(),
            isDead: false,
            controller: this, // Link back to this class instance
            onGround: false, // Drones fly
            springs: { // For hit deformation
                scale: { pos: 1, vel: 0, target: 1, k: 200, d: 15 },
                tiltX: { pos: 0, vel: 0, target: 0, k: 150, d: 12 },
                tiltZ: { pos: 0, vel: 0, target: 0, k: 150, d: 12 }
            }
        };

        this.state = 'SPAWNING';
        this.attackCooldown = 0;
        this.staggerTimer = 0; // NEW: Stagger state timer
        
        // Movement
        this.targetPosition = position.clone();
        this.patrolPoints = [];
        this.currentPatrolIndex = 0;
        
        // Combat
        this.aggroRange = this.config.aggroRange;
        this.attackRange = this.config.attackRange;
        
        // Visual effects
        this.damageFlashTimer = 0;
        this.deathExplosion = false;
        
        // Shield Logic
        this.shieldMesh = null;
        this.shieldRegenTimer = 0;
        
        this.initMesh();
        this.setPosition(position);
        this.initBehavior();
    }
    
    // NEW: Reset method for Pooling
    reset(position) {
        this.group.position.copy(position);
        this.group.visible = true;
        this.group.rotation.set(0, 0, 0);
        
        // Reset Stats
        this.group.userData.hp = this.config.maxHp;
        this.group.userData.shieldHp = this.config.maxShield || 0;
        this.group.userData.isDead = false;
        this.group.userData.velocity.set(0, 0, 0);
        
        // Reset State
        this.state = 'SPAWNING';
        this.attackCooldown = 0;
        this.staggerTimer = 0;
        this.damageFlashTimer = 0;
        this.shieldRegenTimer = 0;
        
        // Reset Springs
        this.group.userData.springs.scale.pos = 1;
        this.group.userData.springs.scale.vel = 0;
        this.group.userData.springs.tiltX.pos = 0;
        this.group.userData.springs.tiltX.vel = 0;
        this.group.userData.springs.tiltZ.pos = 0;
        this.group.userData.springs.tiltZ.vel = 0;
        
        // Reset Visuals
        if (this.shieldMesh) {
            this.shieldMesh.visible = (this.group.userData.shieldHp > 0);
            if (this.shieldMesh.material.uniforms) {
                this.shieldMesh.material.uniforms.uDamage.value = 0;
            }
        }
        
        // Re-init behavior (randomize patrol)
        this.initBehavior();
        
        // Reset Health Bar
        this.updateHealthBar();
        
        // Ensure materials are reset (remove flash)
        this.group.traverse(child => {
            if (child.isMesh && child.material && child.material.emissive) {
                // Reset to base emissive (derived from config color)
                const baseColor = new THREE.Color(this.config.color).multiplyScalar(0.5);
                child.material.emissive.copy(baseColor);
            }
        });
    }
    
    getDroneConfig(type) {
        const configs = {
            'standard': { maxHp: 80, speed: 8, aggroRange: 25, attackRange: 15, attackCooldown: 2.0, color: 0xff4444, size: 1.0, poise: 20 },
            'sniper': { maxHp: 60, speed: 6, aggroRange: 40, attackRange: 35, attackCooldown: 3.0, color: 0x4444ff, size: 0.8, poise: 10 },
            'assault': { maxHp: 120, speed: 12, aggroRange: 20, attackRange: 8, attackCooldown: 1.5, color: 0xffaa00, size: 1.2, poise: 40 },
            'support': { maxHp: 100, speed: 5, aggroRange: 30, attackRange: 20, attackCooldown: 4.0, color: 0x00ff44, size: 1.1, poise: 30 },
            'bomber': { maxHp: 150, speed: 4, aggroRange: 15, attackRange: 10, attackCooldown: 5.0, color: 0x880000, size: 1.5, poise: 60 },
            'scyther': { maxHp: 150, speed: 24, aggroRange: 200, attackRange: 5, attackCooldown: 0.8, color: 0x00ff00, size: 1.0, poise: 50 },
            'lag_knight': { maxHp: 400, maxShield: 300, speed: 3, aggroRange: 20, attackRange: 5, attackCooldown: 2.5, color: 0x00aaff, size: 1.8, poise: 80, hyperArmor: true }, // Shielded
            'zealot': { maxHp: 100, speed: 15, aggroRange: 30, attackRange: 10, attackCooldown: 1.0, color: 0x00ff00, size: 1.0, poise: 20 },
            'gargantua': { maxHp: 2000, speed: 3, aggroRange: 60, attackRange: 40, attackCooldown: 6.0, color: 0xaa00aa, size: 4.0, poise: 999, hyperArmor: true } // Enforcer Mech
        };
        return configs[type] || configs['standard'];
    }
    
    initMesh() {
        let mesh;
        if (typeof AssetFactory !== 'undefined') {
            if (this.type === 'gargantua') {
                mesh = AssetFactory.createMechDrone(); // Reuse mesh but scale up
                mesh.scale.set(4, 4, 4);
            } else if (this.type === 'scyther') {
                mesh = AssetFactory.createScytherMech();
                mesh.scale.set(1.0, 1.0, 1.0);
            } else if (this.type === 'lag_knight') {
                mesh = AssetFactory.createLagKnight();
                mesh.scale.set(1.2, 1.2, 1.2);
                
                // FIND SHIELD MESH
                // AssetFactory creates a group. One child is the shield.
                // It's usually added later in the sequence.
                // Let's search by material opacity or geometry type.
                mesh.traverse((child) => {
                    if (child.isMesh && child.material && child.material.transparent && child.material.opacity < 1.0) {
                        this.shieldMesh = child;
                        // Clone material for independent control
                        child.material = child.material.clone();
                    }
                });
                
            } else if (this.type === 'zealot') {
                mesh = AssetFactory.createNeuralZealot();
                mesh.scale.set(1.0, 1.0, 1.0);
            } else {
                mesh = AssetFactory.createMechDrone();
            }
        } else {
            // Fallback
            mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({color: this.config.color}));
        }
        
        this.group.add(mesh);
        
        // Customize Appearance based on type
        this.customizeAppearance();
        
        // Add health bar
        this.initHealthBar();
    }
    
    customizeAppearance() {
        // Apply type-specific color variations
        this.group.traverse((child) => {
            if (child.isMesh && child.material) {
                // Clone material to allow unique colors per instance
                if (!child.userData.matCloned) {
                    child.material = child.material.clone();
                    child.userData.matCloned = true;
                }
                
                if (child.material.emissive) {
                    child.material.emissive = new THREE.Color(this.config.color).multiplyScalar(0.5);
                }
            }
        });
    }
    
    initHealthBar() {
        const barWidth = this.config.size * 1.5;
        const barHeight = 0.1 * (this.type === 'gargantua' ? 3 : 1);
        
        this.healthBarBg = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth, barHeight),
            new THREE.MeshBasicMaterial({ color: 0x000000, depthTest: false })
        );
        this.healthBarBg.position.y = this.config.size + 0.5;
        
        this.healthBar = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth - 0.05, barHeight - 0.05),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false })
        );
        this.healthBar.position.y = this.config.size + 0.5;
        this.healthBar.position.z = 0.01;
        
        // Shield Bar (Blue overlay)
        if (this.config.maxShield > 0) {
            this.shieldBar = new THREE.Mesh(
                new THREE.PlaneGeometry(barWidth - 0.05, barHeight - 0.05),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, depthTest: false })
            );
            this.shieldBar.position.y = this.config.size + 0.5;
            this.shieldBar.position.z = 0.02; // On top of HP
            this.group.add(this.shieldBar);
        }
        
        this.group.add(this.healthBarBg);
        this.group.add(this.healthBar);
    }
    
    initBehavior() {
        switch(this.type) {
            case 'sniper': this.patrolPoints = this.generateSniperPositions(); break;
            case 'assault': this.patrolPoints = this.generateAssaultPattern(); break;
            case 'support': this.patrolPoints = this.generateSupportPositions(); break;
            case 'bomber': this.patrolPoints = this.generateBomberPath(); break;
            case 'gargantua': this.patrolPoints = this.generateBossPath(); break;
            default: this.patrolPoints = this.generateStandardPatrol();
        }
    }
    
    // NEW: Stagger Logic
    stagger(power) {
        // Hyper-Armor Check
        if (this.config.hyperArmor && power < 50) {
            // Resist stagger
            return;
        }
        
        const poise = this.config.poise || 20;
        let duration = 0.5;
        
        if (power >= poise) {
            duration = 1.5; // Heavy break
            if (window.flux && window.flux.spawnTechText) {
                // Show "BREAK" text above enemy
            }
        } else {
            duration = 0.2; // Micro flinch
        }
        
        this.staggerTimer = duration;
        this.state = 'STAGGER';
        
        // Cancel velocity
        this.group.userData.velocity.set(0,0,0);
        
        // Visual Shake
        this.group.userData.springs.scale.vel = -20; // Squash
        this.group.userData.springs.tiltX.vel = (Math.random() - 0.5) * 50;
        
        // Cancel Attack
        this.attackCooldown = Math.max(this.attackCooldown, 1.0);
    }
    
    update(dt, player) {
        // Sync local HP with UserData HP (Player.js modifies UserData directly)
        if (this.group.userData.hp <= 0 && !this.group.userData.isDead) {
            this.handleDeath();
            return;
        }
        
        if (this.group.userData.isDead) return;

        // SHIELD REGEN LOGIC
        if (this.config.maxShield > 0) {
            this.updateShield(dt);
        }

        // STAGGER CHECK
        if (this.staggerTimer > 0) {
            this.staggerTimer -= dt;
            this.updateVisuals(dt); // Still update visuals (shake)
            this.updateHealthBar();
            
            // Friction
            this.group.userData.velocity.multiplyScalar(0.8);
            _dVec1.copy(this.group.userData.velocity).multiplyScalar(dt);
            this.group.position.add(_dVec1);
            
            if (this.staggerTimer <= 0) {
                this.state = 'CHASE'; // Recover to chase
            }
            return; // Skip AI logic
        }

        this.updateState(player);
        this.updateMovement(dt, player);
        this.updateCombat(dt, player); 
        this.updateVisuals(dt);
        this.updateHealthBar();
    }
    
    updateShield(dt) {
        // If shield broken or damaged, wait before regen
        if (this.group.userData.shieldHp < this.config.maxShield) {
            this.shieldRegenTimer += dt;
            if (this.shieldRegenTimer > 5.0) { // 5s delay
                this.group.userData.shieldHp += 50 * dt; // Regen rate
                if (this.group.userData.shieldHp > this.config.maxShield) {
                    this.group.userData.shieldHp = this.config.maxShield;
                }
            }
        } else {
            this.shieldRegenTimer = 0;
        }
        
        // Update Visuals
        if (this.shieldMesh) {
            this.shieldMesh.visible = (this.group.userData.shieldHp > 0);
            
            // Pulse opacity based on health
            if (this.shieldMesh.visible) {
                const healthPct = this.group.userData.shieldHp / this.config.maxShield;
                this.shieldMesh.material.opacity = 0.3 + (healthPct * 0.3);
                
                // Rotate for effect
                this.shieldMesh.rotation.z += dt * 0.5;
            }
        }
    }
    
    updateCombat(dt, player) {
        this.attackCooldown -= dt;
        this.damageFlashTimer -= dt;
    }
    
    updateState(player) {
        if (this.state === 'SPAWNING') {
            this.state = 'PATROLLING';
            return;
        }
        
        const distanceToPlayer = this.group.position.distanceTo(player.mesh.position);
        
        if (distanceToPlayer <= this.attackRange && this.attackCooldown <= 0) {
            this.state = 'ATTACKING';
        } else if (distanceToPlayer <= this.aggroRange) {
            this.state = 'CHASING';
        } else {
            this.state = 'PATROLLING';
        }
    }
    
    updateMovement(dt, player) {
        const velocity = this.group.userData.velocity;

        switch(this.state) {
            case 'PATROLLING': this.patrolBehavior(dt); break;
            case 'CHASING': this.chaseBehavior(dt, player); break;
            case 'ATTACKING': this.attackBehavior(dt, player); break;
        }
        
        // Apply velocity with damping
        velocity.multiplyScalar(0.9);
        
        // Apply physics movement
        // Reuse _dVec1 for movement delta
        _dVec1.copy(velocity).multiplyScalar(dt);
        this.group.position.add(_dVec1);
        
        // Keep above ground
        if (this.group.position.y < 2) {
            this.group.position.y += (2 - this.group.position.y) * 5 * dt;
            velocity.y *= 0.5;
        }
        
        // Look at target
        this.updateRotation(player);
    }
    
    patrolBehavior(dt) {
        if (this.patrolPoints.length === 0) return;
        const targetPoint = this.patrolPoints[this.currentPatrolIndex];
        
        // _dVec1 = direction
        _dVec1.subVectors(targetPoint, this.group.position);
        
        if (_dVec1.lengthSq() < 4.0) { // 2.0 * 2.0
            this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;
        } else {
            _dVec1.normalize();
            this.group.userData.velocity.add(_dVec1.multiplyScalar(this.config.speed * dt));
        }
    }
    
    chaseBehavior(dt, player) {
        // _dVec1 = direction
        _dVec1.subVectors(player.mesh.position, this.group.position);
        const distSq = _dVec1.lengthSq();
        
        switch(this.type) {
            case 'sniper': // Maintain distance
                const idealDistance = this.attackRange * 0.8;
                if (distSq < idealDistance * idealDistance) _dVec1.multiplyScalar(-1);
                break;
            case 'support': // Stay at medium range
                const supportDistance = this.attackRange * 0.6;
                if (distSq < supportDistance * supportDistance) {
                    _dVec1.normalize().multiplyScalar(supportDistance - Math.sqrt(distSq));
                }
                break;
            case 'scyther': // RUSH DOWN
                // Aggressive acceleration
                _dVec1.normalize();
                this.group.userData.velocity.add(_dVec1.multiplyScalar(this.config.speed * 2.0 * dt));
                return; // Skip default
            case 'lag_knight': // Slow, steady advance
                _dVec1.normalize();
                this.group.userData.velocity.add(_dVec1.multiplyScalar(this.config.speed * 0.8 * dt));
                return;
            case 'zealot': // Erratic, fast
                _dVec1.normalize();
                // Add random jitter
                _dVec1.x += (Math.random() - 0.5) * 2.0;
                _dVec1.z += (Math.random() - 0.5) * 2.0;
                _dVec1.normalize();
                this.group.userData.velocity.add(_dVec1.multiplyScalar(this.config.speed * 1.2 * dt));
                return;
            case 'gargantua': // Slow relentless advance
                break;
        }
        
        _dVec1.normalize();
        this.group.userData.velocity.add(_dVec1.multiplyScalar(this.config.speed * 1.5 * dt));
    }
    
    attackBehavior(dt, player) {
        switch(this.type) {
            case 'sniper': this.group.userData.velocity.multiplyScalar(0.5); break;
            case 'assault': // Circle strafe
                // _dVec1 = toPlayer
                _dVec1.subVectors(player.mesh.position, this.group.position);
                // _dVec2 = sideVector
                _dVec2.crossVectors(_dUp, _dVec1).normalize();
                this.group.userData.velocity.add(_dVec2.multiplyScalar(this.config.speed * dt));
                break;
            case 'bomber': // Charge
                _dVec1.subVectors(player.mesh.position, this.group.position).normalize();
                this.group.userData.velocity.add(_dVec1.multiplyScalar(this.config.speed * 2 * dt));
                break;
            case 'scyther': // Lunge
                _dVec1.subVectors(player.mesh.position, this.group.position).normalize();
                this.group.userData.velocity.add(_dVec1.multiplyScalar(this.config.speed * 3.0 * dt));
                break;
            case 'lag_knight': // Shield Bash
                _dVec1.subVectors(player.mesh.position, this.group.position).normalize();
                this.group.userData.velocity.add(_dVec1.multiplyScalar(this.config.speed * 2.0 * dt));
                break;
            case 'zealot': // Circle and fire
                _dVec1.subVectors(player.mesh.position, this.group.position);
                _dVec2.crossVectors(_dUp, _dVec1).normalize();
                this.group.userData.velocity.add(_dVec2.multiplyScalar(this.config.speed * 1.5 * dt));
                break;
            case 'gargantua':
                this.group.userData.velocity.multiplyScalar(0.1); // Stop to fire
                break;
        }
        this.executeAttack(player);
    }
    
    executeAttack(player) {
        if (this.attackCooldown > 0) return;
        
        switch(this.type) {
            case 'standard': this.standardAttack(player); break;
            case 'sniper': this.sniperAttack(player); break;
            case 'assault': this.assaultAttack(player); break;
            case 'support': this.supportAttack(player); break;
            case 'bomber': this.bomberAttack(player); break;
            case 'scyther': this.scytherAttack(player); break;
            case 'lag_knight': this.lagKnightAttack(player); break;
            case 'zealot': this.zealotAttack(player); break;
            case 'gargantua': this.gargantuaAttack(player); break;
        }
        this.attackCooldown = this.config.attackCooldown;
    }
    
    standardAttack(player) {
        const startPos = this.group.position.clone();
        const direction = new THREE.Vector3().subVectors(player.mesh.position, startPos).normalize();
        if (window.flux && window.flux.spawnEnemyProjectile) window.flux.spawnEnemyProjectile(startPos, direction);
        this.muzzleFlash();
    }
    
    sniperAttack(player) {
        const startPos = this.group.position.clone();
        const direction = new THREE.Vector3().subVectors(player.mesh.position, startPos).normalize();
        this.laserSight(player.mesh.position);
        setTimeout(() => {
            if (!this.group.userData.isDead && window.flux && window.flux.spawnEnemyProjectile) {
                window.flux.spawnEnemyProjectile(startPos, direction);
                window.flux.spawnEnemyProjectile(startPos, direction);
            }
        }, 500);
        this.muzzleFlash(0x4444ff);
    }
    
    assaultAttack(player) {
        const burstCount = 3;
        const burstDelay = 100;
        for (let i = 0; i < burstCount; i++) {
            setTimeout(() => {
                if (!this.group.userData.isDead) {
                    const startPos = this.group.position.clone();
                    const spread = new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2);
                    const direction = new THREE.Vector3().subVectors(player.mesh.position, startPos).add(spread).normalize();
                    if (window.flux && window.flux.spawnEnemyProjectile) window.flux.spawnEnemyProjectile(startPos, direction);
                    if (i === burstCount - 1) this.muzzleFlash(0xffaa00);
                }
            }, i * burstDelay);
        }
    }
    
    supportAttack(player) {
        // Heal allies
        if (window.flux && window.flux.enemies) {
            window.flux.enemies.forEach(enemyGroup => {
                // CRITICAL FIX: Use enemyGroup.userData.maxHp to avoid crash when enemy.config is undefined (e.g. Hunter/Boss)
                if (enemyGroup !== this.group && !enemyGroup.userData.isDead && enemyGroup.userData.hp < enemyGroup.userData.maxHp) {
                    const distance = this.group.position.distanceTo(enemyGroup.position);
                    if (distance < 15) {
                        enemyGroup.userData.hp = Math.min(enemyGroup.userData.maxHp, enemyGroup.userData.hp + 10);
                        if (window.flux.spawnParticles) window.flux.spawnParticles(enemyGroup.position, 5, 0x00ff44, 3);
                    }
                }
            });
        }
        this.supportBeam();
    }
    
    bomberAttack(player) {
        const bombPos = player.mesh.position.clone();
        bombPos.y = 0;
        const bombGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const bombMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bomb = new THREE.Mesh(bombGeo, bombMat);
        bomb.position.copy(this.group.position);
        bomb.userData = { type: 'bomb', life: 3.0, velocity: new THREE.Vector3(0, 10, 0) };
        this.scene.add(bomb);
        
        const arcDirection = new THREE.Vector3().subVectors(bombPos, this.group.position).normalize();
        bomb.userData.velocity.x = arcDirection.x * 8;
        bomb.userData.velocity.z = arcDirection.z * 8;
        
        const bombUpdate = () => {
            if (bomb.userData.life > 0) {
                bomb.userData.life -= 0.016;
                bomb.userData.velocity.y -= 0.5; 
                bomb.position.add(bomb.userData.velocity.clone().multiplyScalar(0.016));
                if (bomb.position.y <= 0.5) {
                    if(window.flux.explode) window.flux.explode(bomb.position);
                    this.scene.remove(bomb);
                    return;
                }
                requestAnimationFrame(bombUpdate);
            } else {
                if(window.flux.explode) window.flux.explode(bomb.position);
                this.scene.remove(bomb);
            }
        };
        bombUpdate();
    }
    
    scytherAttack(player) {
        // Melee Slash Logic
        if (window.flux.audio) window.flux.audio.play('slash_light');
        
        // Visual Slash
        if (window.flux.spawnTrail) {
            const start = this.group.position.clone().add(new THREE.Vector3(0, 1, 0));
            const end = player.mesh.position.clone().add(new THREE.Vector3(0, 1, 0));
            window.flux.spawnTrail(start, end);
        }
        
        // Lunge Impulse
        const lungeDir = new THREE.Vector3().subVectors(player.mesh.position, this.group.position).normalize();
        this.group.userData.velocity.add(lungeDir.multiplyScalar(40));
        
        // Hit Check (Cone)
        const dist = this.group.position.distanceTo(player.mesh.position);
        if (dist < 6.0) {
            player.takeDamage(10); 
            if (window.flux.shake) window.flux.shake(0.3); 
            if (window.flux.spawnHitParticles) window.flux.spawnHitParticles(player.mesh.position, new THREE.Vector3(0,1,0));
            
            // Knockback
            const dir = new THREE.Vector3().subVectors(player.mesh.position, this.group.position).normalize();
            player.velocity.add(dir.multiplyScalar(10)); 
        }
    }

    lagKnightAttack(player) {
        // Shield Bash
        const dist = this.group.position.distanceTo(player.mesh.position);
        if (dist < 4.0) {
            player.takeDamage(25);
            player.velocity.add(new THREE.Vector3(0, 10, 0)); // Launch
            player.isKnockedDown = true;
            if (window.flux.shake) window.flux.shake(0.5);
            if (window.flux.audio) window.flux.audio.play('massive_impact');
        }
    }

    zealotAttack(player) {
        // Glitch Projectile
        const startPos = this.group.position.clone();
        const direction = new THREE.Vector3().subVectors(player.mesh.position, startPos).normalize();
        
        // Custom projectile logic for glitch effect
        if (window.flux && window.flux.spawnEnemyProjectile) {
            window.flux.spawnEnemyProjectile(startPos, direction);
        }
        
        const dist = this.group.position.distanceTo(player.mesh.position);
        if (dist < 15.0) {
            // Trigger HUD Glitch
            if (document.body.classList) {
                document.body.classList.add('hud-glitch');
                setTimeout(() => document.body.classList.remove('hud-glitch'), 500);
            }
            if (window.flux.spawnTechText) window.flux.spawnTechText("SYSTEM HACK DETECTED");
        }
    }
    
    gargantuaAttack(player) {
        // 1. Charge Up
        if (window.flux && window.flux.spawnTechText) window.flux.spawnTechText("ENERGY SURGE DETECTED");
        if (window.flux && window.flux.audio) window.flux.audio.play('charge');
        
        // Visual Charge
        if (window.flux.spawnChargeParticles) window.flux.spawnChargeParticles(this.group.position);
        
        // 2. Fire Beam after delay
        setTimeout(() => {
            if (this.group.userData.isDead) return;
            
            const start = this.group.position.clone();
            const end = player.mesh.position.clone();
            
            // Overshoot the beam
            const dir = new THREE.Vector3().subVectors(end, start).normalize();
            const farEnd = start.clone().add(dir.multiplyScalar(100));
            
            if (window.flux && window.flux.fireBossBeam) {
                window.flux.fireBossBeam(start, farEnd, 1.5, 4.0); // 1.5s duration, 4.0 width
            }
            
            if (window.flux && window.flux.audio) window.flux.audio.play('laser_fire');
            if (window.flux && window.flux.shake) window.flux.shake(2.0);
            
        }, 1000);
        
        // 3. Carpet Bomb follow up
        setTimeout(() => {
             if (this.group.userData.isDead) return;
             this.carpetBomb(player);
        }, 2000);
    }
    
    carpetBomb(player) {
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                if (!this.group.userData.isDead) {
                    const bombPos = player.mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10));
                    const bombGeo = new THREE.SphereGeometry(0.6, 8, 8);
                    const bombMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                    const bomb = new THREE.Mesh(bombGeo, bombMat);
                    bomb.position.copy(this.group.position);
                    bomb.userData = { type: 'bomb', life: 3.0, velocity: new THREE.Vector3(0, 15, 0) };
                    this.scene.add(bomb);
                    
                    const arcDirection = new THREE.Vector3().subVectors(bombPos, this.group.position).normalize();
                    bomb.userData.velocity.x = arcDirection.x * 12;
                    bomb.userData.velocity.z = arcDirection.z * 12;
                    
                    const bombUpdate = () => {
                        if (bomb.userData.life > 0) {
                            bomb.userData.life -= 0.016;
                            bomb.userData.velocity.y -= 0.5; 
                            bomb.position.add(bomb.userData.velocity.clone().multiplyScalar(0.016));
                            if (bomb.position.y <= 0.5) {
                                if(window.flux.explode) window.flux.explode(bomb.position);
                                this.scene.remove(bomb);
                                return;
                            }
                            requestAnimationFrame(bombUpdate);
                        } else {
                            if(window.flux.explode) window.flux.explode(bomb.position);
                            this.scene.remove(bomb);
                        }
                    };
                    bombUpdate();
                }
            }, i * 300);
        }
    }

    laserSight(targetPos) {
        const startPos = this.group.position.clone();
        const direction = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
        const endPos = startPos.clone().add(direction.multiplyScalar(50));
        if (window.flux && window.flux.spawnTrail) window.flux.spawnTrail(startPos, endPos);
    }

    supportBeam() {
        if (window.flux && window.flux.enemies) {
            window.flux.enemies.forEach(enemyGroup => {
                if (enemyGroup !== this.group && !enemyGroup.userData.isDead && enemyGroup.userData.hp < enemyGroup.userData.maxHp) {
                    if (this.group.position.distanceTo(enemyGroup.position) < 15) {
                         if (window.flux.spawnTrail) window.flux.spawnTrail(this.group.position, enemyGroup.position);
                    }
                }
            });
        }
    }

    muzzleFlash(color = 0xffffff) {
        const flashGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const flashMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const flash = new THREE.Mesh(flashGeo, flashMat);
        flash.position.copy(this.group.position);
        this.scene.add(flash);
        let scale = 1.0;
        const animateFlash = () => {
            scale += 0.2;
            flash.scale.set(scale, scale, scale);
            flashMat.opacity -= 0.1;
            if (flashMat.opacity > 0) requestAnimationFrame(animateFlash);
            else this.scene.remove(flash);
        };
        animateFlash();
    }

    updateRotation(player) {
        // Use static vectors
        let targetPos;
        if (this.state === 'PATROLLING' && this.patrolPoints.length > 0) {
            targetPos = this.patrolPoints[this.currentPatrolIndex];
        } else {
            targetPos = player.mesh.position;
        }
        
        _dVec1.subVectors(targetPos, this.group.position);
        _dVec1.y = 0;
        
        if (_dVec1.lengthSq() > 0.01) {
            _dVec1.normalize();
            _dQuat.setFromUnitVectors(_dVec2.set(0, 0, 1), _dVec1);
            this.group.quaternion.slerp(_dQuat, 0.1);
        }
    }

    updateVisuals(dt) {
        if (this.damageFlashTimer > 0) {
            const flashIntensity = this.damageFlashTimer * 5;
            this.group.traverse(child => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(0xff0000).multiplyScalar(flashIntensity);
                }
            });
        }
        
        // SCYTHER ANIMATION
        if (this.type === 'scyther') {
            // Find the asset group (it's the first child usually)
            const mesh = this.group.children.find(c => c.userData && c.userData.wings);
            if (mesh) {
                // Wing Buzz
                const buzz = Math.sin(Date.now() * 0.5) * 0.5;
                if (mesh.userData.wings) {
                    mesh.userData.wings[0].rotation.z = -0.5 + buzz;
                    mesh.userData.wings[1].rotation.z = 0.5 - buzz;
                }
                
                // Tilt forward when running
                const speed = this.group.userData.velocity.length();
                const targetTilt = Math.min(0.8, speed * 0.05);
                mesh.rotation.x = targetTilt;
            }
        }
        
        // STAGGER SHAKE
        if (this.staggerTimer > 0) {
            this.group.position.x += (Math.random() - 0.5) * 0.2;
            this.group.position.z += (Math.random() - 0.5) * 0.2;
        } else {
            this.group.position.y += Math.sin(Date.now() * 0.005) * 0.02;
        }
    }

    updateHealthBar() {
        if (!this.healthBar) return;
        const pct = this.group.userData.hp / this.maxHp;
        this.healthBar.scale.x = Math.max(0, pct);
        
        // Update Shield Bar
        if (this.shieldBar && this.config.maxShield > 0) {
            const shieldPct = this.group.userData.shieldHp / this.config.maxShield;
            this.shieldBar.scale.x = Math.max(0, shieldPct);
        }
        
        if (window.camera) {
            this.healthBar.lookAt(window.camera.position);
            this.healthBarBg.lookAt(window.camera.position);
            if (this.shieldBar) this.shieldBar.lookAt(window.camera.position);
        }
    }

    handleDeath() {
        if (this.group.userData.isDead) return;
        this.group.userData.isDead = true;
        
        // Trigger Spectacle
        if (window.flux && window.flux.killEnemy) {
            window.flux.killEnemy(this.group);
        } else {
            // Fallback
            this.group.visible = false;
            this.group.position.y = -500;
        }
    }
    
    // Patrol generators
    generateStandardPatrol() {
        const points = [];
        const basePos = this.group.position.clone();
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            points.push(new THREE.Vector3(basePos.x + Math.cos(angle) * 10, basePos.y + Math.random() * 3, basePos.z + Math.sin(angle) * 10));
        }
        return points;
    }
    generateSniperPositions() {
        const basePos = this.group.position.clone();
        return [
            new THREE.Vector3(basePos.x + 8, 12, basePos.z),
            new THREE.Vector3(basePos.x - 8, 15, basePos.z + 5),
            new THREE.Vector3(basePos.x + 5, 10, basePos.z - 8)
        ];
    }
    generateAssaultPattern() {
        const points = [];
        const basePos = this.group.position.clone();
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            points.push(new THREE.Vector3(basePos.x + Math.cos(angle) * 6, basePos.y + 3, basePos.z + Math.sin(angle) * 6));
        }
        return points;
    }
    generateSupportPositions() {
        const basePos = this.group.position.clone();
        return [
            new THREE.Vector3(basePos.x + 6, 8, basePos.z + 6),
            new THREE.Vector3(basePos.x - 6, 7, basePos.z - 6)
        ];
    }
    generateBomberPath() {
        const points = [];
        const basePos = this.group.position.clone();
        for (let i = 0; i < 4; i++) {
            points.push(new THREE.Vector3(basePos.x + (i - 2) * 8, 20, basePos.z + (i % 2) * 10 - 5));
        }
        return points;
    }
    generateBossPath() {
        const points = [];
        // Boss moves in a large figure 8
        for (let i = 0; i < 8; i++) {
            const t = (i / 8) * Math.PI * 2;
            points.push(new THREE.Vector3(Math.sin(t) * 20, 15, Math.sin(t * 2) * 10));
        }
        return points;
    }
    
    setPosition(position) {
        this.group.position.copy(position);
        this.targetPosition.copy(position);
    }
}</script>
    <script>/**
 * ANUBIS BOSS CLASS
 * Sleek, Fast, Stronger than player.
 * Implements cinematic entrance and high-speed combat.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes in update loops.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _bVec1 = new THREE.Vector3();
const _bVec2 = new THREE.Vector3();
const _bVec3 = new THREE.Vector3();
const _bQuat = new THREE.Quaternion();
const _bUp = new THREE.Vector3(0, 1, 0);
const _bFwd = new THREE.Vector3(0, 0, 1);

class AnubisBoss {
    constructor(scene, position = new THREE.Vector3()) {
        this.scene = scene;
        this.group = new THREE.Group();
        
        // Stats
        this.maxHp = 5000; // Tanky
        this.speed = 35; // Faster than player (24)
        this.phase = 1;
        
        // Initialize UserData
        this.group.userData = {
            type: 'enemy',
            enemyType: 'anubis',
            hp: this.maxHp,
            maxHp: this.maxHp,
            velocity: new THREE.Vector3(),
            isDead: false,
            controller: this,
            onGround: false,
            springs: { 
                scale: { pos: 1, vel: 0, target: 1, k: 200, d: 15 },
                tiltX: { pos: 0, vel: 0, target: 0, k: 150, d: 12 },
                tiltZ: { pos: 0, vel: 0, target: 0, k: 150, d: 12 }
            }
        };

        this.state = 'ENTRANCE'; // Start with cinematic
        this.stateTimer = 0;
        this.entrancePhase = 0;
        
        this.initMesh();
        this.group.position.copy(position);
        
        // Animation vars
        this.wingFlapSpeed = 5.0;
        this.hoverTime = 0;
        
        // Combat vars
        this.attackType = 'NONE';
        this.subAttackType = 'NONE';
        this.funnelAttackTimer = 0;
    }
    
    initMesh() {
        if (typeof AssetFactory !== 'undefined') {
            const mesh = AssetFactory.createAnubisBoss();
            mesh.scale.set(2.5, 2.5, 2.5); // Imposing but sleek
            this.group.add(mesh);
            this.mesh = mesh; // Reference for animation
        } else {
            // Fallback
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 3, 1), new THREE.MeshBasicMaterial({color: 0x000000}));
            this.group.add(mesh);
        }
        
        // Health Bar
        this.initHealthBar();
    }
    
    initHealthBar() {
        const barWidth = 4.0;
        const barHeight = 0.3;
        
        this.healthBarBg = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth, barHeight),
            new THREE.MeshBasicMaterial({ color: 0x000000, depthTest: false })
        );
        this.healthBarBg.position.y = 4.5;
        
        this.healthBar = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth - 0.05, barHeight - 0.05),
            new THREE.MeshBasicMaterial({ color: 0xffd700, depthTest: false }) // Gold bar
        );
        this.healthBar.position.y = 4.5;
        this.healthBar.position.z = 0.01;
        
        this.group.add(this.healthBarBg);
        this.group.add(this.healthBar);
    }
    
    update(dt, player) {
        if (this.group.userData.hp <= 0 && !this.group.userData.isDead) {
            this.handleDeath();
            return;
        }
        if (this.group.userData.isDead) return;
        
        // Update Shader Time
        if (this.mesh && this.mesh.userData.matFlow) {
            this.mesh.userData.matFlow.uniforms.uTime.value += dt;
        }
        
        // Phase Transition
        if (this.phase === 1 && this.group.userData.hp < this.maxHp * 0.5) {
            this.enterPhase3();
        }
        
        // State Machine
        switch(this.state) {
            case 'ENTRANCE': this.updateEntrance(dt, player); break;
            case 'IDLE': this.updateIdle(dt, player); break;
            case 'CHASE': this.updateChase(dt, player); break;
            case 'ATTACK': this.updateAttack(dt, player); break;
            case 'JUDGMENT': this.updateJudgment(dt, player); break;
            case 'VOID_SLASH': this.updateVoidSlash(dt, player); break;
        }
        
        // Physics & Visuals
        this.updatePhysics(dt);
        this.updateAnimation(dt);
        this.updateFunnels(dt, player);
        this.updateHealthBar();
    }
    
    enterPhase3() {
        this.phase = 2;
        if (window.flux.spawnTechText) window.flux.spawnTechText("PHASE 2: LIMITER RELEASED");
        if (window.flux.shake) window.flux.shake(1.5);
        if (window.flux.audio) window.flux.audio.play('charge');
        this.speed = 55; // Much Faster
        
        // Change colors to Red
        if (this.mesh && this.mesh.userData.matFlow) {
            this.mesh.userData.matFlow.uniforms.uColor.value.setHex(0xff0000);
        }
        this.healthBar.material.color.setHex(0xff0000);
    }
    
    updateFunnels(dt, player) {
        if (!this.mesh || !this.mesh.userData.funnels) return;
        
        const funnels = this.mesh.userData.funnels;
        const funnelGroup = this.mesh.userData.funnelGroup;
        
        // Rotate group
        if (this.phase === 2) {
            funnelGroup.rotation.z += dt * 5.0; // Fast spin
        } else {
            funnelGroup.rotation.z += dt * 1.0;
        }
        
        // Funnel individual behavior
        funnels.forEach(f => {
            if (this.state === 'JUDGMENT') {
                // Expand outward
                // Reuse _bVec1 for target pos
                _bVec1.copy(f.userData.basePos).multiplyScalar(5.0);
                f.position.lerp(_bVec1, dt * 2.0);
                f.lookAt(player.mesh.position);
            } else {
                // Return to base
                f.position.lerp(f.userData.basePos, dt * 5.0);
                f.rotation.set(0,0,0);
            }
        });
    }
    
    updateEntrance(dt, player) {
        this.stateTimer += dt;
        
        // Phase 0: Initial Spawn (Hidden/High up)
        if (this.entrancePhase === 0) {
            if (window.flux && window.flux.spawnTechText) {
                window.flux.spawnTechText("WARNING: CLASS S THREAT");
            }
            // Hijack Camera
            if (window.flux.setCameraFocus) {
                window.flux.setCameraFocus(this.group.position, 1.0);
            }
            this.entrancePhase = 1;
            this.stateTimer = 0;
        }
        
        // Phase 1: Descend slowly with flair
        if (this.entrancePhase === 1) {
            this.group.position.y -= 15.0 * dt; // Slam down faster
            if (this.group.position.y <= 5.0) {
                this.entrancePhase = 2;
                this.stateTimer = 0;
                if (window.flux.shake) window.flux.shake(2.0);
                if (window.flux.audio) window.flux.audio.play('massive_impact');
                // Shockwave on landing
                if (window.flux.spawnShockwave) window.flux.spawnShockwave(this.group.position);
                if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(this.group.position);
            }
        }
        
        // Phase 2: Roar / Pose
        if (this.entrancePhase === 2) {
            if (this.stateTimer > 2.0) {
                this.state = 'CHASE';
                if (window.flux.spawnTechText) window.flux.spawnTechText("TARGET ACQUIRED");
                // Release Camera
                if (window.flux.clearCameraFocus) window.flux.clearCameraFocus();
            }
        }
    }
    
    updateIdle(dt, player) {
        this.state = 'CHASE'; // Aggressive
    }
    
    updateChase(dt, player) {
        const dist = this.group.position.distanceTo(player.mesh.position);
        
        // Teleport logic if far away
        if (dist > 40 && Math.random() > 0.98) {
            this.teleportNear(player);
            return;
        }
        
        // Move towards player
        // _bVec1 = dir
        _bVec1.subVectors(player.mesh.position, this.group.position).normalize();
        this.group.userData.velocity.add(_bVec1.multiplyScalar(this.speed * 2 * dt));
        
        // Face player
        _bQuat.setFromUnitVectors(_bFwd, _bVec1);
        this.group.quaternion.slerp(_bQuat, 0.1);
        
        // Attack Range logic
        if (dist < 8.0) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
            this.attackType = 'MELEE';
        } else if (this.phase === 2 && dist > 15.0 && Math.random() > 0.98) {
            // Phase 2 Special Attacks
            const rand = Math.random();
            if (rand > 0.6) {
                this.state = 'JUDGMENT';
                this.stateTimer = 0;
            } else if (rand > 0.3) {
                this.state = 'VOID_SLASH';
                this.stateTimer = 0;
            } else {
                this.state = 'ATTACK';
                this.attackType = 'BEAM';
                this.stateTimer = 0;
            }
        }
    }
    
    updateJudgment(dt, player) {
        this.stateTimer += dt;
        
        // 1. Rise Up
        if (this.stateTimer < 1.0) {
            this.group.position.y += 10 * dt;
            this.group.userData.velocity.set(0,0,0);
            if (this.stateTimer < 0.1 && window.flux.spawnTechText) window.flux.spawnTechText("JUDGMENT PROTOCOL");
        } 
        // 2. Fire Barrage
        else if (this.stateTimer < 3.0) {
            if (Math.random() > 0.8) {
                // Spawn laser from above player
                // Reuse _bVec1 for targetPos
                _bVec1.copy(player.mesh.position).add(new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10));
                if (window.flux.spawnJudgmentLaser) window.flux.spawnJudgmentLaser(_bVec1);
                if (window.flux.audio) window.flux.audio.play('laser_fire');
            }
        } 
        // 3. Recover
        else {
            this.state = 'CHASE';
        }
    }
    
    updateVoidSlash(dt, player) {
        this.stateTimer += dt;
        
        // 1. Vanish
        if (this.stateTimer < 0.5) {
            this.group.visible = false; // Vanish
            if (this.stateTimer < 0.1) {
                if (window.flux.audio) window.flux.audio.play('teleport');
                if (window.flux.spawnParticles) window.flux.spawnParticles(this.group.position, 20, 0x000000, 10);
            }
        }
        // 2. Reappear Behind
        else if (this.stateTimer < 1.0) {
            if (!this.group.visible) {
                this.group.visible = true;
                // Teleport behind
                // Reuse _bVec1 for backDir
                _bVec1.set(Math.sin(player.mesh.rotation.y), 0, Math.cos(player.mesh.rotation.y)).multiplyScalar(-5);
                
                // Reuse _bVec2 for targetPos
                _bVec2.copy(player.mesh.position).add(_bVec1);
                _bVec2.y = Math.max(2.0, _bVec2.y);
                
                this.group.position.copy(_bVec2);
                this.group.lookAt(player.mesh.position);
                
                if (window.flux.spawnTechText) window.flux.spawnTechText("VOID SLASH");
                if (window.flux.audio) window.flux.audio.play('charge');
            }
        }
        // 3. SLASH
        else if (this.stateTimer < 1.2) {
            if (this.stateTimer < 1.05) {
                // Spawn Slash VFX
                if (window.flux.spawnVoidSlash) window.flux.spawnVoidSlash(this.group.position, this.group.quaternion, 10.0);
                if (window.flux.audio) window.flux.audio.play('slash_heavy');
                
                // Hit Check (Wide)
                if (this.group.position.distanceTo(player.mesh.position) < 10.0) {
                    player.takeDamage(60);
                    if (window.flux.shake) window.flux.shake(1.0);
                }
            }
        }
        else {
            this.state = 'CHASE';
        }
    }
    
    updateAttack(dt, player) {
        this.stateTimer += dt;
        
        // Attack Pattern Randomizer for Melee
        if (this.stateTimer === dt && this.attackType === 'MELEE') { 
             this.subAttackType = Math.random() > 0.5 ? 'SPIN' : 'LUNGE';
             if (window.flux.audio) window.flux.audio.play('charge');
        }
        
        if (this.attackType === 'BEAM') {
            // Wing Beam Attack (Phase 2)
            if (this.stateTimer < 1.0) {
                // Charge
                this.group.userData.velocity.multiplyScalar(0.1); // Stop
                if (Math.random() > 0.8 && window.flux.spawnChargeParticles) {
                    window.flux.spawnChargeParticles(this.group.position);
                }
            } else if (this.stateTimer < 1.1) {
                // Fire
                if (window.flux.spawnAnubisBeam) {
                    window.flux.spawnAnubisBeam(this.group.position, player.mesh.position);
                }
                if (window.flux.audio) window.flux.audio.play('laser_fire');
            } else if (this.stateTimer > 2.0) {
                this.state = 'CHASE';
            }
            
        } else if (this.subAttackType === 'SPIN') {
            // Staff Spin Attack
            if (this.mesh && this.mesh.userData.staff) {
                this.mesh.userData.staff.rotation.z += 20 * dt; // Spin fast
            }
            
            if (this.stateTimer > 1.0 && this.stateTimer < 1.2) {
                // Damage tick area
                if (this.group.position.distanceTo(player.mesh.position) < 10.0) {
                    player.takeDamage(25);
                    if (window.flux.spawnParticles) window.flux.spawnParticles(player.mesh.position, 10, 0xff0000, 10);
                    if (window.flux.shake) window.flux.shake(0.3);
                }
            }
            
            if (this.stateTimer > 2.0) this.state = 'CHASE';
            
        } else {
            // Lunge
            if (this.stateTimer < 0.5) {
                // Wind up
                this.group.userData.velocity.multiplyScalar(0.5);
            } else if (this.stateTimer < 1.0) {
                // Dash
                // Reuse _bVec1 for dir
                _bVec1.set(0, 0, 1).applyQuaternion(this.group.quaternion);
                this.group.userData.velocity.add(_bVec1.multiplyScalar(150 * dt));
                
                // Hit check
                if (this.group.position.distanceTo(player.mesh.position) < 5.0) {
                    player.takeDamage(40);
                    if (window.flux.shake) window.flux.shake(0.8);
                    if (window.flux.audio) window.flux.audio.play('massive_impact');
                    this.state = 'CHASE'; // Hit and run
                }
            } else {
                this.state = 'CHASE';
            }
        }
    }
    
    teleportNear(player) {
        if (window.flux.spawnParticles) window.flux.spawnParticles(this.group.position, 20, 0x000000, 10);
        if (window.flux.audio) window.flux.audio.play('teleport');
        
        // Flank position
        // Reuse _bVec1 for offset
        _bVec1.set((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10);
        
        // Reuse _bVec2 for target
        _bVec2.copy(player.mesh.position).add(_bVec1);
        _bVec2.y = Math.max(2.0, _bVec2.y);
        
        this.group.position.copy(_bVec2);
        this.group.lookAt(player.mesh.position);
        
        if (window.flux.spawnParticles) window.flux.spawnParticles(this.group.position, 20, 0xffd700, 10);
    }
    
    updatePhysics(dt) {
        const vel = this.group.userData.velocity;
        vel.multiplyScalar(0.9); // Drag
        // Reuse _bVec1 for move delta
        _bVec1.copy(vel).multiplyScalar(dt);
        this.group.position.add(_bVec1);
        
        // Float logic
        if (this.group.position.y < 2.0) {
            this.group.position.y += (2.0 - this.group.position.y) * 5 * dt;
        }
    }
    
    updateAnimation(dt) {
        this.hoverTime += dt;
        
        // Bobbing
        this.mesh.position.y = Math.sin(this.hoverTime * 2.0) * 0.2;
        
        // Wing Animation
        if (this.mesh && this.mesh.userData.wings) {
            const wings = this.mesh.userData.wings;
            // Faster flap when attacking
            const speed = (this.state === 'ATTACK' || this.state === 'CHASE') ? 15.0 : 5.0;
            const flap = Math.sin(this.hoverTime * speed) * 0.2;
            
            // Upper wings
            wings[0].rotation.z = 0.5 + flap;
            wings[1].rotation.z = -0.5 - flap;
            
            // Lower wings
            wings[2].rotation.z = 2.5 + (flap * 0.5);
            wings[3].rotation.z = -2.5 - (flap * 0.5);
        }
        
        // Halo Animation
        if (this.mesh && this.mesh.userData.halo) {
            this.mesh.userData.halo.rotation.z -= dt * (this.phase === 2 ? 5.0 : 1.0);
        }
    }
    
    updateHealthBar() {
        if (!this.healthBar) return;
        const pct = this.group.userData.hp / this.maxHp;
        this.healthBar.scale.x = Math.max(0, pct);
        if (window.camera) {
            this.healthBar.lookAt(window.camera.position);
            this.healthBarBg.lookAt(window.camera.position);
        }
    }
    
    handleDeath() {
        this.group.userData.isDead = true;
        if (window.flux.killEnemy) window.flux.killEnemy(this.group);
        if (window.flux.spawnTechText) window.flux.spawnTechText("ANUBIS DEFEATED");
        if (window.flux.clearCameraFocus) window.flux.clearCameraFocus();
    }
}</script>
    
    <!-- NEW: Hunter Mesh Generator -->
    <script>/**
 * HUNTER MESH GENERATOR
 * High-Fidelity Quadruped Mech Model ("Wolf Type").
 * Uses procedural geometry and custom shaders for a "Herculean" aesthetic.
 * UPDATED: Adjusted Thruster orientation to point backwards.
 */

const HUNTER_SHADERS = {
    armorVert: `
        #include <common>
        #include <logdepthbuf_pars_vertex>
        
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vNormal;
        
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
            #include <logdepthbuf_vertex>
        }
    `,
    armorFrag: `
        #include <common>
        #include <logdepthbuf_pars_fragment>
        
        uniform sampler2D tMatCap;
        uniform float uTime;
        uniform vec3 uColor;
        uniform vec3 uGlowColor;
        
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vNormal;
        
        void main() {
            #include <logdepthbuf_fragment>
            
            vec3 viewDir = normalize(vViewPosition);
            vec3 normal = normalize(vNormal);
            
            // MatCap approximation
            vec3 x = normalize(vec3(viewDir.z, 0.0, -viewDir.x));
            vec3 y = cross(viewDir, x);
            vec2 uv = vec2(dot(x, normal), dot(y, normal)) * 0.495 + 0.5;
            vec3 matcap = texture2D(tMatCap, uv).rgb;
            
            float fresnel = pow(1.0 - max(0.0, dot(viewDir, normal)), 3.0);
            
            vec3 baseColor = mix(uColor, matcap, 0.5);
            vec3 rim = uGlowColor * fresnel * 2.0;
            
            // Pulse effect
            float pulse = 0.8 + 0.2 * sin(uTime * 3.0 + vUv.y * 10.0);
            
            gl_FragColor = vec4((baseColor + rim) * pulse, 1.0);
        }
    `,
    shieldVert: `
        varying vec3 vNormal;
        varying vec2 vUv;
        void main() {
            vNormal = normalize(normalMatrix * normal);
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    shieldFrag: `
        uniform float uTime;
        uniform float uHit;
        varying vec3 vNormal;
        varying vec2 vUv;
        
        void main() {
            float alpha = 0.0;
            
            // Hexagon pattern
            vec2 r = vUv * 10.0;
            vec2 r2 = fract(r);
            float hex = max(abs(r2.x - 0.5), abs(r2.y - 0.5));
            
            if (uHit > 0.0) {
                alpha = uHit * (0.2 + 0.8 * step(0.45, hex));
            }
            
            gl_FragColor = vec4(0.0, 1.0, 1.0, alpha);
        }
    `
};

class HunterMesh {
    static build(controller) {
        const group = controller.group;
        
        // --- MATERIALS ---
        const matCap = TextureGen.createMatCap(256, '#444455', '#111122');
        
        controller.matArmor = new THREE.ShaderMaterial({
            uniforms: {
                tMatCap: { value: matCap },
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x222233) }, // Dark Blue-Grey
                uGlowColor: { value: new THREE.Color(0xff0055) } // Red Rim
            },
            vertexShader: HUNTER_SHADERS.armorVert,
            fragmentShader: HUNTER_SHADERS.armorFrag
        });
        
        controller.matJoint = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.7,
            metalness: 0.8
        });
        
        controller.matEye = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        
        controller.matShield = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uHit: { value: 0.0 }
            },
            vertexShader: HUNTER_SHADERS.shieldVert,
            fragmentShader: HUNTER_SHADERS.shieldFrag,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });

        // --- BODY ---
        const bodyGroup = new THREE.Group();
        group.add(bodyGroup);
        controller.bodyGroup = bodyGroup;

        // Torso (Ribcage)
        const torsoGeo = new THREE.CylinderGeometry(0.3, 0.5, 1.2, 6);
        torsoGeo.rotateX(Math.PI/2);
        const torso = new THREE.Mesh(torsoGeo, controller.matArmor);
        bodyGroup.add(torso);
        
        // Rear Body (Hips)
        const hipsGeo = new THREE.BoxGeometry(0.7, 0.6, 0.8);
        const hips = new THREE.Mesh(hipsGeo, controller.matArmor);
        hips.position.z = -0.8;
        bodyGroup.add(hips);
        
        // Spine Connector
        const spine = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.6), controller.matJoint);
        spine.rotation.x = Math.PI/2;
        spine.position.z = -0.4;
        bodyGroup.add(spine);

        // --- HEAD ---
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 0.3, 0.7);
        bodyGroup.add(headGroup);
        controller.headGroup = headGroup;
        
        // Cranium
        const headGeo = new THREE.BoxGeometry(0.4, 0.35, 0.5);
        const head = new THREE.Mesh(headGeo, controller.matArmor);
        headGroup.add(head);
        
        // Snout
        const snoutGeo = new THREE.ConeGeometry(0.15, 0.5, 4);
        snoutGeo.rotateX(Math.PI/2);
        const snout = new THREE.Mesh(snoutGeo, controller.matArmor);
        snout.position.z = 0.45;
        headGroup.add(snout);
        
        // Ears
        const earGeo = new THREE.ConeGeometry(0.08, 0.3, 4);
        const earL = new THREE.Mesh(earGeo, controller.matArmor);
        earL.position.set(0.15, 0.25, -0.1);
        earL.rotation.z = -0.3;
        earL.rotation.x = -0.2;
        headGroup.add(earL);
        
        const earR = new THREE.Mesh(earGeo, controller.matArmor);
        earR.position.set(-0.15, 0.25, -0.1);
        earR.rotation.z = 0.3;
        earR.rotation.x = -0.2;
        headGroup.add(earR);
        
        // Eyes
        const eyeGeo = new THREE.BoxGeometry(0.1, 0.05, 0.02);
        const eyeL = new THREE.Mesh(eyeGeo, controller.matEye);
        eyeL.position.set(0.12, 0.05, 0.25);
        eyeL.rotation.y = 0.2;
        headGroup.add(eyeL);
        
        const eyeR = new THREE.Mesh(eyeGeo, controller.matEye);
        eyeR.position.set(-0.12, 0.05, 0.25);
        eyeR.rotation.y = -0.2;
        headGroup.add(eyeR);

        // --- LEGS ---
        controller.limbs = [];
        controller.thrusters = []; // Store thruster references
        
        // Front Left
        this.createLeg(controller, bodyGroup, 0.4, 0.0, 0.5, 1);
        // Front Right
        this.createLeg(controller, bodyGroup, -0.4, 0.0, 0.5, -1);
        // Rear Left (With Thruster)
        this.createLeg(controller, bodyGroup, 0.4, 0.1, -0.8, 1, true);
        // Rear Right (With Thruster)
        this.createLeg(controller, bodyGroup, -0.4, 0.1, -0.8, -1, true);
        
        // --- TAIL ---
        const tailGroup = new THREE.Group();
        tailGroup.position.set(0, 0.2, -1.2);
        bodyGroup.add(tailGroup);
        controller.tail = tailGroup;
        
        const tailGeo = new THREE.CylinderGeometry(0.08, 0.02, 1.2, 5);
        tailGeo.rotateX(Math.PI/2); // Point back
        tailGeo.translate(0, 0, -0.6); // Pivot at base
        const tail = new THREE.Mesh(tailGeo, controller.matArmor);
        tailGroup.add(tail);
        
        // --- SHIELD ---
        const shieldGeo = new THREE.SphereGeometry(1.2, 16, 16, 0, Math.PI*2, 0, Math.PI*0.5);
        const shield = new THREE.Mesh(shieldGeo, controller.matShield);
        shield.rotation.x = -Math.PI/2;
        shield.position.z = 0.8;
        shield.scale.set(1, 0.6, 1);
        shield.visible = false;
        bodyGroup.add(shield);
        controller.shieldMesh = shield;
    }
    
    static createLeg(controller, parent, x, y, z, side, isRear = false) {
        const hip = new THREE.Group();
        hip.position.set(x, y, z);
        parent.add(hip);
        
        // Shoulder/Hip Joint
        const joint = new THREE.Mesh(new THREE.SphereGeometry(0.2), controller.matJoint);
        hip.add(joint);
        
        // Add Thruster to Rear Hips
        if (isRear) {
            const thrusterGeo = new THREE.ConeGeometry(0.15, 0.5, 8);
            // FIXED: Rotate to point backwards (-Z)
            // Cone default points +Y. 
            // Rotate X by -PI/2 points it to +Z.
            // Rotate X by PI/2 points it to -Z (Backwards).
            thrusterGeo.rotateX(Math.PI * 0.5); 
            
            const thruster = new THREE.Mesh(thrusterGeo, controller.matArmor);
            thruster.position.set(side * 0.1, 0.2, -0.1);
            hip.add(thruster);
            
            // Add Plume
            if (typeof ThrusterPlume !== 'undefined') {
                // Attach plume to thruster
                // ThrusterPlume points down -Y by default.
                // We want it to point backwards (-Z).
                // So we rotate the mount X by PI/2.
                
                const mount = new THREE.Group();
                mount.position.copy(thruster.position);
                // Align mount with thruster direction (Backwards)
                mount.rotation.x = Math.PI * 0.5; 
                mount.translateY(-0.25); // Move to base of cone
                hip.add(mount);
                
                const plumeObj = new ThrusterPlume(mount, 0xffaa00);
                controller.thrusters.push(plumeObj);
            }
        }
        
        // Upper Leg
        const upperLen = 0.6;
        const upperGeo = new THREE.BoxGeometry(0.15, upperLen, 0.15);
        upperGeo.translate(0, -upperLen/2, 0);
        const upper = new THREE.Mesh(upperGeo, controller.matArmor);
        // Initial Pose
        upper.rotation.x = isRear ? 0.5 : -0.3;
        upper.rotation.z = side * 0.1;
        hip.add(upper);
        
        // Knee
        const knee = new THREE.Group();
        knee.position.y = -upperLen;
        upper.add(knee);
        
        const kneeJoint = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.2), controller.matJoint);
        kneeJoint.rotation.z = Math.PI/2;
        knee.add(kneeJoint);
        
        // Lower Leg
        const lowerLen = 0.7;
        const lowerGeo = new THREE.BoxGeometry(0.12, lowerLen, 0.12);
        lowerGeo.translate(0, -lowerLen/2, 0);
        const lower = new THREE.Mesh(lowerGeo, controller.matArmor);
        // Initial Pose
        lower.rotation.x = isRear ? -0.8 : 0.6;
        knee.add(lower);
        
        // Foot
        const foot = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.3), controller.matJoint);
        foot.position.y = -lowerLen;
        foot.position.z = 0.1;
        lower.add(foot);
        
        controller.limbs.push({ hip, upper, knee, lower, isRear, side });
    }
}</script>
    <script>/**
 * HUNTER ENEMY CLASS
 * Agile, wolf-like robot that flanks and charges.
 * STRICTLY GROUND-BASED with Complex IK for 4 legs.
 * Features a frontal shield that blocks attacks.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes in update loops.
 * OPTIMIZED: Implemented reset() for Object Pooling.
 * UPDATED: Added Kinetic Impact (Stagger) System.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _hVec1 = new THREE.Vector3();
const _hVec2 = new THREE.Vector3();
const _hVec3 = new THREE.Vector3();
const _hVec4 = new THREE.Vector3();
const _hVec5 = new THREE.Vector3();
const _hQuat = new THREE.Quaternion();
const _hUp = new THREE.Vector3(0, 1, 0);
const _hDown = new THREE.Vector3(0, -1, 0);
const _hFwd = new THREE.Vector3(0, 0, 1);

class HunterEnemy {
    constructor(scene, position = new THREE.Vector3()) {
        this.scene = scene;
        this.type = 'hunter'; // Explicit type
        this.group = new THREE.Group();
        
        // Stats
        this.maxHp = 350; 
        this.speed = 10; // SLOWED DOWN
        this.boostSpeed = 35; // Fast burst
        this.turnSpeed = 6.0;
        
        // Initialize UserData
        this.group.userData = {
            type: 'enemy',
            enemyType: 'hunter',
            hp: this.maxHp,
            maxHp: this.maxHp,
            velocity: new THREE.Vector3(),
            isDead: false,
            controller: this,
            onGround: true,
            springs: { 
                scale: { pos: 1, vel: 0, target: 1, k: 200, d: 15 },
                tiltX: { pos: 0, vel: 0, target: 0, k: 150, d: 12 },
                tiltZ: { pos: 0, vel: 0, target: 0, k: 150, d: 12 }
            }
        };

        this.state = 'SPAWN'; 
        this.stateTimer = 0;
        this.chargeCooldown = 3.0;
        this.isBoosting = false;
        this.staggerTimer = 0; // NEW: Stagger state
        
        // Visual Components
        this.bodyGroup = null;
        this.limbs = []; // Populated by Mesh Builder
        this.thrusters = []; // Populated by Mesh Builder
        this.shieldMesh = null;
        this.matArmor = null;
        this.matShield = null;
        
        this.initMesh();
        
        // Ensure we start on ground
        this.group.position.copy(position);
        
        // --- IK SYSTEM SETUP ---
        this.ikSolver = new IKSystem();
        
        // Foot Targets (World Space)
        this.footTargets = [
            new THREE.Vector3(), // FL
            new THREE.Vector3(), // FR
            new THREE.Vector3(), // BL
            new THREE.Vector3()  // BR
        ];
        
        // Pole Targets (Knee direction)
        this.poleTargets = [
            new THREE.Vector3(), new THREE.Vector3(),
            new THREE.Vector3(), new THREE.Vector3()
        ];
        
        // Raycasters
        this.raycaster = new THREE.Raycaster();
        
        // Gait
        this.gaitTime = 0;
        this.stepHeight = 0.5;
        this.strideLength = 1.5;
        
        // Bone Lengths (Must match HunterMesh)
        this.upperLen = 0.6;
        this.lowerLen = 0.7;
        
        // Initial Foot Placement
        this.resetFeet();
    }
    
    // NEW: Reset method for Pooling
    reset(position) {
        this.group.position.copy(position);
        this.group.visible = true;
        this.group.rotation.set(0, 0, 0);
        
        // Reset Stats
        this.group.userData.hp = this.maxHp;
        this.group.userData.isDead = false;
        this.group.userData.velocity.set(0, 0, 0);
        
        // Reset State
        this.state = 'SPAWN';
        this.stateTimer = 0;
        this.chargeCooldown = 3.0;
        this.isBoosting = false;
        this.staggerTimer = 0;
        
        // Reset Feet
        this.resetFeet();
        
        // Reset Visuals
        this.updateHealthBar();
        if (this.shieldMesh) this.shieldMesh.visible = false;
        
        // Reset Springs
        this.group.userData.springs.scale.pos = 1;
        this.group.userData.springs.scale.vel = 0;
    }
    
    initMesh() {
        if (typeof HunterMesh !== 'undefined') {
            HunterMesh.build(this);
        } else {
            // Fallback
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), new THREE.MeshStandardMaterial({color: 0x111111}));
            this.group.add(mesh);
        }
        
        // Health Bar
        this.initHealthBar();
    }
    
    initHealthBar() {
        const barWidth = 1.5;
        const barHeight = 0.15;
        
        this.healthBarBg = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth, barHeight),
            new THREE.MeshBasicMaterial({ color: 0x000000, depthTest: false })
        );
        this.healthBarBg.position.y = 2.5;
        
        this.healthBar = new THREE.Mesh(
            new THREE.PlaneGeometry(barWidth - 0.05, barHeight - 0.05),
            new THREE.MeshBasicMaterial({ color: 0xff0055, depthTest: false }) 
        );
        this.healthBar.position.y = 2.5;
        this.healthBar.position.z = 0.01;
        
        this.group.add(this.healthBarBg);
        this.group.add(this.healthBar);
    }
    
    resetFeet() {
        // Initialize feet relative to body
        const offsets = [
            new THREE.Vector3(0.4, 0, 0.5),  // FL
            new THREE.Vector3(-0.4, 0, 0.5), // FR
            new THREE.Vector3(0.4, 0, -0.8), // BL
            new THREE.Vector3(-0.4, 0, -0.8) // BR
        ];
        
        for(let i=0; i<4; i++) {
            this.footTargets[i].copy(this.group.position).add(offsets[i]);
            this.footTargets[i].y = 0; // Floor
        }
    }
    
    // NEW: Stagger Logic
    stagger(power) {
        // Hunter has high poise (50)
        // Light attacks (20) won't stagger much
        // Heavy attacks (60) will break
        
        let duration = 0.2;
        if (power >= 50) {
            duration = 2.0; // Long break
            if (window.flux && window.flux.spawnTechText) {
                window.flux.spawnTechText("ARMOR BREAK");
            }
            if (window.flux.audio) window.flux.audio.play('massive_impact');
        }
        
        this.staggerTimer = duration;
        this.state = 'STAGGER';
        
        // Cancel Charge
        this.isBoosting = false;
        this.group.userData.velocity.set(0,0,0);
        
        // Visual Squash
        this.group.userData.springs.scale.vel = -30;
    }
    
    update(dt, player) {
        if (this.group.userData.hp <= 0 && !this.group.userData.isDead) {
            this.handleDeath();
            return;
        }
        if (this.group.userData.isDead) return;
        
        this.stateTimer += dt;
        this.chargeCooldown -= dt;
        
        // Update Shader Time
        if (this.matArmor) this.matArmor.uniforms.uTime.value += dt;
        if (this.matShield) this.matShield.uniforms.uTime.value += dt;
        
        // STAGGER LOGIC
        if (this.staggerTimer > 0) {
            this.staggerTimer -= dt;
            this.updatePhysics(dt); // Gravity still applies
            this.updateIK(dt); // Legs try to stand
            this.updateHealthBar();
            
            // Shake
            this.group.position.x += (Math.random() - 0.5) * 0.1;
            
            if (this.staggerTimer <= 0) {
                this.state = 'RECOVER';
                this.stateTimer = 0;
            }
            return;
        }
        
        // State Machine
        switch(this.state) {
            case 'SPAWN': this.updateSpawn(dt); break;
            case 'FLANK': this.updateFlank(dt, player); break;
            case 'CHARGE_PREP': this.updateChargePrep(dt, player); break;
            case 'DASH': this.updateDash(dt, player); break;
            case 'RECOVER': this.updateRecover(dt, player); break;
        }
        
        this.updatePhysics(dt);
        this.updateIK(dt); // Complex Leg Movement
        this.updateThrusters(dt); // Visuals
        this.updateShield(dt);
        this.updateHealthBar();
    }
    
    updateSpawn(dt) {
        // Drop from sky but snap to ground quickly
        if (this.stateTimer < 0.5) {
            this.group.userData.velocity.y = -20;
        } else {
            this.state = 'FLANK';
            this.stateTimer = 0;
        }
    }
    
    updateFlank(dt, player) {
        this.isBoosting = false;
        const dist = this.group.position.distanceTo(player.mesh.position);
        
        // Calculate flank position (Behind and to the side)
        // Reuse _hVec1 for pForward, _hVec2 for pRight
        _hVec1.set(0, 0, 1).applyQuaternion(player.mesh.quaternion);
        _hVec2.set(1, 0, 0).applyQuaternion(player.mesh.quaternion);
        
        // Alternate sides based on ID or timer
        const side = (Math.floor(Date.now() / 5000) % 2 === 0) ? 1 : -1;
        
        // _hVec3 = targetPos
        _hVec3.copy(player.mesh.position)
            .sub(_hVec1.multiplyScalar(10)) // Behind
            .add(_hVec2.multiplyScalar(side * 12)); // Side
            
        // _hVec4 = direction
        _hVec4.subVectors(_hVec3, this.group.position);
        _hVec4.y = 0;
        
        if (_hVec4.lengthSq() > 9.0) { // 3.0 * 3.0
            _hVec4.normalize();
            // Move at base speed (slow)
            this.group.userData.velocity.add(_hVec4.multiplyScalar(this.speed * dt));
            
            // Look at move dir
            _hQuat.setFromUnitVectors(_hFwd, _hVec4);
            this.group.quaternion.slerp(_hQuat, this.turnSpeed * dt);
        } else {
            // Reached flank position, look at player
            // _hVec5 = toPlayer
            _hVec5.subVectors(player.mesh.position, this.group.position).normalize();
            _hQuat.setFromUnitVectors(_hFwd, _hVec5);
            this.group.quaternion.slerp(_hQuat, this.turnSpeed * dt);
            
            if (this.chargeCooldown <= 0 && dist < 30) {
                this.state = 'CHARGE_PREP';
                this.stateTimer = 0;
                if (window.flux.audio) window.flux.audio.play('charge');
                if (window.flux.spawnChargeParticles) window.flux.spawnChargeParticles(this.group.position);
            }
        }
    }
    
    updateChargePrep(dt, player) {
        this.isBoosting = true; // Revving up
        // Face player aggressively
        _hVec1.subVectors(player.mesh.position, this.group.position).normalize();
        _hQuat.setFromUnitVectors(_hFwd, _hVec1);
        this.group.quaternion.slerp(_hQuat, 10.0 * dt);
        
        // Crouch visual
        this.group.userData.springs.scale.target = 0.8;
        this.group.userData.velocity.set(0,0,0); // Stop moving
        
        if (this.stateTimer > 1.0) { // Longer prep
            this.state = 'DASH';
            this.stateTimer = 0;
            this.dashDir = _hVec1.clone(); // Must clone here as state persists
            if (window.flux.audio) window.flux.audio.play('dash');
            if (window.flux.spawnParticles) window.flux.spawnParticles(this.group.position, 10, 0xff0000, 10);
        }
    }
    
    updateDash(dt, player) {
        this.isBoosting = true;
        // Move fast in straight line using Boost Speed
        this.group.userData.velocity.copy(this.dashDir).multiplyScalar(this.boostSpeed);
        
        // Hit Check
        const dist = this.group.position.distanceTo(player.mesh.position);
        if (dist < 3.5) {
            player.takeDamage(40);
            // Knockback
            player.velocity.add(this.dashDir.clone().multiplyScalar(40));
            player.isKnockedDown = true;
            
            if (window.flux.shake) window.flux.shake(1.0);
            if (window.flux.audio) window.flux.audio.play('massive_impact');
            this.state = 'RECOVER';
            this.stateTimer = 0;
            this.group.userData.velocity.multiplyScalar(-0.5); // Bounce back
        }
        
        if (this.stateTimer > 0.8) { // Dash duration
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }
    
    updateRecover(dt, player) {
        this.isBoosting = false;
        // INCREASED DAMPING: Slow down much faster (0.8 instead of 0.9)
        this.group.userData.velocity.multiplyScalar(0.8); 
        this.group.userData.springs.scale.target = 1.0;
        
        if (this.stateTimer > 2.0) { // Longer recovery
            this.state = 'FLANK';
            this.chargeCooldown = 4.0;
        }
    }
    
    updatePhysics(dt) {
        // 1. Apply Gravity
        this.group.userData.velocity.y -= 80 * dt;
        
        // 2. Move
        const vel = this.group.userData.velocity;
        
        // INCREASED FRICTION: Apply damping every frame to prevent "ice skating"
        // Only apply friction if on ground and not dashing
        if (this.state !== 'DASH' && this.group.position.y < 1.0) {
            vel.multiplyScalar(0.9); // 10% drag per frame
        }
        
        // Reuse _hVec1 for nextPos
        _hVec1.copy(this.group.position).addScaledVector(vel, dt);
        
        // 3. Ground Collision (Raycast)
        // Reuse _hVec2 for ray origin
        _hVec2.copy(_hVec1).add(_hUp.clone().multiplyScalar(2));
        this.raycaster.set(_hVec2, _hDown);
        
        let groundY = 0;
        let normal = _hUp;
        
        // Check against static world
        if (window.flux.staticGroup) {
            const intersects = this.raycaster.intersectObjects(window.flux.staticGroup.children, true);
            if (intersects.length > 0) {
                groundY = intersects[0].point.y;
                normal = intersects[0].face.normal;
            }
        }
        
        // 4. Terrain Following
        if (_hVec1.y < groundY + 1.2) { // 1.2 is hip height
            _hVec1.y = groundY + 1.2;
            vel.y = 0;
            
            // Align body to terrain normal
            _hVec3.set(0, 1, 0).applyQuaternion(this.group.quaternion); // Current Up
            _hQuat.setFromUnitVectors(_hVec3, normal);
            // Smoothly tilt
            const smoothQuat = new THREE.Quaternion().slerp(_hQuat, dt * 5.0);
            this.group.quaternion.premultiply(smoothQuat);
        }
        
        this.group.position.copy(_hVec1);
        
        // Spring updates
        const s = this.group.userData.springs.scale;
        const diff = s.target - s.pos;
        s.vel += (diff * s.k - s.vel * s.d) * dt;
        s.pos += s.vel * dt;
        
        // Apply scale spring to body group Y (bobbing)
        if (this.bodyGroup) {
            this.bodyGroup.position.y = (s.pos - 1.0) * 0.5; 
        }
    }
    
    updateIK(dt) {
        if (this.limbs.length < 4) return;
        
        const speed = this.group.userData.velocity.length();
        const isMoving = speed > 1.0;
        
        // Gait Cycle (Trot)
        // FL(0) & BR(3) are phase 0
        // FR(1) & BL(2) are phase 0.5
        this.gaitTime += dt * speed * 0.3; // Stride frequency
        
        const phases = [0, 0.5, 0.5, 0]; 
        
        // Offsets from center for each leg
        const legOffsets = [
            new THREE.Vector3(0.4, 0, 0.8),   // FL
            new THREE.Vector3(-0.4, 0, 0.8),  // FR
            new THREE.Vector3(0.4, 0, -0.8),  // BL
            new THREE.Vector3(-0.4, 0, -0.8)  // BR
        ];
        
        for(let i=0; i<4; i++) {
            const limb = this.limbs[i];
            
            // 1. Calculate Ideal Foot Position
            // Project forward based on velocity
            // Reuse _hVec1 for offset
            _hVec1.copy(legOffsets[i]).applyQuaternion(this.group.quaternion);
            
            // Reuse _hVec2 for idealPos
            _hVec2.copy(this.group.position).add(_hVec1);
            
            // Add velocity lead
            if (isMoving) {
                // Reuse _hVec3 for lead
                _hVec3.copy(this.group.userData.velocity).normalize().multiplyScalar(this.strideLength * 0.5);
                _hVec2.add(_hVec3);
            }
            
            // Raycast to find ground at ideal pos
            // Reuse _hVec4 for ray origin
            _hVec4.copy(_hVec2).add(_hUp.clone().multiplyScalar(2));
            this.raycaster.set(_hVec4, _hDown);
            
            if (window.flux.staticGroup) {
                const hits = this.raycaster.intersectObjects(window.flux.staticGroup.children, true);
                if (hits.length > 0) {
                    _hVec2.y = hits[0].point.y;
                } else {
                    _hVec2.y = 0; // Fallback
                }
            }
            
            // 2. Animate Foot Target
            if (isMoving) {
                const phase = (this.gaitTime + phases[i]) % 1.0;
                
                // Swing Phase (0.0 - 0.5): Move foot forward and up
                if (phase < 0.5) {
                    const t = phase * 2.0; // 0 to 1
                    // Parabolic arc
                    const height = Math.sin(t * Math.PI) * this.stepHeight;
                    
                    // Lerp from 'behind' to 'front' relative to body
                    // Simplified: Just move towards idealPos + some forward overstep
                    const forward = this.group.userData.velocity.clone().normalize();
                    const start = _hVec2.clone().sub(forward.multiplyScalar(this.strideLength * 0.5));
                    const end = _hVec2.clone().add(forward.multiplyScalar(this.strideLength * 0.5));
                    
                    this.footTargets[i].lerpVectors(start, end, t);
                    this.footTargets[i].y += height;
                } 
                // Stance Phase (0.5 - 1.0): Foot planted, moves backward relative to body
                else {
                    const t = (phase - 0.5) * 2.0; // 0 to 1
                    const forward = this.group.userData.velocity.clone().normalize();
                    const start = _hVec2.clone().add(forward.multiplyScalar(this.strideLength * 0.5));
                    const end = _hVec2.clone().sub(forward.multiplyScalar(this.strideLength * 0.5));
                    
                    this.footTargets[i].lerpVectors(start, end, t);
                    // Raycast again to ensure planted on ground
                    this.raycaster.set(this.footTargets[i].clone().add(new THREE.Vector3(0, 2, 0)), _hDown);
                    if (window.flux.staticGroup) {
                        const hits = this.raycaster.intersectObjects(window.flux.staticGroup.children, true);
                        if (hits.length > 0) this.footTargets[i].y = hits[0].point.y;
                    }
                }
            } else {
                // Idle: Plant feet at ideal spots
                this.footTargets[i].lerp(_hVec2, dt * 10);
            }
            
            // 3. Solve IK
            
            // Reuse _hVec3 for hipPos
            limb.hip.getWorldPosition(_hVec3);
            
            const fwd = _hFwd.clone().applyQuaternion(this.group.quaternion);
            const up = _hUp.clone().applyQuaternion(this.group.quaternion);
            
            let polePos;
            if (limb.isRear) {
                // Rear legs: Knees bend forward
                polePos = _hVec3.clone().add(fwd.clone().multiplyScalar(2.0)).add(up);
            } else {
                // Front legs: Knees bend backward
                polePos = _hVec3.clone().sub(fwd.clone().multiplyScalar(2.0)).add(up);
            }
            
            this.ikSolver.solve(
                limb.upper, 
                limb.lower, 
                this.footTargets[i], 
                polePos, 
                this.upperLen, 
                this.lowerLen, 
                0.9 // Stiffness
            );
        }
    }
    
    updateThrusters(dt) {
        if (!this.thrusters) return;
        
        // Only show thrusters when boosting
        const intensity = this.isBoosting ? 1.0 : 0.0;
        
        this.thrusters.forEach(t => {
            if (t && t.update) {
                t.update(dt, intensity);
            }
        });
    }
    
    updateAnimation(dt) {
        const speed = this.group.userData.velocity.length();
        
        if (speed > 1.0) {
            // Body Tilt
            if (this.bodyGroup) {
                this.bodyGroup.rotation.z = Math.sin(this.runCycle) * 0.05; // Roll
                this.bodyGroup.rotation.x = Math.sin(this.runCycle * 2) * 0.05; // Pitch
            }
        } else {
            // Idle breathing
            this.runCycle += dt * 2.0;
            if (this.bodyGroup) {
                this.bodyGroup.position.y = Math.sin(this.runCycle) * 0.02;
            }
        }
        
        // Tail Wag
        if (this.tail) {
            const wagSpeed = (speed > 1.0) ? 15.0 : 2.0;
            this.tail.rotation.y = Math.sin(this.runCycle * 0.5) * 0.2;
        }
    }
    
    // --- SHIELD LOGIC ---
    updateShield(dt) {
        if (this.shieldMesh && this.matShield) {
            if (this.shieldMesh.visible) {
                // Fade out
                this.matShield.uniforms.uHit.value -= dt * 2.0;
                if (this.matShield.uniforms.uHit.value <= 0) {
                    this.shieldMesh.visible = false;
                    this.matShield.uniforms.uHit.value = 0;
                }
            }
        }
    }

    shouldBlock(attackerPos) {
        const toAttacker = new THREE.Vector3().subVectors(attackerPos, this.group.position).normalize();
        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.group.quaternion);
        const dot = forward.dot(toAttacker);
        
        if (dot > 0.5) {
            if (this.shieldMesh && this.matShield) {
                this.shieldMesh.visible = true;
                this.matShield.uniforms.uHit.value = 1.0;
            }
            return true;
        }
        return false;
    }
    
    updateHealthBar() {
        if (!this.healthBar) return;
        const pct = this.group.userData.hp / this.maxHp;
        this.healthBar.scale.x = Math.max(0, pct);
        if (window.camera) {
            this.healthBar.lookAt(window.camera.position);
            this.healthBarBg.lookAt(window.camera.position);
        }
    }
    
    handleDeath() {
        this.group.userData.isDead = true;
        if (window.flux.killEnemy) window.flux.killEnemy(this.group);
    }
}</script>
    
    <!-- SPAWN SYSTEM (Refactored into 3 files) -->
    <script>/**
 * WAVE CONFIGURATION DATA
 * Defines the composition, difficulty, and timing of enemy waves per stage.
 * Loaded before SpawnSystem.
 * UPDATED: Implemented Stage-Specific Wave Logic.
 * UPDATED: Scyther Swarm is EXCLUSIVELY in 'CITY' stage, Wave 2.
 * UPDATED: Added 'SPIRE' wave configuration.
 * UPDATED: Added Neural Zealot, Lag Knight, and Support Drone to waves.
 */

const STAGE_WAVES = {
    'CITY': [
        // WAVE 1: PERIMETER BREACH (Standard Intro)
        {
            name: "PERIMETER BREACH",
            type: "timed",
            duration: 60, 
            spawnInterval: 3.0,
            maxEnemies: 6,
            pool: ['standard', 'assault', 'sniper', 'zealot'] // Added Zealot
        },
        // WAVE 2: SCYTHER SWARM (MID-BOSS) - EXCLUSIVE TO CITY
        {
            name: "SCYTHER SWARM",
            type: "swarm_boss", // Special logic in SpawnSystem
            totalToDefeat: 60, // Placeholder, overridden by random logic in SpawnSystem
            maxActive: 15, // Fight 15 at once for intensity
            spawnInterval: 0.5, // Very fast replacement
            pool: ['scyther'],
            cinematic: true // Triggers entrance
        },
        // WAVE 3: ELITE SQUADRON (Cleanup/Late Stage)
        {
            name: "ELITE SQUADRON",
            type: "timed",
            duration: 999, 
            spawnInterval: 8.0,
            maxEnemies: 5,
            pool: ['gargantua', 'sniper', 'scyther', 'bomber', 'lag_knight', 'support'] // Added Lag Knight & Support
        }
    ],
    'SPIRE': [
        // WAVE 1: SECURITY BREACH
        {
            name: "SECURITY BREACH",
            type: "timed",
            duration: 60,
            spawnInterval: 4.0,
            maxEnemies: 5,
            pool: ['lag_knight', 'assault', 'zealot'] // Heavy on Knights and Zealots
        },
        // WAVE 2: RESOURCE DENIAL (Elites)
        {
            name: "RESOURCE DENIAL",
            type: "timed",
            duration: 90,
            spawnInterval: 6.0,
            maxEnemies: 4,
            pool: ['gargantua', 'lag_knight', 'sniper', 'support'] // Added Support
        },
        // WAVE 3: CORE DEFENSE (Bosses)
        {
            name: "CORE DEFENSE",
            type: "timed",
            duration: 999,
            spawnInterval: 10.0,
            maxEnemies: 3,
            pool: ['gargantua', 'anubis', 'hunter'] // Rare Anubis spawn
        }
    ],
    // DEFAULT CONFIG FOR OTHER STAGES (NO SWARM)
    'DEFAULT': [
        {
            name: "HOSTILE PATROL",
            type: "timed",
            duration: 60,
            spawnInterval: 4.0,
            maxEnemies: 5,
            pool: ['standard', 'sniper', 'zealot']
        },
        {
            name: "HEAVY ASSAULT",
            type: "timed",
            duration: 90,
            spawnInterval: 5.0,
            maxEnemies: 6,
            pool: ['assault', 'bomber', 'hunter', 'support']
        },
        {
            name: "ELITE GUARD",
            type: "timed",
            duration: 999,
            spawnInterval: 8.0,
            maxEnemies: 4,
            pool: ['gargantua', 'hunter', 'lag_knight']
        }
    ]
};

const SPAWN_CONFIG = {
    minDist: 15, 
    maxDist: 40,
    heightRange: { min: 2, max: 10 }
};

// Helper to retrieve config
function getWaveConfig(stageName) {
    return STAGE_WAVES[stageName] || STAGE_WAVES['DEFAULT'];
}</script>
    <script>/**
 * ENEMY FACTORY
 * Centralizes the instantiation of different enemy types.
 * Decouples spawning logic from specific enemy class implementations.
 * UPDATED: Added explicit cases for 'lag_knight' and 'zealot'.
 */
class EnemyFactory {
    static create(type, scene, position) {
        let enemy = null;

        switch (type) {
            case 'hunter':
                if (typeof HunterEnemy !== 'undefined') {
                    enemy = new HunterEnemy(scene, position);
                } else {
                    console.warn("HunterEnemy class missing");
                }
                break;
                
            case 'anubis':
                if (typeof AnubisBoss !== 'undefined') {
                    enemy = new AnubisBoss(scene, position);
                } else {
                    console.warn("AnubisBoss class missing");
                }
                break;

            case 'gargantua':
                if (typeof MechDroneEnemy !== 'undefined') {
                    enemy = new MechDroneEnemy(scene, 'gargantua', position);
                }
                break;

            case 'scyther':
            case 'lag_knight': // Explicit case
            case 'zealot':     // Explicit case
            case 'standard':
            case 'sniper':
            case 'assault':
            case 'support':
            case 'bomber':
            default:
                if (typeof MechDroneEnemy !== 'undefined') {
                    enemy = new MechDroneEnemy(scene, type, position);
                } else {
                    console.warn("MechDroneEnemy class missing");
                }
                break;
        }

        return enemy;
    }
}</script>
    
    <!-- NEW: Enemy Pool -->
    <script>/**
 * ENEMY OBJECT POOL
 * Manages reuse of enemy entities to prevent Garbage Collection spikes.
 * Stores inactive enemies by type and recycles them.
 */
class EnemyPool {
    constructor(scene) {
        this.scene = scene;
        this.pools = {}; // Map<type, Array<EnemyController>>
    }

    /**
     * Get an enemy from the pool or create a new one.
     * @param {string} type - Enemy type (e.g., 'standard', 'hunter')
     * @param {THREE.Vector3} position - Spawn position
     * @returns {Object} The enemy controller
     */
    get(type, position) {
        if (!this.pools[type]) {
            this.pools[type] = [];
        }

        let enemy = null;

        if (this.pools[type].length > 0) {
            // Reuse existing
            enemy = this.pools[type].pop();
            // Reset state
            if (enemy.reset) {
                enemy.reset(position);
            } else {
                // Fallback if reset not implemented (shouldn't happen with correct implementation)
                enemy.group.position.copy(position);
                enemy.group.visible = true;
                enemy.group.userData.isDead = false;
                enemy.group.userData.hp = enemy.group.userData.maxHp;
            }
        } else {
            // Create new
            if (typeof EnemyFactory !== 'undefined') {
                enemy = EnemyFactory.create(type, this.scene, position);
            }
        }

        return enemy;
    }

    /**
     * Release an enemy back to the pool.
     * @param {Object} enemy - The enemy controller
     */
    release(enemy) {
        if (!enemy || !enemy.group) return;

        const type = enemy.type || enemy.group.userData.enemyType;
        
        if (!this.pools[type]) {
            this.pools[type] = [];
        }

        // Hide and disable
        enemy.group.visible = false;
        enemy.group.userData.isDead = true;
        // Move away to prevent accidental interactions
        enemy.group.position.set(0, -1000, 0);

        this.pools[type].push(enemy);
    }
}</script>
    
    <script>/**
 * SPAWN SYSTEM
 * Manages wave progression, enemy pooling, and spawn timers.
 * Depends on: js/wave-data.js, js/enemy-factory.js, js/enemy-pool.js
 * UPDATED: Now accepts stageType in constructor to load specific waves.
 * UPDATED: Uses this.waves instead of global WAVE_CONFIG.
 */
class DroneSpawnSystem {
    constructor(scene, enemyGroup, stageType = 'CITY') {
        this.scene = scene;
        this.enemyGroup = enemyGroup;
        
        // Load Stage Specific Waves
        this.waves = (typeof getWaveConfig === 'function') ? getWaveConfig(stageType) : [];
        
        this.currentWaveIndex = 0;
        this.waveTimer = 0;
        this.spawnTimer = 0;
        this.activeEnemies = [];
        
        this.waveActive = true;
        
        // Swarm Boss State
        this.swarmKills = 0;
        this.swarmTotal = 0;
        this.backgroundSwarmMesh = null;
        this.swarmPhases = null; // For animation
        this.swarmBaseY = null; // For animation
        this.swarmAlive = null; // Track alive state of background instances
        this.currentSwarmPositions = null; // NEW: Track positions for collision
        this.cinematicTriggered = false;
        
        // Initialize Enemy Pool
        if (typeof EnemyPool !== 'undefined') {
            this.pool = new EnemyPool(scene);
        } else {
            console.warn("EnemyPool not found. Falling back to direct creation.");
        }
        
        // Initial spawn delay
        this.spawnTimer = 0.1;
        
        // Expose for Combat System
        window.flux.spawnSystem = this;
        
        console.log(`SpawnSystem: Online for stage ${stageType}`);
    }

    forceStop() {
        console.log("SpawnSystem: Force Stopping Wave");
        this.waveActive = false;
        
        // 1. Cleanup Background Swarm immediately
        this.cleanupBackgroundSwarm();
        
        // 2. Kill all active enemies immediately
        for (let i = this.activeEnemies.length - 1; i >= 0; i--) {
            const enemyGroup = this.activeEnemies[i];
            
            // Mark dead and hide
            enemyGroup.visible = false;
            enemyGroup.userData.isDead = true;
            
            // Return to pool if possible
            if (this.pool && enemyGroup.userData.controller) {
                this.pool.release(enemyGroup.userData.controller);
            } else {
                this.enemyGroup.remove(enemyGroup);
            }
        }
        this.activeEnemies = [];
        
        // 3. Clear global references
        if (window.flux.enemies) {
            window.flux.enemies.length = 0;
        }
        
        // 4. Hide Swarm UI
        const counter = document.getElementById('swarm-counter');
        if (counter) counter.style.display = 'none';
        
        // 5. Reset Timers
        this.spawnTimer = 9999; // Prevent accidental spawn
    }

    update(dt, player) {
        if (!this.waveActive || !player) return;
        
        // Clean up dead enemies from list
        for (let i = this.activeEnemies.length - 1; i >= 0; i--) {
            const enemyGroup = this.activeEnemies[i];
            
            // Check if dead
            if (enemyGroup.userData.isDead) {
                // If pool exists, release it back to pool
                if (this.pool && enemyGroup.userData.controller) {
                    this.pool.release(enemyGroup.userData.controller);
                } else {
                    // Fallback: Remove from scene (GC)
                    this.enemyGroup.remove(enemyGroup);
                }
                
                // Remove from active list
                this.activeEnemies.splice(i, 1);
                
                // Also remove from global flux.enemies array to keep it clean
                if (window.flux && window.flux.enemies) {
                    const globalIdx = window.flux.enemies.indexOf(enemyGroup);
                    if (globalIdx > -1) window.flux.enemies.splice(globalIdx, 1);
                }
                
                // SWARM LOGIC: Count kills
                const currentWave = this.waves[this.currentWaveIndex];
                if (currentWave && currentWave.type === 'swarm_boss') {
                    this.swarmKills++;
                    this.updateBackgroundSwarm(dt); // Just update logic, visual update is separate
                    if (typeof updateSwarmCounter === 'function') {
                        updateSwarmCounter(currentWave.totalToDefeat - this.swarmKills);
                    }
                }
                
            } else {
                // Update enemy logic
                if (enemyGroup.userData.controller && typeof enemyGroup.userData.controller.update === 'function') {
                    enemyGroup.userData.controller.update(dt, player);
                }
            }
        }
        
        // Always animate background swarm if it exists
        if (this.backgroundSwarmMesh) {
            this.updateBackgroundSwarm(dt);
        }
        
        // Wave Progression
        if (this.currentWaveIndex >= this.waves.length) return;
        const currentWave = this.waves[this.currentWaveIndex];
        
        if (currentWave.type === 'swarm_boss') {
            // Boss Wave: Progress by kills
            if (!this.cinematicTriggered && currentWave.cinematic) {
                this.cinematicTriggered = true;
                this.waveActive = false; // Pause spawning during cinematic
                
                // Determine Swarm Size randomly
                const rand = Math.random();
                let swarmSize = 'full';
                let totalEnemies = currentWave.totalToDefeat;
                
                if (rand < 0.3) {
                    swarmSize = 'small';
                    totalEnemies = 6;
                } else if (rand < 0.6) {
                    swarmSize = 'medium';
                    totalEnemies = 16;
                } else {
                    swarmSize = 'full';
                    totalEnemies = 40 + Math.floor(Math.random() * 20); // 40-60
                }
                
                // Override wave config with random size
                currentWave.totalToDefeat = totalEnemies;
                
                // Initialize background swarm immediately for cinematic
                this.initBackgroundSwarm(totalEnemies);
                
                // CRITICAL FIX: Hide the persistent mesh during cinematic to avoid duplication
                // The cinematic plays using a temporary mesh in flux-helpers.js
                if (this.backgroundSwarmMesh) this.backgroundSwarmMesh.visible = false;
                
                if (window.flux.startSwarmCinematic) {
                    window.flux.startSwarmCinematic(() => {
                        // Cinematic Done
                        if (this.backgroundSwarmMesh) this.backgroundSwarmMesh.visible = true; // Show real mesh
                        this.waveActive = true; // Resume
                        if (typeof updateSwarmCounter === 'function') {
                            updateSwarmCounter(currentWave.totalToDefeat);
                        }
                    }, swarmSize); // Pass size to cinematic
                } else {
                    this.waveActive = true;
                    if (this.backgroundSwarmMesh) this.backgroundSwarmMesh.visible = true;
                }
                return;
            }
            
            if (this.swarmKills >= currentWave.totalToDefeat) {
                this.cleanupBackgroundSwarm();
                this.nextWave();
                return;
            }
            
            // Spawn logic for swarm (Aggressive replacement)
            this.spawnTimer -= dt;
            if (this.spawnTimer <= 0) {
                if (!this.swarmSpawnedCount) this.swarmSpawnedCount = 0;
                
                if (this.activeEnemies.length < currentWave.maxActive && this.swarmSpawnedCount < currentWave.totalToDefeat) {
                    this.spawnEnemy(player, currentWave);
                    this.swarmSpawnedCount++;
                }
                this.spawnTimer = currentWave.spawnInterval;
            }
            
        } else {
            // Standard Wave: Progress by Time
            this.waveTimer += dt;
            if (this.waveTimer >= currentWave.duration) {
                this.nextWave();
            }
            
            // Spawning Logic
            this.spawnTimer -= dt;
            if (this.spawnTimer <= 0) {
                if (this.activeEnemies.length < currentWave.maxEnemies) {
                    this.spawnEnemy(player, currentWave);
                }
                this.spawnTimer = currentWave.spawnInterval;
            }
        }
    }
    
    initBackgroundSwarm(count) {
        this.swarmTotal = count;
        this.swarmPhases = new Float32Array(count);
        this.swarmBaseY = new Float32Array(count);
        this.swarmAlive = new Uint8Array(count).fill(1); // 1 = Alive, 0 = Dead
        this.currentSwarmPositions = new Float32Array(count * 3); // NEW: For collision
        
        // Use High-Fidelity Baked Geometry
        let geo;
        if (typeof AssetFactory !== 'undefined' && AssetFactory.getScytherInstancedGeometry) {
            geo = AssetFactory.getScytherInstancedGeometry();
        } else {
            geo = new THREE.ConeGeometry(0.5, 2.0, 3); // Fallback
        }
        
        // Dark metallic material with green emission
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0x112211, 
            emissive: 0x00ff00,
            emissiveIntensity: 0.5,
            roughness: 0.7,
            metalness: 0.8
        });
        
        this.backgroundSwarmMesh = new THREE.InstancedMesh(geo, mat, count);
        this.backgroundSwarmMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        
        const dummy = new THREE.Object3D();
        // UPDATED: Radius reduced to 40 to fit inside walls (Walls at 60)
        const radius = 40; 
        
        for(let i=0; i<count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = radius + (Math.random() - 0.5) * 10; // Slight variation
            
            // Position in a circle on the ground
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const y = 0;
            
            dummy.position.set(x, y, z);
            
            // Look at center (0,0,0)
            dummy.lookAt(0,0,0);
            
            // Random scale variation
            // UPDATED: Scale 0.56 (1.4x bigger than 0.4)
            const baseScale = 0.56; 
            const s = baseScale + Math.random() * 0.1;
            dummy.scale.set(s,s,s);
            
            dummy.updateMatrix();
            this.backgroundSwarmMesh.setMatrixAt(i, dummy.matrix);
            
            // Store for animation
            this.swarmPhases[i] = Math.random() * Math.PI * 2;
            this.swarmBaseY[i] = y;
            
            // Init Position Array
            this.currentSwarmPositions[i*3] = x;
            this.currentSwarmPositions[i*3+1] = y;
            this.currentSwarmPositions[i*3+2] = z;
        }
        
        this.scene.add(this.backgroundSwarmMesh);
    }
    
    // NEW: Kill a background instance
    killBackgroundInstance(instanceId) {
        if (!this.backgroundSwarmMesh || !this.swarmAlive) return;
        if (this.swarmAlive[instanceId] === 0) return; // Already dead
        
        // Mark dead
        this.swarmAlive[instanceId] = 0;
        this.swarmKills++;
        
        // Get position for effects
        const position = new THREE.Vector3(
            this.currentSwarmPositions[instanceId*3],
            this.currentSwarmPositions[instanceId*3+1],
            this.currentSwarmPositions[instanceId*3+2]
        );
        
        // Visuals
        if (window.flux.spawnParticles) window.flux.spawnParticles(position, 15, 0x00ff00, 15);
        if (window.flux.audio) window.flux.audio.play('hit_flesh');
        if (window.flux.showDamage) window.flux.showDamage(position, 999, true);
        
        // Hide Instance (Scale to 0)
        const dummy = new THREE.Object3D();
        dummy.position.copy(position);
        dummy.scale.set(0, 0, 0);
        dummy.updateMatrix();
        this.backgroundSwarmMesh.setMatrixAt(instanceId, dummy.matrix);
        this.backgroundSwarmMesh.instanceMatrix.needsUpdate = true;
        
        // Update HUD
        const currentWave = this.waves[this.currentWaveIndex];
        if (currentWave && typeof updateSwarmCounter === 'function') {
            updateSwarmCounter(currentWave.totalToDefeat - this.swarmKills);
        }
        
        // Add Combo
        if (window.flux.addCombo) window.flux.addCombo();
    }
    
    updateBackgroundSwarm(dt) {
        if (!this.backgroundSwarmMesh) return;
        
        const dummy = new THREE.Object3D();
        const matrix = new THREE.Matrix4();
        const position = new THREE.Vector3();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        
        const limit = this.swarmTotal;
        const spawned = this.swarmSpawnedCount || 0;
        
        for (let i = 0; i < limit; i++) {
            // Skip dead instances
            if (this.swarmAlive && this.swarmAlive[i] === 0) continue;
            
            // If this index corresponds to an enemy that has "spawned" into battle, hide it from background
            if (i < spawned) {
                dummy.position.set(0, -5000, 0);
                dummy.updateMatrix();
                this.backgroundSwarmMesh.setMatrixAt(i, dummy.matrix);
                continue;
            }
            
            // Get current matrix
            this.backgroundSwarmMesh.getMatrixAt(i, matrix);
            matrix.decompose(position, quaternion, scale);
            
            // Animate Y
            const phase = this.swarmPhases[i];
            const time = Date.now() * 0.002;
            // UPDATED: Increased float amplitude to 2.5
            const newY = this.swarmBaseY[i] + Math.sin(time + phase) * 2.5; 
            
            dummy.position.set(position.x, newY, position.z);
            dummy.quaternion.copy(quaternion);
            dummy.scale.copy(scale);
            dummy.updateMatrix();
            
            this.backgroundSwarmMesh.setMatrixAt(i, dummy.matrix);
            
            // Update Position Array for Collision
            if (this.currentSwarmPositions) {
                this.currentSwarmPositions[i*3] = position.x;
                this.currentSwarmPositions[i*3+1] = newY;
                this.currentSwarmPositions[i*3+2] = position.z;
            }
        }
        
        this.backgroundSwarmMesh.instanceMatrix.needsUpdate = true;
    }
    
    cleanupBackgroundSwarm() {
        if (this.backgroundSwarmMesh) {
            this.scene.remove(this.backgroundSwarmMesh);
            this.backgroundSwarmMesh.geometry.dispose();
            this.backgroundSwarmMesh.material.dispose();
            this.backgroundSwarmMesh = null;
        }
        
        // REMOVE BARRIER
        if (window.game && window.game.staticGroup) {
            const toRemove = [];
            window.game.staticGroup.traverse(obj => {
                if (obj.userData && obj.userData.isSwarmBarrier) {
                    toRemove.push(obj);
                }
            });
            
            toRemove.forEach(obj => {
                window.game.staticGroup.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            
            // Reset Physics Arena Radius
            if (window.flux.player) window.flux.player.arenaRadius = null;
        }

        if (typeof updateSwarmCounter === 'function') {
            const el = document.getElementById('swarm-counter');
            if (el) el.style.display = 'none';
        }
    }
    
    spawnEnemy(player, waveConfig) {
        // Pick random type from pool
        const type = waveConfig.pool[Math.floor(Math.random() * waveConfig.pool.length)];
        
        // Calculate Spawn Position (Around player, but not too close)
        const angle = Math.random() * Math.PI * 2;
        const dist = SPAWN_CONFIG.minDist + Math.random() * (SPAWN_CONFIG.maxDist - SPAWN_CONFIG.minDist);
        
        const x = player.mesh.position.x + Math.cos(angle) * dist;
        const z = player.mesh.position.z + Math.sin(angle) * dist;
        const y = SPAWN_CONFIG.heightRange.min + Math.random() * (SPAWN_CONFIG.heightRange.max - SPAWN_CONFIG.heightRange.min);
        
        const pos = new THREE.Vector3(x, y, z);
        
        let enemyController;
        
        // Use Pool if available
        if (this.pool) {
            enemyController = this.pool.get(type, pos);
        } else {
            enemyController = EnemyFactory.create(type, this.scene, pos);
        }
        
        if (enemyController && enemyController.group) {
            // Ensure it's in the scene graph (Pool might have removed it or it's new)
            if (!enemyController.group.parent) {
                this.enemyGroup.add(enemyController.group);
            }
            
            // Add to tracking list (reference the Group, which has UserData)
            this.activeEnemies.push(enemyController.group);
            
            // Add to global shared array for other systems (Combat, Radar)
            if (window.flux && window.flux.enemies) {
                window.flux.enemies.push(enemyController.group);
            }
            
            // Spawn Effect
            if (window.flux && window.flux.spawnParticles) {
                window.flux.spawnParticles(pos, 20, 0xff0000, 10);
            }
            if (window.flux && window.flux.audio) {
                window.flux.audio.play('teleport');
            }
        }
    }
    
    nextWave() {
        this.currentWaveIndex++;
        if (this.currentWaveIndex >= this.waves.length) {
            this.currentWaveIndex = this.waves.length - 1; // Loop last wave
        }
        
        this.waveTimer = 0;
        this.swarmKills = 0;
        this.swarmSpawnedCount = 0;
        this.cinematicTriggered = false;
        
        const waveName = this.waves[this.currentWaveIndex].name;
        
        if (window.flux.spawnTechText) {
            window.flux.spawnTechText(`WAVE ${this.currentWaveIndex + 1}: ${waveName}`);
        }
        
        if (window.flux.audio) {
            window.flux.audio.play('charge');
        }
    }
}</script>
    
    <!-- WORLD GENERATION MODULES (Refactored) -->
    <script>/**
 * WORLD UTILITIES
 * Common helper functions for environment and effects.
 * Extracted from world-gen.js
 */

function initDust(group) {
    const dustCount = 400; 
    const dustGeo = new THREE.BufferGeometry();
    const positions = [];
    for(let i=0; i<dustCount; i++) {
        positions.push((Math.random()-0.5)*200); 
        positions.push((Math.random())*40); 
        positions.push((Math.random()-0.5)*200); 
    }
    dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const dustMat = new THREE.PointsMaterial({ color: 0xccddff, size: 0.25, transparent: true, opacity: 0.6, sizeAttenuation: true, blending: THREE.AdditiveBlending });
    group.add(new THREE.Points(dustGeo, dustMat));
}

function initRain(group) {
    const rainCount = 1000; 
    const rainGeo = new THREE.BufferGeometry();
    const positions = [];
    for(let i=0; i<rainCount; i++) {
        positions.push((Math.random()-0.5)*200);
        positions.push(Math.random()*60);
        positions.push((Math.random()-0.5)*200);
    }
    rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const rainMat = new THREE.PointsMaterial({ color: 0x88ffff, size: 0.3, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
    const rainSystem = new THREE.Points(rainGeo, rainMat);
    rainSystem.userData = { velocities: new Float32Array(rainCount) };
    for(let i=0; i<rainCount; i++) rainSystem.userData.velocities[i] = 20 + Math.random()*20;
    group.add(rainSystem);
}

function spawnPlasmaOrbs(system, pos, count, forceColor = null) {
    if (!pos || !system) return;
    
    // UPDATED: Removed minimum clamp (was Math.max(count, 200)) to allow fewer drops
    const actualCount = count; 
    
    for (let i = 0; i < actualCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const upForce = 20.0 + Math.random() * 30.0; 
        const spreadForce = 15.0 + Math.random() * 15.0; 
        
        const vel = new THREE.Vector3(Math.cos(angle) * spreadForce, upForce, Math.sin(angle) * spreadForce);
        
        let colorHex;
        if (forceColor !== null) {
            colorHex = forceColor;
        } else {
            const palette = [0x00ffff, 0xff00ff, 0xffaa00, 0x00ff00];
            colorHex = palette[Math.floor(Math.random() * palette.length)];
        }
        
        // UPDATED: Logic for bigger orbs (approx 5% chance)
        const isBig = Math.random() > 0.95;
        const size = isBig ? (2.5 + Math.random() * 1.5) : (0.6 + Math.random() * 0.4); 
        
        const rotVel = new THREE.Vector3((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);
        
        // UPDATED: Life set to 10.0 seconds so drops disappear
        system.spawn(pos, vel, colorHex, 10.0, 40, size, 0.0, 0.6, rotVel, 0.8, 0.3, 0.5 + Math.random() * 0.5);
    }
}

function flashEnemy(obj) {
    if (!obj) return;
    obj.traverse((child) => {
        if (child.isMesh) {
            if (child.material && child.material.emissive) {
                if (!child.userData.origEmissive) child.userData.origEmissive = child.material.emissive.getHex();
                child.material.emissive.setHex(0xffffff);
                setTimeout(() => {
                    if (child.material) child.material.emissive.setHex(child.userData.origEmissive);
                }, 100);
            } 
            else if (child.material && child.material.color) {
                if (!child.userData.origColor) child.userData.origColor = child.material.color.getHex();
                child.material.color.setHex(0xffffff);
                setTimeout(() => {
                    if (child.material) child.material.color.setHex(child.userData.origColor);
                }, 100);
            }
        }
    });
}</script>
    <script>/**
 * STAGE BUILDERS
 * Specific geometry generation for different biomes.
 * Extracted from world-gen.js
 */

function buildCyberCity(group) {
    const buildingTex = TextureGen.createBuildingTex(256, '#555'); 
    const wallMat = new THREE.MeshStandardMaterial({ map: buildingTex, roughness: 0.3, metalness: 0.5 });
    const neonMat = new THREE.MeshBasicMaterial({ color: 0x00ff9d });

    // Central Platform
    const centerBlock = new THREE.Mesh(new THREE.BoxGeometry(20, 4, 20), wallMat);
    centerBlock.position.set(0, 2, 0);
    centerBlock.castShadow = true;
    centerBlock.receiveShadow = true;
    group.add(centerBlock);

    // Walls / Skyscrapers
    const longWallGeo = new THREE.BoxGeometry(10, 60, 100);
    const longWall1 = new THREE.Mesh(longWallGeo, wallMat);
    longWall1.position.set(-60, 30, 0);
    group.add(longWall1);

    const longWall2 = new THREE.Mesh(longWallGeo, wallMat);
    longWall2.position.set(60, 30, 0);
    group.add(longWall2);
    
    // Floating Platforms
    const platGeo = new THREE.BoxGeometry(8, 1, 8);
    const platMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
    
    for(let i=0; i<5; i++) {
        const plat = new THREE.Mesh(platGeo, platMat);
        plat.position.set(
            (Math.random()-0.5) * 80,
            10 + Math.random() * 15,
            (Math.random()-0.5) * 80
        );
        // Keep center clear
        if (plat.position.length() < 20) continue;
        
        group.add(plat);
        
        // Neon trim
        const trim = new THREE.Mesh(new THREE.BoxGeometry(8.2, 0.2, 8.2), neonMat);
        trim.position.copy(plat.position);
        group.add(trim);
    }

    // Skyline
    buildSkyline(group, buildingTex, 0x888888);
}

function buildWasteland(group) {
    const rockGeo = new THREE.DodecahedronGeometry(1, 0);
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x884400, roughness: 0.9 });
    
    // Ruins Material
    const ruinTex = TextureGen.createHazard(256, '#553311', '#221100');
    const ruinMat = new THREE.MeshStandardMaterial({ map: ruinTex, roughness: 0.9 });

    // Random Rocks
    for(let i=0; i<60; i++) {
        const rock = new THREE.Mesh(rockGeo, rockMat);
        const s = 2 + Math.random() * 10;
        rock.scale.set(s, s*0.8, s);
        rock.position.set(
            (Math.random()-0.5) * 200,
            s * 0.3 - 2, // Embed in ground
            (Math.random()-0.5) * 200
        );
        // Clear center
        if (rock.position.length() < 20) continue;
        
        rock.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
        rock.castShadow = true;
        rock.receiveShadow = true;
        group.add(rock);
    }
    
    // Ruined Pillars
    const pillarGeo = new THREE.BoxGeometry(4, 15, 4);
    for(let i=0; i<10; i++) {
        const pillar = new THREE.Mesh(pillarGeo, ruinMat);
        pillar.position.set(
            (Math.random()-0.5) * 120,
            7.5,
            (Math.random()-0.5) * 120
        );
        if (pillar.position.length() < 30) continue;
        
        pillar.rotation.y = Math.random();
        pillar.rotation.z = (Math.random() - 0.5) * 0.5; // Tilted
        pillar.castShadow = true;
        group.add(pillar);
    }
    
    // Giant Pyramids in distance
    const pyrGeo = new THREE.ConeGeometry(30, 50, 4);
    const pyrMat = new THREE.MeshStandardMaterial({ color: 0xcc8800, roughness: 0.5, metalness: 0.2 });
    
    const p1 = new THREE.Mesh(pyrGeo, pyrMat);
    p1.position.set(-100, 25, -100);
    group.add(p1);
    
    const p2 = new THREE.Mesh(pyrGeo, pyrMat);
    p2.position.set(100, 25, 100);
    group.add(p2);
    
    // NEW: LAND MINES
    const mineGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 8);
    const mineMat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0xff0000, emissiveIntensity: 0.5 });
    
    for(let i=0; i<15; i++) {
        const mine = new THREE.Mesh(mineGeo, mineMat.clone());
        mine.position.set(
            (Math.random()-0.5) * 100,
            0.1,
            (Math.random()-0.5) * 100
        );
        // Adjust for terrain
        mine.position.y = Math.sin(mine.position.x * 0.05) * Math.cos(mine.position.z * 0.05) * 5 + 0.1;
        
        mine.userData = { dynamicType: 'land_mine' };
        group.add(mine);
    }
}

function buildIceSector(group) {
    const iceGeo = new THREE.ConeGeometry(1, 4, 3);
    const iceMat = new THREE.MeshStandardMaterial({ 
        color: 0xaaddff, 
        roughness: 0.1, 
        metalness: 0.1,
        transparent: true,
        opacity: 0.8
    });
    
    const deepIceMat = new THREE.MeshStandardMaterial({
        color: 0x004488,
        roughness: 0.2,
        metalness: 0.5
    });

    // Ice Spikes
    for(let i=0; i<100; i++) {
        const spike = new THREE.Mesh(iceGeo, iceMat);
        const h = 5 + Math.random() * 20;
        const w = 2 + Math.random() * 6;
        spike.scale.set(w, h/4, w); // Scale Y is relative to unit cone height 4
        spike.position.set(
            (Math.random()-0.5) * 250,
            h/2 - 2,
            (Math.random()-0.5) * 250
        );
        if (spike.position.length() < 30) continue;
        
        spike.castShadow = true;
        group.add(spike);
    }
    
    // Large Glaciers (Blocky)
    const glacierGeo = new THREE.BoxGeometry(30, 15, 30);
    
    const g1 = new THREE.Mesh(glacierGeo, deepIceMat);
    g1.position.set(80, 0, -80);
    g1.rotation.y = 0.5;
    group.add(g1);
    
    const g2 = new THREE.Mesh(glacierGeo, deepIceMat);
    g2.position.set(-80, 0, 80);
    g2.rotation.y = -0.5;
    group.add(g2);
    
    // Floating Ice Chunks
    for(let i=0; i<10; i++) {
        const chunk = new THREE.Mesh(new THREE.DodecahedronGeometry(3), iceMat);
        chunk.position.set(
            (Math.random()-0.5) * 100,
            15 + Math.random() * 20,
            (Math.random()-0.5) * 100
        );
        group.add(chunk);
    }
    
    // NEW: FALLING ICE SPIKES (Ceiling Hazards)
    const spikeGeo = new THREE.ConeGeometry(1, 5, 4);
    spikeGeo.rotateX(Math.PI); // Point down
    
    for(let i=0; i<20; i++) {
        const spike = new THREE.Mesh(spikeGeo, iceMat);
        spike.position.set(
            (Math.random()-0.5) * 80,
            25 + Math.random() * 10,
            (Math.random()-0.5) * 80
        );
        spike.userData = { dynamicType: 'ice_spike', triggered: false };
        group.add(spike);
    }
}

function buildVoidZone(group) {
    const monoGeo = new THREE.BoxGeometry(6, 40, 6);
    const monoMat = new THREE.MeshStandardMaterial({ color: 0x110011, roughness: 0.1, metalness: 0.8 });
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xaa00ff });
    
    // The Ring
    for(let i=0; i<16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        const radius = 80;
        
        const mono = new THREE.Mesh(monoGeo, monoMat);
        mono.position.set(Math.cos(angle)*radius, 20, Math.sin(angle)*radius);
        mono.lookAt(0, 20, 0);
        group.add(mono);
        
        // Glowing strip
        const strip = new THREE.Mesh(new THREE.BoxGeometry(0.5, 35, 6.1), glowMat);
        strip.position.copy(mono.position);
        strip.rotation.copy(mono.rotation);
        group.add(strip);
    }
    
    // Floating Geometric Anomalies
    const shapes = [
        new THREE.IcosahedronGeometry(4, 0),
        new THREE.OctahedronGeometry(4, 0),
        new THREE.TetrahedronGeometry(4, 0)
    ];
    
    for(let i=0; i<30; i++) {
        const geo = shapes[Math.floor(Math.random() * shapes.length)];
        const anomaly = new THREE.Mesh(geo, monoMat);
        anomaly.position.set(
            (Math.random()-0.5)*150,
            10 + Math.random()*40,
            (Math.random()-0.5)*150
        );
        // Wireframe glow
        const wire = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true }));
        anomaly.add(wire);
        
        // Tag as dynamic
        anomaly.userData = { dynamicType: 'void_anomaly' };
        
        group.add(anomaly);
    }
    
    // Central Altar
    const altar = new THREE.Mesh(new THREE.CylinderGeometry(10, 15, 5, 8), monoMat);
    altar.position.y = 2.5;
    group.add(altar);
}

// NEW: DATA SPIRE BUILDER (Biome 3)
function buildDataSpire(group) {
    const floorMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.1, metalness: 0.2 });
    const wallMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.1 });
    const glassMat = new THREE.MeshStandardMaterial({ color: 0xccffff, transparent: true, opacity: 0.4, roughness: 0.0, metalness: 0.9 });
    const lightMat = new THREE.MeshBasicMaterial({ color: 0x00aaff });

    // Main Floor (Sterile White)
    const floorGeo = new THREE.BoxGeometry(60, 2, 60);
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.position.y = -1;
    group.add(floor);
    
    // Vertical Pillars (Data Servers)
    const pillarGeo = new THREE.BoxGeometry(4, 40, 4);
    for(let i=0; i<4; i++) {
        const pillar = new THREE.Mesh(pillarGeo, wallMat);
        const x = (i % 2 === 0 ? 25 : -25);
        const z = (i < 2 ? 25 : -25);
        pillar.position.set(x, 20, z);
        group.add(pillar);
        
        // Server Lights
        const stripGeo = new THREE.PlaneGeometry(0.5, 38);
        const strip = new THREE.Mesh(stripGeo, lightMat);
        strip.position.set(x + (x>0?-2.1:2.1), 20, z);
        strip.rotation.y = (x>0 ? -Math.PI/2 : Math.PI/2);
        group.add(strip);
    }
    
    // Upper Platforms (Glass)
    const platGeo = new THREE.BoxGeometry(15, 0.5, 15);
    const positions = [
        [0, 10, 0],
        [20, 15, 0],
        [-20, 15, 0],
        [0, 20, 20],
        [0, 20, -20]
    ];
    
    positions.forEach(pos => {
        const plat = new THREE.Mesh(platGeo, glassMat);
        plat.position.set(...pos);
        group.add(plat);
        
        // Support beams (Holographic?)
        const beamGeo = new THREE.CylinderGeometry(0.1, 0.1, pos[1]);
        const beam = new THREE.Mesh(beamGeo, lightMat);
        beam.position.set(pos[0], pos[1]/2, pos[2]);
        beam.material.transparent = true;
        beam.material.opacity = 0.3;
        group.add(beam);
    });
    
    // AP DAMPENERS (Security Devices)
    if (typeof AssetFactory !== 'undefined' && AssetFactory.createGravityTrap) {
        // Reusing Gravity Trap visual but as AP Dampener
        const dampener1 = AssetFactory.createGravityTrap();
        dampener1.position.set(20, 16, 0);
        dampener1.userData = { dynamicType: 'ap_dampener', radius: 15 };
        group.add(dampener1);
        
        const dampener2 = AssetFactory.createGravityTrap();
        dampener2.position.set(-20, 16, 0);
        dampener2.userData = { dynamicType: 'ap_dampener', radius: 15 };
        group.add(dampener2);
    }
    
    // THE CHRONO-SYNC DATA CORE (Goal)
    if (typeof AssetFactory !== 'undefined' && AssetFactory.createDataCore) {
        const core = AssetFactory.createDataCore();
        core.position.set(0, 12, 0); // On central platform
        // Add a light
        const light = new THREE.PointLight(0x00ff9d, 2, 20);
        light.position.set(0, 14, 0);
        group.add(light);
        group.add(core);
    }
}

function buildSkyline(group, texture, color) {
    const geo = new THREE.BoxGeometry(10, 60, 10);
    const mat = new THREE.MeshBasicMaterial({ map: texture, color: color, fog: true });
    const count = 40; // Increased density
    const mesh = new THREE.InstancedMesh(geo, mat, count);
    const dummy = new THREE.Object3D();
    for(let i=0; i<count; i++) { 
        const angle = Math.random() * Math.PI * 2;
        const radius = 100 + Math.random() * 80;
        dummy.position.set(Math.cos(angle) * radius, 20 + Math.random() * 30, Math.sin(angle) * radius);
        dummy.scale.y = 1 + Math.random() * 3.0;
        dummy.scale.x = 1 + Math.random() * 2.0;
        dummy.scale.z = 1 + Math.random() * 2.0;
        dummy.updateMatrix();
        mesh.setMatrixAt(i, dummy.matrix);
    }
    mesh.instanceMatrix.needsUpdate = true;
    group.add(mesh);
}</script>
    <script>/**
 * WORLD GENERATION SYSTEM (ORCHESTRATOR)
 * Delegates to stage-builders.js and world-utils.js
 * Handles environment configuration.
 * BUG FIX: Removed material disposal to prevent destroying shared cached assets.
 */

const STAGE_CONFIG = {
    'CITY': {
        floorColor: '#00f3ff',
        skyColor: 0x050510,
        fogColor: 0x050510,
        fogDensity: 0.015,
        ambient: 0x111122,
        light: 0xffffff
    },
    'WASTELAND': {
        floorColor: '#ffaa00',
        skyColor: 0x331100,
        fogColor: 0x331100,
        fogDensity: 0.025,
        ambient: 0x442200,
        light: 0xffaa00
    },
    'ICE': {
        floorColor: '#ffffff',
        skyColor: 0xeeffff,
        fogColor: 0xccffff,
        fogDensity: 0.02,
        ambient: 0x444455,
        light: 0x88ccff
    },
    'VOID': {
        floorColor: '#aa00ff',
        skyColor: 0x000000,
        fogColor: 0x110022,
        fogDensity: 0.03,
        ambient: 0x220033,
        light: 0xff00ff
    },
    'SPIRE': {
        floorColor: '#cccccc',
        skyColor: 0xeeeeff,
        fogColor: 0xffffff,
        fogDensity: 0.01,
        ambient: 0x888899,
        light: 0xccffff
    }
};

function buildWorld(group, stageType = 'CITY') {
    // Clear previous world
    while(group.children.length > 0){ 
        const child = group.children[0];
        if (child.geometry) child.geometry.dispose();
        // FIX: Do NOT dispose materials as they might be shared/cached
        // if (child.material) {
        //     if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
        //     else child.material.dispose();
        // }
        group.remove(child); 
    }

    console.log(`WorldGen: Building Stage ${stageType}`);
    const config = STAGE_CONFIG[stageType] || STAGE_CONFIG['CITY'];

    // Update Scene Fog & Background (Global side effects, handled here for convenience)
    if (window.game && window.game.scene) {
        window.game.scene.fog = new THREE.FogExp2(config.fogColor, config.fogDensity);
        window.game.scene.background = new THREE.Color(config.skyColor);
    }

    // --- FLOOR ---
    const gridSize = 512;
    let gridTex;
    
    if (stageType === 'WASTELAND') {
         gridTex = TextureGen.createHazard(512, '#553311', '#331100');
    } else if (stageType === 'ICE') {
         gridTex = TextureGen.createMatCap(512, '#ffffff', '#aaccff'); // Icy look
    } else if (stageType === 'SPIRE') {
         gridTex = TextureGen.createGrid(512, '#00aaff', '#ffffff'); // High tech white/blue
    } else {
         gridTex = TextureGen.createGrid(512, config.floorColor, '#000000'); 
    }
    
    gridTex.wrapS = THREE.RepeatWrapping;
    gridTex.wrapT = THREE.RepeatWrapping;
    gridTex.repeat.set(40, 40);
    
    const floorGeo = new THREE.PlaneGeometry(800, 800, 64, 64); // More segments for displacement
    
    // Displace floor for Wasteland/Ice
    if (stageType === 'WASTELAND' || stageType === 'ICE') {
        const pos = floorGeo.attributes.position;
        for(let i=0; i<pos.count; i++) {
            const z = pos.getZ(i); // Z is Up in PlaneGeometry before rotation
            // Simple noise
            const noise = Math.sin(pos.getX(i) * 0.05) * Math.cos(pos.getY(i) * 0.05) * 5;
            pos.setZ(i, z + noise);
        }
        floorGeo.computeVertexNormals();
    }

    const floorMat = new THREE.MeshStandardMaterial({ 
        map: gridTex, 
        roughness: stageType === 'ICE' ? 0.1 : 0.8, 
        metalness: stageType === 'CITY' ? 0.5 : 0.1,
        emissive: config.fogColor,
        emissiveIntensity: 0.1
    });
    
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -2.0; // Lower slightly to account for displacement
    floor.receiveShadow = true;
    group.add(floor);

    // --- STAGE SPECIFIC GENERATION ---
    switch (stageType) {
        case 'WASTELAND':
            buildWasteland(group);
            break;
        case 'ICE':
            buildIceSector(group);
            break;
        case 'VOID':
            buildVoidZone(group);
            break;
        case 'SPIRE':
            buildDataSpire(group);
            break;
        case 'CITY':
        default:
            buildCyberCity(group);
            break;
    }
    
    // Add some barrels everywhere because video games
    if (typeof AssetFactory !== 'undefined') {
        for (let i = 0; i < 8; i++) {
            const barrel = AssetFactory.createExplosiveBarrel();
            const bx = (Math.random() - 0.5) * 80;
            const bz = (Math.random() - 0.5) * 80;
            barrel.position.set(bx, 0, bz);
            // Adjust height for uneven terrain
            if (stageType === 'WASTELAND' || stageType === 'ICE') {
                 barrel.position.y = Math.sin(bx * 0.05) * Math.cos(bz * 0.05) * 5;
            }
            barrel.userData = { type: 'barrel' };
            group.add(barrel);
        }
    }
    
    // NEW: Register Dynamics
    if (window.game && window.game.stageDynamics) {
        window.game.stageDynamics.registerStageObjects(group);
    }
}</script>
    
    <script>/**
 * UI SYSTEM - OPTIMIZED
 * Handles HUD updates, floating text, menu interactions, and AI Dialogue.
 * OPTIMIZED: Implemented DOM Caching and Dirty Checking.
 * UPDATED: Added FluxAI (Text-to-Speech + Visual Dialogue).
 * UPDATED: AI Voice made smoother and less spammy.
 */

// --- FLOATING TEXT POOL ---
const floatTextPool = {
    pool: [],
    get: function() {
        if (this.pool.length > 0) {
            const el = this.pool.pop();
            el.style.display = 'block';
            el.style.opacity = '1';
            el.style.animation = 'none';
            el.offsetHeight; // Trigger reflow
            el.style.animation = ''; // Re-enable CSS animation
            return el;
        }
        const div = document.createElement('div');
        document.body.appendChild(div);
        return div;
    },
    release: function(el) {
        el.style.display = 'none';
        this.pool.push(el);
    }
};

// --- FLOATING TEXT SYSTEM ---
function spawnFloatingText(pos, text, isCrit, isTech = false, isParry = false) {
    if (isTech) return; // Tech text disabled in favor of AI (mostly)

    if(!pos) return;
    
    const div = floatTextPool.get();
    
    if (isParry) {
        div.className = 'damage-number damage-parry';
    } else {
        div.className = isCrit ? 'damage-number damage-crit' : 'damage-number';
    }
    
    div.innerText = text;
    
    const tempV = pos.clone();
    
    const driftX = (Math.random() - 0.5) * 40;
    const driftY = (Math.random() - 0.5) * 40;
    
    if (window.game && window.game.camera) {
        tempV.project(window.game.camera);
        const x = (tempV.x * .5 + .5) * window.innerWidth;
        const y = (-(tempV.y * .5) + .5) * window.innerHeight;
        
        div.style.left = `${x + driftX}px`;
        div.style.top = `${y + driftY}px`;
        
        const rot = (Math.random() - 0.5) * 20;
        div.style.transform = `translate(-50%, -50%) rotate(${rot}deg)`;
    }
    
    // Use pool release instead of removeChild
    setTimeout(() => {
        floatTextPool.release(div);
    }, 1000);
}

// --- FLUX AI SYSTEM (VOICE & DIALOGUE) ---
class FluxAI {
    constructor() {
        this.synth = window.speechSynthesis;
        this.voice = null;
        this.dialogueBox = null;
        this.dialogueText = null;
        this.isSpeaking = false;
        this.queue = []; // Message queue
        
        this.initUI();
        this.initVoice();
        
        // Retry loading voices if they aren't ready immediately
        if (this.synth.onvoiceschanged !== undefined) {
            this.synth.onvoiceschanged = () => this.initVoice();
        }
    }
    
    initUI() {
        // Create Dialogue Box
        const container = document.createElement('div');
        container.id = 'ai-dialogue-box';
        container.style.cssText = `
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            background: rgba(0, 10, 20, 0.85);
            border: 1px solid #00f3ff;
            border-left: 4px solid #00f3ff;
            padding: 15px;
            display: none;
            flex-direction: row;
            align-items: center;
            gap: 15px;
            z-index: 100;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        `;
        
        const avatar = document.createElement('div');
        avatar.style.cssText = `
            width: 50px;
            height: 50px;
            background: #00f3ff;
            mask-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>');
            -webkit-mask-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>');
            mask-size: cover;
            -webkit-mask-size: cover;
            animation: pulse 1s infinite;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
        `;
        
        const header = document.createElement('div');
        header.innerText = "SYSTEM AI";
        header.style.cssText = `
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #00f3ff;
            letter-spacing: 2px;
            margin-bottom: 4px;
        `;
        
        this.dialogueText = document.createElement('div');
        this.dialogueText.style.cssText = `
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            color: white;
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        `;
        
        content.appendChild(header);
        content.appendChild(this.dialogueText);
        container.appendChild(avatar);
        container.appendChild(content);
        
        document.getElementById('ui-layer').appendChild(container);
        this.dialogueBox = container;
    }
    
    initVoice() {
        const voices = this.synth.getVoices();
        // Priority: Google US English (Chrome), Microsoft Zira (Windows), Samantha (Mac), any Female
        this.voice = voices.find(v => v.name === 'Google US English') || 
                     voices.find(v => v.name.includes('Zira')) || 
                     voices.find(v => v.name.includes('Samantha')) ||
                     voices.find(v => v.name.includes('Female')) || 
                     voices[0];
    }
    
    speak(text, priority = false) {
        // Filter out non-critical spam
        // Only speak if priority is true (Cutscenes, Bosses, Warnings)
        if (!priority) return;

        if (this.isSpeaking) {
            this.synth.cancel(); // Interrupt current speech for priority
        }
        
        // Visual
        this.dialogueBox.style.display = 'flex';
        this.dialogueText.innerText = "";
        
        // Typewriter effect
        let i = 0;
        const typeInterval = setInterval(() => {
            this.dialogueText.innerText += text.charAt(i);
            i++;
            if (i >= text.length) clearInterval(typeInterval);
        }, 30);
        
        // Audio
        const utter = new SpeechSynthesisUtterance(text);
        if (this.voice) utter.voice = this.voice;
        
        // Tweak for robotic feel
        utter.pitch = 1.1; // Slightly higher
        utter.rate = 1.05; // Slightly faster, crisp
        utter.volume = 1.0;
        
        utter.onend = () => {
            this.isSpeaking = false;
            setTimeout(() => {
                this.dialogueBox.style.display = 'none';
            }, 3000); // Hide after 3s
        };
        
        this.isSpeaking = true;
        this.synth.speak(utter);
    }
}

// Initialize AI globally
window.flux = window.flux || {};
window.addEventListener('DOMContentLoaded', () => {
    // Wait a bit to ensure DOM is ready
    setTimeout(() => {
        window.flux.ai = new FluxAI();
    }, 1000);
});

// ... existing HUD code ...
// --- HUD CACHE & STATE ---
const uiState = {
    cache: {},
    last: {
        hp: -1,
        ap: -1,
        shield: -1,
        ammo: -1,
        weapon: -1,
        reloading: null,
        combo: -1,
        shieldBroken: null
    },
    timeouts: {
        hpLag: null,
        apLag: null
    }
};

function initUICache() {
    uiState.cache = {
        hpBar: document.getElementById('hp-bar'),
        hpBarLag: document.getElementById('hp-bar-lag'),
        apBar: document.getElementById('ap-bar'),
        apBarLag: document.getElementById('ap-bar-lag'),
        weaponName: document.getElementById('weapon-name'),
        ammoCount: document.getElementById('ammo-count'),
        reloadMsg: document.getElementById('reload-msg'),
        shieldContainer: document.getElementById('shield-bar-container'),
        shieldBar: document.getElementById('shield-bar'),
        comboContainer: document.getElementById('combo-container'),
        comboText: document.getElementById('combo-count'),
        comboLabel: document.getElementById('combo-label'),
        styleRank: document.getElementById('style-rank'),
        xpBarFill: document.getElementById('xp-bar-fill'),
        xpLevelText: document.getElementById('xp-level-text')
    };
    
    // Create Shield Bar if missing
    if (!uiState.cache.shieldContainer) {
        const statusContainer = document.querySelector('.status-bars');
        if (statusContainer) {
            const sc = document.createElement('div');
            sc.id = 'shield-bar-container';
            sc.innerHTML = '<div id="shield-bar"></div>';
            statusContainer.appendChild(sc);
            uiState.cache.shieldContainer = sc;
            uiState.cache.shieldBar = document.getElementById('shield-bar');
        }
    }
}

function updateSwarmCounter(remaining) {
    let el = document.getElementById('swarm-counter');
    if (!el) {
        el = document.createElement('div');
        el.id = 'swarm-counter';
        el.style.position = 'absolute';
        el.style.top = '100px';
        el.style.left = '50%';
        el.style.transform = 'translateX(-50%)';
        el.style.fontFamily = "'Orbitron', sans-serif";
        el.style.fontSize = '32px';
        el.style.color = '#ff0055';
        el.style.textShadow = '0 0 10px #ff0055';
        el.style.zIndex = '50';
        el.style.fontWeight = '900';
        document.getElementById('ui-layer').appendChild(el);
    }
    
    el.style.display = 'block';
    el.innerText = `SWARM: ${remaining}`;
    
    // Pulse effect on update
    el.style.transform = 'translateX(-50%) scale(1.2)';
    setTimeout(() => el.style.transform = 'translateX(-50%) scale(1.0)', 100);
    
    if (remaining <= 0) {
        el.style.color = '#00ff9d';
        el.style.textShadow = '0 0 10px #00ff9d';
        setTimeout(() => { el.style.display = 'none'; }, 3000);
    }
}

function updateXpBar(current, max, level) {
    let barContainer = document.getElementById('xp-bar-container');
    if (!barContainer) {
        barContainer = document.createElement('div');
        barContainer.id = 'xp-bar-container';
        barContainer.style.cssText = 'position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 40%; height: 6px; background: rgba(0,0,0,0.5); border: 1px solid #555; z-index: 100;';
        
        const fill = document.createElement('div');
        fill.id = 'xp-bar-fill';
        fill.style.cssText = 'width: 0%; height: 100%; background: #ffd700; box-shadow: 0 0 10px #ffd700; transition: width 0.2s;';
        barContainer.appendChild(fill);
        
        const lvlText = document.createElement('div');
        lvlText.id = 'xp-level-text';
        lvlText.style.cssText = 'position: absolute; top: -25px; width: 100%; text-align: center; color: #ffd700; font-family: "Orbitron"; font-size: 14px; text-shadow: 0 0 5px #ffd700;';
        barContainer.appendChild(lvlText);
        
        document.body.appendChild(barContainer);
        
        uiState.cache.xpBarFill = fill;
        uiState.cache.xpLevelText = lvlText;
    }
    
    const pct = Math.min(100, (current / max) * 100);
    if (uiState.cache.xpBarFill) uiState.cache.xpBarFill.style.width = `${pct}%`;
    if (uiState.cache.xpLevelText) uiState.cache.xpLevelText.innerText = `SYNC LEVEL ${level}`;
}

// Expose globally
window.flux.updateXpBar = updateXpBar;

function updateHUD(comboCount) {
    const player = window.flux.player;
    if (!player) return;
    
    // Initialize cache if needed
    if (!uiState.cache.hpBar) initUICache();
    
    const c = uiState.cache;
    const l = uiState.last;

    // 1. HP Bar Logic
    if (Math.abs(player.hp - l.hp) > 0.1) {
        const hpPct = (player.hp / player.maxHp) * 100;
        if (c.hpBar) c.hpBar.style.width = `${hpPct}%`;
        
        if (player.hp < l.hp) {
            clearTimeout(uiState.timeouts.hpLag);
            uiState.timeouts.hpLag = setTimeout(() => {
                if (c.hpBarLag) c.hpBarLag.style.width = `${hpPct}%`;
            }, 500);
        } else {
            if (c.hpBarLag) c.hpBarLag.style.width = `${hpPct}%`;
        }
        l.hp = player.hp;
    }

    // 2. AP Bar Logic
    if (Math.abs(player.ap - l.ap) > 0.1) {
        const apPct = (player.ap / 50) * 100;
        if (c.apBar) c.apBar.style.width = `${apPct}%`;
        
        if (player.ap < l.ap) {
            clearTimeout(uiState.timeouts.apLag);
            uiState.timeouts.apLag = setTimeout(() => {
                if (c.apBarLag) c.apBarLag.style.width = `${apPct}%`;
            }, 500);
        } else {
            if (c.apBarLag) c.apBarLag.style.width = `${apPct}%`;
        }
        l.ap = player.ap;
    }

    // 3. Weapon Info
    const weaponChanged = (player.currentWeapon !== l.weapon) || (player.currentStyle !== l.style);
    const ammoChanged = (player.ammo !== l.ammo);
    
    if (weaponChanged || ammoChanged) {
        if (c.weaponName && c.ammoCount) {
            if (player.currentWeapon === player.WEAPON_MELEE) {
                let styleName = "KATANA";
                if (player.currentStyle === 1) styleName = "DAGGER";
                if (player.currentStyle === 2) styleName = "GREATSWORD";
                c.weaponName.innerText = styleName;
                c.ammoCount.innerText = "‚àû";
                c.ammoCount.style.color = "#aaa";
            } else if (player.currentWeapon === player.WEAPON_BEAM) {
                c.weaponName.innerText = "BEAM RIFLE";
                c.ammoCount.innerText = player.ammo;
                c.ammoCount.style.color = (player.ammo > 0) ? "#00f3ff" : "#ff0055";
            } else {
                c.weaponName.innerText = "AVENGER";
                c.ammoCount.innerText = player.ammo;
                c.ammoCount.style.color = (player.ammo > 0) ? "#00ff9d" : "#ff0055";
            }
        }
        l.weapon = player.currentWeapon;
        l.style = player.currentStyle;
        l.ammo = player.ammo;
    }
    
    if (player.isReloading !== l.reloading) {
        if (c.reloadMsg) {
            if (player.isReloading) c.reloadMsg.classList.remove('hidden');
            else c.reloadMsg.classList.add('hidden');
        }
        l.reloading = player.isReloading;
    }
    
    // 4. Shield Bar Logic
    if (c.shieldContainer) {
        if (player.isShieldBroken !== l.shieldBroken || Math.abs(player.shieldHp - l.shield) > 1.0) {
            if (player.isShieldBroken) {
                c.shieldContainer.classList.remove('active');
            } else if (player.shieldHp < player.shieldMaxHp) {
                c.shieldContainer.classList.add('active');
                if(c.shieldBar) c.shieldBar.style.width = (player.shieldHp / player.shieldMaxHp * 100) + '%';
            } else {
                c.shieldContainer.classList.remove('active');
            }
            l.shieldBroken = player.isShieldBroken;
            l.shield = player.shieldHp;
        }
    }
    
    // 5. Combo System
    const currentCombo = comboCount !== undefined ? comboCount : window.flux.comboCount || 0;
    if (currentCombo !== l.combo) {
        if (currentCombo > 0) {
            if (c.comboContainer) c.comboContainer.classList.add('active');
            if (c.comboText) c.comboText.innerText = currentCombo;
            
            const styleRanks = ["D", "C", "B", "A", "S", "SS", "SSS"];
            let rankIndex = 0;
            if (currentCombo > 5) rankIndex = 1; 
            if (currentCombo > 10) rankIndex = 2; 
            if (currentCombo > 20) rankIndex = 3; 
            if (currentCombo > 30) rankIndex = 4; 
            if (currentCombo > 45) rankIndex = 5; 
            if (currentCombo > 60) rankIndex = 6; 
            
            const rank = styleRanks[rankIndex];
            if (c.styleRank) {
                c.styleRank.innerText = rank;
                c.styleRank.className = `rank-${rank.toLowerCase()}`;
            }
            
            if (currentCombo > 15) {
                 if(c.comboText) {
                     c.comboText.style.color = '#ff0055';
                     c.comboText.style.textShadow = '0 0 20px #ff0055';
                 }
                 if(c.comboLabel) c.comboLabel.innerText = "OVERDRIVE";
            } else {
                 if(c.comboText) {
                     c.comboText.style.color = '#00f3ff';
                     c.comboText.style.textShadow = '0 0 15px var(--neon-blue)';
                 }
                 if(c.comboLabel) c.comboLabel.innerText = "HITS";
            }
            
            if(c.comboText) {
                c.comboText.style.transform = 'scale(1.5)';
                setTimeout(() => { if(c.comboText) c.comboText.style.transform = 'scale(1)'; }, 50);
            }
        } else {
            if (c.comboContainer) c.comboContainer.classList.remove('active');
        }
        l.combo = currentCombo;
    }
}

// --- MENU INITIALIZATION ---
function initUI(game) {
    initUICache(); // Initialize cache immediately
    
    const btnMenu = document.getElementById('btn-menu');
    const mainMenu = document.getElementById('main-menu');
    const btnQuit = document.getElementById('menu-quit');
    const btnMechs = document.getElementById('menu-mechs');
    const btnOptions = document.getElementById('menu-options');
    const bestiaryMenu = document.getElementById('bestiary-menu');
    const btnBestiaryBack = document.getElementById('bestiary-back');
    const btnBestiaryNext = document.getElementById('bestiary-next');
    const btnBestiaryPrev = document.getElementById('bestiary-prev');
    const optionsMenu = document.getElementById('options-menu');
    const btnOptBack = document.getElementById('opt-back');
    const btnOptLayout = document.getElementById('opt-layout');
    const hudEditor = document.getElementById('hud-editor');
    const btnEditorClose = document.getElementById('editor-close');
    const btnEditorSave = document.getElementById('editor-save');
    const btnEditorLoad = document.getElementById('editor-load');
    const btnEditorReset = document.getElementById('editor-reset');
    const fileInput = document.getElementById('layout-file-input');
    
    // --- PERFORMANCE TOGGLE BUTTON ---
    const perfBtn = document.createElement('button');
    perfBtn.className = 'menu-btn small';
    perfBtn.innerText = 'POST-PROCESS: ON';
    perfBtn.style.marginTop = '10px';
    perfBtn.addEventListener('click', () => {
        if (game.setQuality) {
            const newQuality = game.enablePostProcessing ? 'low' : 'high';
            game.setQuality(newQuality);
            perfBtn.innerText = `POST-PROCESS: ${game.enablePostProcessing ? 'ON' : 'OFF'}`;
        } else {
            game.enablePostProcessing = !game.enablePostProcessing;
            perfBtn.innerText = `POST-PROCESS: ${game.enablePostProcessing ? 'ON' : 'OFF'}`;
        }
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });
    const optContent = optionsMenu.querySelector('.modal-content');
    if(optContent) optContent.insertBefore(perfBtn, btnOptBack);

    // Event Listeners
    if(btnMenu) btnMenu.addEventListener('click', () => {
        game.isPaused = true;
        mainMenu.classList.remove('hidden');
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    if(btnQuit) btnQuit.addEventListener('click', () => {
        game.isPaused = false;
        mainMenu.classList.add('hidden');
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    if(btnMechs) btnMechs.addEventListener('click', () => {
        mainMenu.classList.add('hidden');
        bestiaryMenu.classList.remove('hidden');
        openBestiary(game);
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    if(btnBestiaryBack) btnBestiaryBack.addEventListener('click', () => {
        bestiaryMenu.classList.add('hidden');
        mainMenu.classList.remove('hidden');
        closeBestiary(game);
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    if(btnBestiaryNext) btnBestiaryNext.addEventListener('click', () => {
        game.currentBestiaryIndex = (game.currentBestiaryIndex + 1) % game.bestiaryModels.length;
        updateBestiaryModel(game);
        if (window.flux.audio) window.flux.audio.play('ui_hover');
    });

    if(btnBestiaryPrev) btnBestiaryPrev.addEventListener('click', () => {
        game.currentBestiaryIndex = (game.currentBestiaryIndex - 1 + game.bestiaryModels.length) % game.bestiaryModels.length;
        updateBestiaryModel(game);
        if (window.flux.audio) window.flux.audio.play('ui_hover');
    });

    if(btnOptions) btnOptions.addEventListener('click', () => {
        mainMenu.classList.add('hidden');
        optionsMenu.classList.remove('hidden');
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    if(btnOptBack) btnOptBack.addEventListener('click', () => {
        optionsMenu.classList.add('hidden');
        mainMenu.classList.remove('hidden');
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    if(btnOptLayout) btnOptLayout.addEventListener('click', () => {
        optionsMenu.classList.add('hidden');
        hudEditor.classList.remove('hidden');
        game.input.setEditMode(true);
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });

    if(btnEditorClose) btnEditorClose.addEventListener('click', () => {
        hudEditor.classList.add('hidden');
        optionsMenu.classList.remove('hidden');
        game.input.setEditMode(false);
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });
    
    if(btnEditorSave) btnEditorSave.addEventListener('click', () => {
        saveButtonLayout();
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });
    
    if(btnEditorReset) btnEditorReset.addEventListener('click', () => {
        resetButtonLayout();
        if (window.flux.audio) window.flux.audio.play('ui_click');
    });
    
    if(btnEditorLoad) btnEditorLoad.addEventListener('click', () => {
        fileInput.click();
    });
    
    if(fileInput) fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const layout = JSON.parse(e.target.result);
                loadButtonLayout(layout);
                if (window.flux.audio) window.flux.audio.play('ui_click');
            } catch (err) {
                console.error("Failed to load layout", err);
            }
        };
        reader.readAsText(file);
    });
}

function openBestiary(game) {
    game.isBestiaryOpen = true;
    if (!game.bestiaryScene) {
        game.bestiaryScene = new THREE.Scene();
        game.bestiaryScene.background = new THREE.Color(0x050510);
        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        game.bestiaryScene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 2.0);
        dir.position.set(5, 5, 5);
        game.bestiaryScene.add(dir);
        game.bestiaryCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
        game.bestiaryCamera.position.set(0, 1, 4);
        game.bestiaryCamera.lookAt(0, 0, 0);
        
        // COMPLETE ENEMY LIST
        game.bestiaryModels = [
            { name: "JEHUTY (ORBITAL FRAME)", desc: "Advanced tactical suit. High mobility.", type: 'jehuty' },
            { name: "ANUBIS", desc: "Class S Threat. Unknown capabilities.", type: 'anubis' },
            { name: "GARGANTUA", desc: "Class A Threat. Massive firepower. Hyper-Armor.", type: 'gargantua' },
            { name: "LAG KNIGHT", desc: "Heavy shielded unit. Immune to frontal attacks.", type: 'lag_knight' },
            { name: "NEURAL ZEALOT", desc: "Cyber-cultist. Uses glitch attacks to disrupt HUD.", type: 'zealot' },
            { name: "SCYTHER MECH", desc: "High speed melee unit. Swarm tactics.", type: 'scyther' },
            { name: "HUNTER MECH", desc: "Agile quadruped. Flanking attacks.", type: 'hunter' },
            { name: "VECTOR STRIKER", desc: "Space superiority interceptor.", type: 'interceptor' },
            { name: "STANDARD DRONE", desc: "Common combat unit. Laser weaponry.", type: 'standard' },
            { name: "SNIPER DRONE", desc: "Long range unit. High damage railgun.", type: 'sniper' },
            { name: "ASSAULT DRONE", desc: "Aggressive close-range unit. Burst fire.", type: 'assault' },
            { name: "BOMBER DRONE", desc: "Heavy unit. Deploys explosive ordinance.", type: 'bomber' },
            { name: "SUPPORT DRONE", desc: "Repair unit. Heals allies.", type: 'support' }
        ];
    }
    if (!game.bestiaryRenderer) {
        const container = document.getElementById('bestiary-canvas-container');
        if (container) {
            game.bestiaryRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            game.bestiaryRenderer.setSize(container.clientWidth, container.clientHeight);
            game.bestiaryRenderer.setPixelRatio(window.devicePixelRatio);
            container.innerHTML = ''; 
            container.appendChild(game.bestiaryRenderer.domElement);
            const resizeObserver = new ResizeObserver(() => {
                if (game.bestiaryRenderer && container) {
                    game.bestiaryRenderer.setSize(container.clientWidth, container.clientHeight);
                    if (game.bestiaryCamera) {
                        game.bestiaryCamera.aspect = container.clientWidth / container.clientHeight;
                        game.bestiaryCamera.updateProjectionMatrix();
                    }
                }
            });
            resizeObserver.observe(container);
        }
    }
    updateBestiaryModel(game);
}

function closeBestiary(game) {
    game.isBestiaryOpen = false;
    if (game.bestiaryModel) {
        game.bestiaryScene.remove(game.bestiaryModel);
        game.bestiaryModel = null;
    }
}

function updateBestiaryModel(game) {
    if (game.bestiaryModel) game.bestiaryScene.remove(game.bestiaryModel);
    const data = game.bestiaryModels[game.currentBestiaryIndex];
    document.getElementById('bestiary-label').innerText = data.name;
    document.getElementById('bestiary-desc').innerText = data.desc;
    
    if (typeof AssetFactory !== 'undefined') {
        if (data.type === 'jehuty') {
            if (typeof PlayerMesh !== 'undefined' && PlayerMesh.createStandalone) {
                game.bestiaryModel = PlayerMesh.createStandalone();
                game.bestiaryModel.scale.set(1, 1, 1);
                game.bestiaryModel.position.set(0, -1.5, 0); 
            } else {
                game.bestiaryModel = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshBasicMaterial({color:0x00ffff}));
            }
        } else if (data.type === 'anubis') {
            game.bestiaryModel = AssetFactory.createAnubisBoss();
            game.bestiaryModel.scale.set(0.8, 0.8, 0.8);
            game.bestiaryModel.position.set(0, -1.0, 0);
        } else if (data.type === 'gargantua') {
            game.bestiaryModel = AssetFactory.createMechDrone();
            game.bestiaryModel.scale.set(2, 2, 2);
             game.bestiaryModel.traverse((child) => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(0xaa00aa);
                }
            });
            game.bestiaryModel.position.set(0, 0, 0);
        } else if (data.type === 'scyther') {
            game.bestiaryModel = AssetFactory.createScytherMech();
            game.bestiaryModel.scale.set(1.2, 1.2, 1.2);
            game.bestiaryModel.position.set(0, 0, 0);
        } else if (data.type === 'hunter') {
            game.bestiaryModel = AssetFactory.createHunter();
            game.bestiaryModel.scale.set(1, 1, 1);
            game.bestiaryModel.position.set(0, 0, 0);
        } else if (data.type === 'lag_knight') {
            if (AssetFactory.createLagKnight) {
                game.bestiaryModel = AssetFactory.createLagKnight();
                game.bestiaryModel.scale.set(1.2, 1.2, 1.2);
                game.bestiaryModel.position.set(0, -0.5, 0);
            }
        } else if (data.type === 'zealot') {
            if (AssetFactory.createNeuralZealot) {
                game.bestiaryModel = AssetFactory.createNeuralZealot();
                game.bestiaryModel.scale.set(1.2, 1.2, 1.2);
                game.bestiaryModel.position.set(0, -0.5, 0);
            }
        } else if (data.type === 'interceptor') {
            if (typeof SpaceAssetFactory !== 'undefined' && SpaceAssetFactory.createSpaceInterceptor) {
                game.bestiaryModel = SpaceAssetFactory.createSpaceInterceptor();
                game.bestiaryModel.scale.set(0.5, 0.5, 0.5);
                game.bestiaryModel.rotation.x = Math.PI/4; // Tilt to show shape
                game.bestiaryModel.position.set(0, 0, 0);
            }
        } else {
            // Standard Drones
            game.bestiaryModel = AssetFactory.createMechDrone();
            let color = 0xffffff;
            if (data.type === 'standard') color = 0xff4444;
            if (data.type === 'sniper') color = 0x4444ff;
            if (data.type === 'assault') color = 0xffaa00;
            if (data.type === 'bomber') color = 0x880000;
            if (data.type === 'support') color = 0x00ff44;
            
            game.bestiaryModel.traverse((child) => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(color);
                }
            });
            game.bestiaryModel.position.set(0, 0, 0);
        }
    } else {
        // Fallback
        game.bestiaryModel = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color:0xff0000}));
        game.bestiaryModel.position.set(0, 0, 0);
    }
    
    if (game.bestiaryModel) {
        game.bestiaryScene.add(game.bestiaryModel);
    }
}

function saveButtonLayout() {
    const buttons = document.querySelectorAll('.btn');
    const layout = {};
    buttons.forEach(btn => {
        layout[btn.id] = {
            left: btn.style.left,
            top: btn.style.top,
            right: btn.style.right,
            bottom: btn.style.bottom,
            scale: btn.dataset.scale || 1.0
        };
    });
    const blob = new Blob([JSON.stringify(layout)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "flux_layout.json";
    a.click();
}

function loadButtonLayout(layout) {
    for (const id in layout) {
        const btn = document.getElementById(id);
        if (btn) {
            const pos = layout[id];
            btn.style.left = pos.left;
            btn.style.top = pos.top;
            btn.style.right = pos.right;
            btn.style.bottom = pos.bottom;
            if (pos.scale) {
                btn.style.transform = `scale(${pos.scale})`;
                btn.dataset.scale = pos.scale;
            }
        }
    }
}

function resetButtonLayout() {
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(btn => {
        btn.style.left = '';
        btn.style.top = '';
        btn.style.right = '';
        btn.style.bottom = '';
        btn.style.transform = '';
        btn.dataset.scale = 1.0;
    });
}</script>
    
    <!-- NEW: Space Enemies Module -->
    <script>/**
 * SPACE ENEMIES MODULE
 * Contains AI classes for Space Mode entities.
 * - SpaceTurret: Stationary defense.
 * - SpaceSwarmBoid: Simple flocking enemy.
 * - SpaceInterceptor: Advanced dogfighting enemy.
 * UPDATED: Added XP Reward on Death.
 */

class SpaceTurret {
    constructor(parent, position, scene) {
        this.scene = scene;
        this.active = true;
        this.fireTimer = Math.random() * 2.0;
        this.fireRate = 0.8; // Seconds
        this.range = 800; // Increased range
        
        // Mesh Group
        this.mesh = new THREE.Group();
        this.mesh.position.copy(position);
        parent.add(this.mesh);
        
        // Base
        const baseGeo = new THREE.CylinderGeometry(2, 2.5, 1, 8);
        const baseMat = new THREE.MeshStandardMaterial({ color: 0x444455 });
        this.base = new THREE.Mesh(baseGeo, baseMat);
        this.mesh.add(this.base);
        
        // Head (Rotates)
        this.head = new THREE.Group();
        this.head.position.y = 1.0;
        this.mesh.add(this.head);
        
        const domeGeo = new THREE.SphereGeometry(1.5, 8, 8, 0, Math.PI * 2, 0, Math.PI/2);
        const domeMat = new THREE.MeshStandardMaterial({ color: 0x666677 });
        this.dome = new THREE.Mesh(domeGeo, domeMat);
        this.head.add(this.dome);
        
        // Barrels
        const barrelGeo = new THREE.CylinderGeometry(0.3, 0.3, 4);
        barrelGeo.rotateX(Math.PI/2);
        barrelGeo.translate(0, 0, 2);
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        
        this.barrelL = new THREE.Mesh(barrelGeo, barrelMat);
        this.barrelL.position.x = -0.8;
        this.head.add(this.barrelL);
        
        this.barrelR = new THREE.Mesh(barrelGeo, barrelMat);
        this.barrelR.position.x = 0.8;
        this.head.add(this.barrelR);
        
        // Add to enemy logic
        this.mesh.userData = {
            type: 'enemy',
            enemyType: 'turret',
            hp: 200,
            maxHp: 200,
            isDead: false
        };
    }
    
    update(dt, playerPos, playerVel) {
        if (this.mesh.userData.hp <= 0) {
            if (!this.mesh.userData.isDead) {
                this.mesh.userData.isDead = true;
                this.mesh.visible = false;
                if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(this.mesh.getWorldPosition(new THREE.Vector3()));
                if (window.flux.audio) window.flux.audio.play('drone_death');
                
                if (window.flux.awardXp) window.flux.awardXp(50); // Reward for kill
            }
            return;
        }
        
        const worldPos = new THREE.Vector3();
        this.mesh.getWorldPosition(worldPos);
        
        const dist = worldPos.distanceTo(playerPos);
        
        if (dist < this.range) {
            // Predictive Aiming
            const projectileSpeed = 100;
            const timeToImpact = dist / projectileSpeed;
            const predictedPos = playerPos.clone().add(playerVel.clone().multiplyScalar(timeToImpact));
            
            // Track Player
            this.head.lookAt(predictedPos);
            
            // Fire
            this.fireTimer -= dt;
            if (this.fireTimer <= 0) {
                this.fire(worldPos, predictedPos);
                this.fireTimer = this.fireRate + Math.random() * 0.5;
            }
        }
    }
    
    fire(origin, target) {
        // Calculate direction with slight spread
        const dir = new THREE.Vector3().subVectors(target, origin).normalize();
        dir.x += (Math.random() - 0.5) * 0.05;
        dir.y += (Math.random() - 0.5) * 0.05;
        dir.z += (Math.random() - 0.5) * 0.05;
        dir.normalize();
        
        // Spawn Projectile (Use global helper)
        if (window.flux.spawnEnemyProjectile) {
            // Fire from barrel tips (approximate world pos)
            const tipL = origin.clone().add(dir.clone().multiplyScalar(4)); 
            window.flux.spawnEnemyProjectile(tipL, dir);
        }
    }
}

class SpaceSwarmBoid {
    constructor(scene, parentGroup, position) {
        this.scene = scene;
        
        const geo = new THREE.ConeGeometry(0.5, 2.0, 4);
        geo.rotateX(Math.PI/2);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(position);
        
        this.mesh.userData = {
            type: 'enemy',
            enemyType: 'swarm',
            hp: 30,
            maxHp: 30,
            isDead: false,
            velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20
            ),
            attackTimer: Math.random() * 5
        };
        
        parentGroup.add(this.mesh);
    }
    
    update(dt, playerPos) {
        if (this.mesh.userData.hp <= 0) {
            if (this.mesh.visible) {
                this.mesh.visible = false;
                this.mesh.userData.isDead = true;
                if (window.flux.spawnParticles) window.flux.spawnParticles(this.mesh.position, 10, 0xff0000, 10);
                if (window.flux.spawnSpaceExplosion) window.flux.spawnSpaceExplosion(this.mesh.position, 0.5);
                
                if (window.flux.awardXp) window.flux.awardXp(10); // Small reward
            }
            return;
        }
        
        const toPlayer = new THREE.Vector3().subVectors(playerPos, this.mesh.position);
        const dist = toPlayer.length();
        
        // Boid Logic: Swarm towards player but orbit close
        if (dist > 50) {
            toPlayer.normalize().multiplyScalar(20.0 * dt);
            this.mesh.userData.velocity.add(toPlayer);
        } else {
            const cross = new THREE.Vector3().crossVectors(toPlayer, new THREE.Vector3(0,1,0)).normalize();
            this.mesh.userData.velocity.add(cross.multiplyScalar(10.0 * dt));
        }
        
        // Attack
        this.mesh.userData.attackTimer -= dt;
        if (this.mesh.userData.attackTimer <= 0 && dist < 300) {
            if (window.flux.spawnEnemyProjectile) {
                const dir = toPlayer.normalize();
                window.flux.spawnEnemyProjectile(this.mesh.position, dir);
            }
            this.mesh.userData.attackTimer = 3.0 + Math.random() * 2.0;
        }
        
        // Physics
        this.mesh.userData.velocity.clampLength(0, 60);
        this.mesh.position.add(this.mesh.userData.velocity.clone().multiplyScalar(dt));
        this.mesh.lookAt(this.mesh.position.clone().add(this.mesh.userData.velocity));
    }
}

class SpaceInterceptor {
    constructor(scene, parentGroup, position) {
        this.scene = scene;
        
        if (typeof SpaceAssetFactory !== 'undefined' && SpaceAssetFactory.createSpaceInterceptor) {
            this.mesh = SpaceAssetFactory.createSpaceInterceptor();
        } else {
            // Fallback
            const geo = new THREE.BoxGeometry(2, 1, 4);
            const mat = new THREE.MeshStandardMaterial({ color: 0x5555ff });
            this.mesh = new THREE.Mesh(geo, mat);
        }
        
        this.mesh.position.copy(position);
        
        this.mesh.userData = {
            type: 'enemy',
            enemyType: 'interceptor',
            hp: 150,
            maxHp: 150,
            isDead: false,
            velocity: new THREE.Vector3(),
            state: 'CHASE', // CHASE, EVADE, ATTACK_RUN, EVADE_ROLL
            stateTimer: 0
        };
        
        parentGroup.add(this.mesh);
        
        this.speed = 80;
        this.turnSpeed = 2.0;
    }
    
    update(dt, playerPos, playerVel) {
        if (this.mesh.userData.hp <= 0) {
            if (!this.mesh.userData.isDead) {
                this.mesh.userData.isDead = true;
                this.mesh.visible = false;
                if (window.flux.spawnSpaceExplosion) window.flux.spawnSpaceExplosion(this.mesh.position, 2.0);
                if (window.flux.audio) window.flux.audio.play('drone_death');
                
                if (window.flux.awardXp) window.flux.awardXp(30); // Medium reward
            }
            return;
        }
        
        const data = this.mesh.userData;
        data.stateTimer -= dt;
        
        const toPlayer = new THREE.Vector3().subVectors(playerPos, this.mesh.position);
        const dist = toPlayer.length();
        const dirToPlayer = toPlayer.clone().normalize();
        
        // State Machine
        if (data.state === 'CHASE') {
            // Try to get behind player
            const behindPos = playerPos.clone().sub(playerVel.clone().normalize().multiplyScalar(50));
            const toBehind = new THREE.Vector3().subVectors(behindPos, this.mesh.position).normalize();
            
            // Accelerate
            data.velocity.add(toBehind.multiplyScalar(this.speed * dt));
            
            if (dist < 100 && data.stateTimer <= 0) {
                data.state = 'ATTACK_RUN';
                data.stateTimer = 2.0;
            }
        } 
        else if (data.state === 'ATTACK_RUN') {
            // Fly straight at player and fire
            data.velocity.add(dirToPlayer.multiplyScalar(this.speed * 1.5 * dt));
            
            if (Math.random() > 0.9) {
                if (window.flux.spawnEnemyProjectile) {
                    window.flux.spawnEnemyProjectile(this.mesh.position, dirToPlayer);
                }
            }
            
            if (dist < 20 || data.stateTimer <= 0) {
                // Randomly choose Evade type
                if (Math.random() > 0.5) {
                    data.state = 'EVADE_ROLL';
                    data.stateTimer = 1.0;
                } else {
                    data.state = 'EVADE';
                    data.stateTimer = 1.5;
                }
            }
        }
        else if (data.state === 'EVADE') {
            // Break away
            const evadeDir = new THREE.Vector3().crossVectors(dirToPlayer, new THREE.Vector3(0,1,0)).normalize();
            data.velocity.add(evadeDir.multiplyScalar(this.speed * 2.0 * dt));
            
            if (data.stateTimer <= 0) {
                data.state = 'CHASE';
                data.stateTimer = 5.0;
            }
        }
        else if (data.state === 'EVADE_ROLL') {
            // Barrel Roll
            const evadeDir = new THREE.Vector3().crossVectors(dirToPlayer, new THREE.Vector3(1,0,0)).normalize();
            data.velocity.add(evadeDir.multiplyScalar(this.speed * 1.5 * dt));
            
            // Visual Roll
            this.mesh.rotateZ(10 * dt);
            
            if (data.stateTimer <= 0) {
                data.state = 'CHASE';
                data.stateTimer = 3.0;
            }
        }
        
        // Physics
        data.velocity.multiplyScalar(0.98); // Drag
        data.velocity.clampLength(0, 120); // Max speed
        this.mesh.position.add(data.velocity.clone().multiplyScalar(dt));
        
        // Rotation (Bank into turns)
        if (data.state !== 'EVADE_ROLL') {
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), data.velocity.clone().normalize());
            this.mesh.quaternion.slerp(targetQuat, this.turnSpeed * dt);
        }
        
        // Engine Trail
        if (window.flux.spawnParticles && Math.random() > 0.5) {
            window.flux.spawnParticles(this.mesh.position, 1, 0x5555ff, 5);
        }
    }
}</script>

    <!-- NEW: Space System -->
    <script>/**
 * SPACE SYSTEM - ARCHITECTURAL IMPLEMENTATION
 * Based on 'space.txt' Blueprint.
 * Handles:
 * 1. Space Environment (Procedural Stars, Earth, Solar System)
 * 2. Cinematic Launch Sequence (Ground -> Space Transition)
 * 3. Atmospheric Effects (Fade, Shockwave)
 * 4. Mission System (Beacons, Dynamic Objectives)
 * 5. 6DOF Camera Tracking & Barrel Rolls
 * 6. Space Dust & Thruster VFX
 * 7. Space Radar & HUD & Lock Indicators
 * UPDATED: Added Mission Beacons ON EARTH SURFACE.
 * UPDATED: Added "Station Defense" and "Asteroid Field" missions.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes.
 * UPDATED: Implemented Vector Puzzle Logic (Orbital Stabilization).
 * UPDATED: Added Retrieval Mission (Drifting Data Core).
 * UPDATED: Spawns Interceptors and Swarm Boids upon entering space.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _ssVec1 = new THREE.Vector3();
const _ssVec2 = new THREE.Vector3();
const _ssVec3 = new THREE.Vector3();
const _ssForward = new THREE.Vector3();
const _ssUp = new THREE.Vector3();
const _ssRight = new THREE.Vector3();
const _ssQuat = new THREE.Quaternion();

class SpaceSystem {
    constructor(scene, camera, player, game) {
        this.scene = scene;
        this.camera = camera;
        this.player = player;
        this.game = game;
        
        this.active = false;
        this.launching = false;
        this.launchTimer = 0;
        this.victoryTriggered = false;
        this.destructionTimer = 0; 
        
        // Config
        this.earthRadius = 1000;
        this.orbitAltitude = 1200;
        this.reEntryAltitude = 1050; // Trigger altitude
        this.reEntryCooldown = 0; // Prevent instant re-entry after launch
        
        // Groups
        this.spaceGroup = new THREE.Group();
        this.spaceGroup.visible = false;
        this.scene.add(this.spaceGroup);
        
        this.spaceEnemyGroup = new THREE.Group();
        this.spaceGroup.add(this.spaceEnemyGroup);
        
        this.beaconGroup = new THREE.Group();
        this.spaceGroup.add(this.beaconGroup);
        
        // Swarm System
        this.swarmBoids = [];
        this.interceptors = [];
        this.capitalShip = null;
        this.station = null; // New Mission Asset
        this.turrets = [];
        
        // Mission State
        this.currentMission = null; // 'CAPITAL', 'ASTEROID', 'DEFENSE', 'VECTOR_PUZZLE', 'RETRIEVAL', null
        this.missionData = {}; // Store mission specific counters
        this.beacons = [];
        
        // Vector Puzzle State
        this.vectorPuzzleTarget = null;
        this.vectorPuzzleTimer = 0;
        this.vectorPuzzleSuccessTime = 3.0; // Hold for 3 seconds
        
        // Retrieval Mission State
        this.retrievalTarget = null;
        
        // Boss Logic
        this.mainCannonTimer = 0;
        this.mainCannonState = 'IDLE'; 
        
        // VFX
        this.dustParticles = null;
        this.dustPositions = null;
        this.nebulaMesh = null;
        this.asteroids = [];
        this.collidableAsteroids = []; // For collision checks
        this.speedLines = null;
        this.wingTrails = { left: null, right: null };
        
        // Radar
        this.radarEl = null;
        this.radarBlips = [];
        
        // HUD Elements
        this.hudOverlay = null;
        this.progradeMarker = null;
        this.retrogradeMarker = null;
        this.flightModeIndicator = null;
        this.lockIndicators = []; 
        this.objectiveContainer = null;
        
        this.initEnvironment();
        this.initSpaceDust();
        this.initRadar();
        this.initVFX();
    }
    
    initRadar() {
        if (!document.getElementById('radar-style')) {
            const style = document.createElement('style');
            style.id = 'radar-style';
            style.innerHTML = `
                #space-radar {
                    position: absolute;
                    bottom: 120px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 140px;
                    height: 140px;
                    border: 2px solid var(--neon-blue);
                    border-radius: 50%;
                    background: rgba(0, 10, 20, 0.6);
                    z-index: 35;
                    overflow: hidden;
                    pointer-events: none;
                    display: none;
                    box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
                }
                #space-radar::after {
                    content: '';
                    position: absolute;
                    top: 50%; left: 50%;
                    width: 100%; height: 1px;
                    background: rgba(0, 243, 255, 0.3);
                    transform: translate(-50%, -50%);
                }
                #space-radar::before {
                    content: '';
                    position: absolute;
                    top: 50%; left: 50%;
                    width: 1px; height: 100%;
                    background: rgba(0, 243, 255, 0.3);
                    transform: translate(-50%, -50%);
                }
                .radar-blip {
                    position: absolute;
                    width: 4px;
                    height: 4px;
                    background: #ff0055;
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    box-shadow: 0 0 4px #ff0055;
                }
                .radar-blip.capital {
                    width: 8px; height: 8px;
                    background: #ffaa00;
                    border: 1px solid white;
                }
                .radar-blip.beacon {
                    width: 6px; height: 6px;
                    background: #00ff00;
                    border: 1px solid #00ff00;
                    box-shadow: 0 0 8px #00ff00;
                    animation: blink 1s infinite;
                }
                .radar-player {
                    position: absolute;
                    top: 50%; left: 50%;
                    width: 0; height: 0;
                    border-left: 4px solid transparent;
                    border-right: 4px solid transparent;
                    border-bottom: 8px solid white;
                    transform: translate(-50%, -50%);
                    filter: drop-shadow(0 0 2px white);
                }
                #mission-complete {
                    position: absolute;
                    top: 50%; left: 50%;
                    transform: translate(-50%, -50%);
                    font-family: 'Orbitron', sans-serif;
                    font-size: 48px;
                    color: #00ff9d;
                    text-shadow: 0 0 20px #00ff9d;
                    z-index: 10000;
                    opacity: 0;
                    transition: opacity 2s;
                    pointer-events: none;
                    text-align: center;
                }
                #mission-complete.visible { opacity: 1; }
                .sub-text { font-size: 24px; color: white; margin-top: 10px; }
                
                #warning-msg {
                    position: absolute;
                    top: 20%; left: 50%;
                    transform: translateX(-50%);
                    color: #ff0055;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 24px;
                    text-shadow: 0 0 10px #ff0000;
                    animation: blink 0.2s infinite;
                    display: none;
                    z-index: 50;
                }
                
                .beacon-label {
                    position: absolute;
                    color: white;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 12px;
                    background: rgba(0,0,0,0.7);
                    padding: 4px 8px;
                    border: 1px solid white;
                    pointer-events: none;
                    transform: translate(-50%, -100%);
                    white-space: nowrap;
                }
            `;
            document.head.appendChild(style);
        }

        const radar = document.createElement('div');
        radar.id = 'space-radar';
        radar.innerHTML = '<div class="radar-player"></div>';
        
        const uiLayer = document.getElementById('ui-layer');
        if (uiLayer) {
            uiLayer.appendChild(radar);
            const warn = document.createElement('div');
            warn.id = 'warning-msg';
            warn.innerText = "WARNING: HIGH ENERGY DETECTED";
            uiLayer.appendChild(warn);
        }
        
        this.radarEl = radar;
        
        for(let i=0; i<30; i++) {
            const blip = document.createElement('div');
            blip.className = 'radar-blip';
            blip.style.display = 'none';
            radar.appendChild(blip);
            this.radarBlips.push(blip);
        }
    }
    
    initEnvironment() {
        // 1. Procedural Starfield
        const starGeo = new THREE.BufferGeometry();
        const starCount = 5000;
        const starPos = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);
        
        for(let i=0; i<starCount; i++) {
            const r = 3000 + Math.random() * 3000;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            starPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            starPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            starPos[i*3+2] = r * Math.cos(phi);
            
            starSizes[i] = 10.0 + Math.random() * 20.0; 
        }
        
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
        
        const starMat = new THREE.PointsMaterial({
            color: 0xffffff,
            map: TextureGen.createSoftSprite(), 
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true, 
            depthWrite: false 
        });
        
        this.starField = new THREE.Points(starGeo, starMat);
        this.spaceGroup.add(this.starField);
        
        // 2. Earth (Target for Re-entry)
        const earthGeo = new THREE.SphereGeometry(this.earthRadius, 64, 64);
        const earthTex = TextureGen.createPlanetTexture(1024, 'earth');
        const earthMat = new THREE.MeshPhongMaterial({
            map: earthTex,
            emissive: 0x000011,
            specular: 0x111111,
            shininess: 10
        });
        
        this.earth = new THREE.Mesh(earthGeo, earthMat);
        // Earth is below the player at start (y = -1200)
        this.earth.position.y = -this.earthRadius - 200;
        this.spaceGroup.add(this.earth);
        
        const atmoGeo = new THREE.SphereGeometry(this.earthRadius * 1.05, 64, 64);
        const atmoMat = new THREE.MeshBasicMaterial({
            color: 0x44aaff,
            transparent: true,
            opacity: 0.2,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending
        });
        this.atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
        this.earth.add(this.atmosphere);
        
        this.initNebula();
        this.initSolarSystem();
    }
    
    initSolarSystem() {
        // Sun
        const sunGeo = new THREE.SphereGeometry(500, 32, 32);
        const sunTex = TextureGen.createPlanetTexture(512, 'sun');
        const sunMat = new THREE.MeshBasicMaterial({ map: sunTex, color: 0xffaa00, fog: false });
        this.sun = new THREE.Mesh(sunGeo, sunMat);
        this.sun.position.set(2000, 4000, 2000); 
        this.spaceGroup.add(this.sun);
        
        const spriteMat = new THREE.SpriteMaterial({ map: TextureGen.createSoftSprite(), color: 0xffaa00, blending: THREE.AdditiveBlending });
        const sunGlow = new THREE.Sprite(spriteMat);
        sunGlow.scale.set(3000, 3000, 1.0);
        this.sun.add(sunGlow);
        this.sun.add(new THREE.PointLight(0xffaa00, 2.0, 10000));

        // Planets Helper
        const createPlanet = (name, size, pos, hasRing = false) => {
            const geo = new THREE.SphereGeometry(size, 32, 32);
            const tex = TextureGen.createPlanetTexture(512, name);
            const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8, metalness: 0.2 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            
            if (hasRing) {
                const ringGeo = new THREE.RingGeometry(size * 1.4, size * 2.2, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xccaa88, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                mesh.add(ring);
            }
            this.spaceGroup.add(mesh);
            return mesh;
        };

        this.mercury = createPlanet('mercury', 80, new THREE.Vector3(1800, 3800, 1800));
        this.venus = createPlanet('venus', 140, new THREE.Vector3(1500, 3500, 1500));
        this.moon = createPlanet('moon', 150, new THREE.Vector3(1500, 500, -1000));
        this.mars = createPlanet('mars', 200, new THREE.Vector3(-3000, 200, -4000));
        this.jupiter = createPlanet('jupiter', 600, new THREE.Vector3(5000, -1000, 3000));
        this.saturn = createPlanet('saturn', 500, new THREE.Vector3(7000, -500, -2000), true);
        this.uranus = createPlanet('uranus', 300, new THREE.Vector3(-6000, 1000, 5000));
        this.neptune = createPlanet('neptune', 300, new THREE.Vector3(-8000, -1000, -6000));
    }
    
    initNebula() {
        const count = 50;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        
        for(let i=0; i<count; i++) {
            pos[i*3] = (Math.random() - 0.5) * 3000;
            pos[i*3+1] = (Math.random() - 0.5) * 1500;
            pos[i*3+2] = -2000 + (Math.random() * 1500);
            
            const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
            colors[i*3] = color.r;
            colors[i*3+1] = color.g;
            colors[i*3+2] = color.b;
        }
        
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const mat = new THREE.PointsMaterial({
            size: 600,
            map: TextureGen.createSoftSprite(), 
            vertexColors: true,
            transparent: true,
            opacity: 0.15,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        
        this.nebulaMesh = new THREE.Points(geo, mat);
        this.spaceGroup.add(this.nebulaMesh);
    }
    
    initSpaceDust() {
        const count = 1000;
        const geo = new THREE.BufferGeometry();
        this.dustPositions = new Float32Array(count * 3);
        
        for(let i=0; i<count; i++) {
            this.dustPositions[i*3] = (Math.random() - 0.5) * 100;
            this.dustPositions[i*3+1] = (Math.random() - 0.5) * 100;
            this.dustPositions[i*3+2] = (Math.random() - 0.5) * 100;
        }
        
        geo.setAttribute('position', new THREE.BufferAttribute(this.dustPositions, 3));
        
        const mat = new THREE.PointsMaterial({
            color: 0xaaaaaa,
            size: 0.2,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        
        this.dustParticles = new THREE.Points(geo, mat);
        this.dustParticles.frustumCulled = false;
        this.spaceGroup.add(this.dustParticles);
    }
    
    initVFX() {
        if (typeof SpeedLineSystem !== 'undefined') {
            this.speedLines = new SpeedLineSystem(this.spaceGroup, 200);
        }
        
        if (typeof RibbonTrail !== 'undefined') {
            this.wingTrails.left = new RibbonTrail(this.spaceGroup, 30, 0.4, 0x00ffff);
            this.wingTrails.right = new RibbonTrail(this.spaceGroup, 30, 0.4, 0x00ffff);
        }
    }
    
    // --- NEW: MISSION BEACONS ON EARTH ---
    createMissionBeacon(type, position, color, labelText) {
        const group = new THREE.Group();
        
        // Calculate position on Earth's surface (radius ~1000)
        // We assume 'position' is a normalized direction vector or just coords to be normalized
        const surfacePos = position.clone().normalize().multiplyScalar(this.earthRadius);
        // Offset slightly so it's not buried
        surfacePos.add(position.clone().normalize().multiplyScalar(10));
        
        // Earth is at (0, -1200, 0)
        // So relative to space group origin (0,0,0), the beacon should be at earthPos + surfacePos
        const earthCenter = this.earth.position.clone();
        const finalPos = earthCenter.clone().add(surfacePos);
        
        group.position.copy(finalPos);
        
        // Point outward from Earth center
        group.lookAt(earthCenter); 
        group.rotateX(-Math.PI/2); // Align cylinder up with normal
        
        // Massive Beam extending into space
        const beamGeo = new THREE.CylinderGeometry(20, 20, 4000, 32, 1, true);
        beamGeo.translate(0, 2000, 0); // Pivot at base, extend up
        const beamMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const beam = new THREE.Mesh(beamGeo, beamMat);
        group.add(beam);
        
        // Core Beam
        const coreGeo = new THREE.CylinderGeometry(5, 5, 4000, 16, 1, true);
        coreGeo.translate(0, 2000, 0);
        const coreMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const core = new THREE.Mesh(coreGeo, coreMat);
        group.add(core);
        
        // Base Glow
        const glowGeo = new THREE.SphereGeometry(50, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        group.add(glow);
        
        // Create DOM Label
        const label = document.createElement('div');
        label.className = 'beacon-label';
        label.innerText = labelText;
        label.style.display = 'none';
        label.style.borderColor = '#' + color.toString(16).padStart(6, '0');
        label.style.textShadow = `0 0 10px #${color.toString(16).padStart(6, '0')}`;
        document.getElementById('ui-layer').appendChild(label);
        
        // Store stage type mapping
        let stageType = 'CITY';
        if (type === 'WASTELAND_MISSION') stageType = 'WASTELAND';
        if (type === 'ICE_MISSION') stageType = 'ICE';
        if (type === 'VOID_MISSION') stageType = 'VOID';
        
        group.userData = { type: 'beacon', missionType: type, stageType: stageType, labelElement: label };
        this.beaconGroup.add(group);
        this.beacons.push(group);
    }
    
    initMissions() {
        // Clear existing beacons
        this.beacons.forEach(b => {
            if (b.userData.labelElement) b.userData.labelElement.remove();
            this.beaconGroup.remove(b);
        });
        this.beacons = [];
        
        // 1. CITY (Top)
        this.createMissionBeacon('CITY_MISSION', new THREE.Vector3(0, 1, 0), 0x00aaff, "NEO TOKYO");
        
        // 2. WASTELAND (Side)
        this.createMissionBeacon('WASTELAND_MISSION', new THREE.Vector3(1, 0.2, 0), 0xffaa00, "SCORCHED EARTH");
        
        // 3. ICE (Other Side)
        this.createMissionBeacon('ICE_MISSION', new THREE.Vector3(-1, 0.2, 0), 0xaaddff, "FROZEN SECTOR");
        
        // 4. VOID (Back)
        this.createMissionBeacon('VOID_MISSION', new THREE.Vector3(0, 0.2, -1), 0xaa00ff, "VOID ZONE");
    }
    
    checkMissionTriggers() {
        // In space, we trigger landing by flying INTO the beam
        // Check distance to the beam axis or just proximity to the beacon base?
        // Let's do proximity to the beacon base for simplicity, but with a wide radius
        
        const pPos = this.player.mesh.position;
        
        for (let beacon of this.beacons) {
            // Simple distance check
            const dist = pPos.distanceTo(beacon.position);
            
            // If close enough (e.g. 300 units), trigger landing
            if (dist < 300) {
                if (this.reEntryCooldown <= 0) {
                    this.triggerReentrySequence(beacon.userData.stageType);
                }
                break;
            }
        }
    }
    
    startMission(type, position) {
        // Deprecated in favor of surface beacons
    }
    
    spawnDefenseWave(center) {
        // ... existing code ...
    }
    
    updateDefenseMission(dt) {
        // ... existing code ...
    }
    
    triggerLaunch() {
        if (this.launching || this.active) return;
        
        console.log("SpaceSystem: Initiating Launch Sequence...");
        this.launching = true;
        this.launchTimer = 0;
        this.reEntryCooldown = 5.0; // 5 seconds grace period before re-entry possible
        
        // --- AGGRESSIVE CLEANUP OF GROUND EVENTS ---
        
        // 1. Stop Spawn System (Swarm Event)
        if (window.flux.spawnSystem) {
            if (window.flux.spawnSystem.forceStop) {
                window.flux.spawnSystem.forceStop();
            }
        }
        
        // 2. Clear Ground Enemies (Redundant but safe)
        if (window.flux.enemies) {
            window.flux.enemies.forEach(e => {
                if (e.userData.controller) {
                     e.visible = false;
                     e.userData.isDead = true; 
                }
            });
            window.flux.enemies.length = 0; // Clear array
        }
        
        if (window.flux.startCinematic) window.flux.startCinematic();
        
        if (window.flux.audio) {
            window.flux.audio.play('charge');
            setTimeout(() => window.flux.audio.play('massive_impact'), 1500);
        }
        
        if (window.flux.spawnChargeParticles) window.flux.spawnChargeParticles(this.player.mesh.position);
    }
    
    update(dt) {
        if (this.launching) {
            this.updateLaunchSequence(dt);
        }
        
        if (this.active) {
            this.reEntryCooldown -= dt;
            
            this.updateSpaceCamera(dt); 
            this.updateSpaceEnvironment(dt);
            this.updateSwarm(dt);
            this.updateInterceptors(dt);
            this.updateTurrets(dt);
            this.updateSpaceDust(dt);
            this.updateThrusters(dt);
            this.updateRadar();
            this.updateHUD();
            
            // Mission Logic
            this.checkMissionTriggers();
            this.updateBeacons();
            this.updateVectorPuzzle(dt); // NEW: Update Vector Puzzle Logic
            this.updateRetrievalMission(dt); // NEW: Update Retrieval Logic
            
            this.updateVFX(dt);
            this.updateWarpEffect(dt);
            
            this.checkAsteroidCollisions();
            // checkReentry removed, handled by checkMissionTriggers now
            
            if (typeof PlayerCombat !== 'undefined' && this.game.input && !this.game.input.actions.attack) {
                PlayerCombat.releaseSpaceWeapon(this.player);
            }
            
            if (typeof PlayerMesh !== 'undefined') {
                PlayerMesh.transform(this.player, 'JET', dt);
            }
            
            if (this.victoryTriggered) {
                this.updateDestructionSequence(dt);
            }
        }
    }
    
    // --- NEW: VECTOR PUZZLE LOGIC ---
    startVectorPuzzle() {
        this.currentMission = 'VECTOR_PUZZLE';
        this.vectorPuzzleTimer = 0;
        
        // Define a target vector (e.g., towards a specific point or just a direction)
        // For simplicity, let's say align with a specific beacon or point in space
        // Let's create a visual target
        const targetGeo = new THREE.SphereGeometry(50, 32, 32);
        const targetMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5 });
        this.vectorPuzzleTarget = new THREE.Mesh(targetGeo, targetMat);
        this.vectorPuzzleTarget.position.set(0, 0, -2000); // Far ahead
        this.spaceGroup.add(this.vectorPuzzleTarget);
        
        if (window.flux.spawnTechText) window.flux.spawnTechText("MISSION: ORBITAL STABILIZATION");
        this.objectiveContainer.innerHTML = `
            <div class="objective-header">MISSION: ORBITAL STABILIZATION</div>
            <div class="objective-item active">ALIGN VECTOR & DECOUPLE</div>
        `;
    }

    updateVectorPuzzle(dt) {
        if (this.currentMission !== 'VECTOR_PUZZLE' || !this.vectorPuzzleTarget) return;

        const playerVel = this.player.velocity.clone();
        const speed = playerVel.length();
        const toTarget = new THREE.Vector3().subVectors(this.vectorPuzzleTarget.position, this.player.mesh.position).normalize();
        
        // Check 1: Is Player in Decoupled Mode?
        const isDecoupled = this.player.flightMode === 'DECOUPLED';
        
        // Check 2: Is Velocity Vector aligned with Target?
        const velDir = playerVel.clone().normalize();
        const alignment = velDir.dot(toTarget);
        
        // Check 3: Is Aim Stable? (Not rotating wildly)
        // We can check rotational velocity or just input
        const isStable = Math.abs(this.game.input.lookVector.x) < 0.1 && Math.abs(this.game.input.lookVector.y) < 0.1;

        if (isDecoupled && alignment > 0.95 && speed > 50 && isStable) {
            this.vectorPuzzleTimer += dt;
            
            // Visual Feedback
            this.vectorPuzzleTarget.material.color.setHex(0x00ff00);
            this.vectorPuzzleTarget.scale.setScalar(1.0 + Math.sin(Date.now() * 0.01) * 0.1);
            
            if (this.vectorPuzzleTimer >= this.vectorPuzzleSuccessTime) {
                this.completeVectorPuzzle();
            }
        } else {
            this.vectorPuzzleTimer = Math.max(0, this.vectorPuzzleTimer - dt); // Decay progress
            this.vectorPuzzleTarget.material.color.setHex(0xff0000); // Red if not aligned
        }
        
        // Update HUD progress
        const progress = Math.min(1.0, this.vectorPuzzleTimer / this.vectorPuzzleSuccessTime);
        // Could add a progress bar here
    }

    completeVectorPuzzle() {
        this.currentMission = null;
        if (window.flux.spawnTechText) window.flux.spawnTechText("STABILIZATION COMPLETE");
        if (window.flux.audio) window.flux.audio.play('charge');
        
        // Cleanup
        this.spaceGroup.remove(this.vectorPuzzleTarget);
        this.vectorPuzzleTarget = null;
        
        // Reward?
        if (window.flux.addCombo) window.flux.addCombo(); // Bonus combo
        
        // Return to patrol
        setTimeout(() => {
            this.initObjectives();
        }, 2000);
    }

    // --- NEW: RETRIEVAL MISSION LOGIC ---
    startRetrievalMission() {
        this.currentMission = 'RETRIEVAL';
        
        // Spawn Drifting Core
        if (typeof AssetFactory !== 'undefined' && AssetFactory.createDataCore) {
            this.retrievalTarget = AssetFactory.createDataCore();
            // Spawn somewhere random but reachable
            this.retrievalTarget.position.set(
                (Math.random() - 0.5) * 1000,
                (Math.random() - 0.5) * 500,
                (Math.random() - 0.5) * 1000
            );
            // Add drift velocity
            this.retrievalTarget.userData.driftVelocity = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20
            );
            this.spaceGroup.add(this.retrievalTarget);
            
            if (window.flux.spawnTechText) window.flux.spawnTechText("MISSION: RETRIEVE DATA CORE");
            this.objectiveContainer.innerHTML = `
                <div class="objective-header">MISSION: RETRIEVAL</div>
                <div class="objective-item active">LOCATE & SECURE CORE</div>
            `;
        }
    }

    updateRetrievalMission(dt) {
        if (this.currentMission !== 'RETRIEVAL' || !this.retrievalTarget) return;
        
        // Drift
        this.retrievalTarget.position.add(this.retrievalTarget.userData.driftVelocity.clone().multiplyScalar(dt));
        this.retrievalTarget.rotation.x += dt * 0.5;
        this.retrievalTarget.rotation.y += dt * 0.2;
        
        // Check Distance
        const dist = this.player.mesh.position.distanceTo(this.retrievalTarget.position);
        
        // Show indicator if far
        if (dist > 100) {
            // Add marker logic here if needed, or rely on Radar
        }
        
        if (dist < 15) { // Pickup radius
            this.completeRetrievalMission();
        }
    }

    completeRetrievalMission() {
        this.currentMission = null;
        if (window.flux.spawnTechText) window.flux.spawnTechText("CORE RETRIEVED");
        if (window.flux.audio) window.flux.audio.play('charge');
        
        // Visuals
        if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(this.retrievalTarget.position);
        
        // Cleanup
        this.spaceGroup.remove(this.retrievalTarget);
        this.retrievalTarget = null;
        
        // Reward
        if (window.flux.addCombo) window.flux.addCombo();
        
        // Return to patrol
        setTimeout(() => {
            this.initObjectives();
        }, 2000);
    }
    
    updateBeacons() {
        if (!this.beaconGroup.visible) return;
        
        this.beacons.forEach(b => {
            if (b.userData.labelElement) {
                // Project position to screen
                _ssVec1.copy(b.position);
                _ssVec1.project(this.camera);
                
                if (_ssVec1.z < 1) {
                    b.userData.labelElement.style.display = 'block';
                    const x = (_ssVec1.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(_ssVec1.y * 0.5) + 0.5) * window.innerHeight;
                    b.userData.labelElement.style.left = `${x}px`;
                    b.userData.labelElement.style.top = `${y}px`;
                    
                    // Distance
                    const dist = Math.floor(this.player.mesh.position.distanceTo(b.position));
                    b.userData.labelElement.innerText = `${b.userData.stageType} [${dist}m]`;
                } else {
                    b.userData.labelElement.style.display = 'none';
                }
            }
        });
    }
    
    checkReentry() {
        // Deprecated, logic moved to checkMissionTriggers
    }
    
    triggerReentrySequence(stageType = 'CITY') {
        if (this.game && this.game.triggerReentry) {
            // CLEAR SPACE ENEMIES
            this.spaceEnemyGroup.clear();
            this.swarmBoids = [];
            this.interceptors = [];
            this.turrets = [];
            this.asteroids = [];
            this.collidableAsteroids = [];
            window.flux.spaceEnemies = [];
            
            this.game.triggerReentry(stageType);
        }
    }
    
    checkAsteroidCollisions() {
        if (!this.player || this.player.isDead) return;
        
        const speed = this.player.velocity.length();
        const isWarping = speed > 2000; 
        
        if (isWarping) return; 
        
        const playerRadius = 2.0; 
        const pPos = this.player.mesh.position;
        
        // Check Collidable Asteroids (Mission specific or Environment)
        for (let i = this.collidableAsteroids.length - 1; i >= 0; i--) {
            const asteroid = this.collidableAsteroids[i];
            
            // Skip if dead/removed
            if (asteroid.userData.isDead) {
                this.collidableAsteroids.splice(i, 1);
                continue;
            }
            
            const distSq = pPos.distanceToSquared(asteroid.position);
            const radiusSum = (asteroid.userData.radius || 10) + playerRadius;
            
            if (distSq < radiusSum * radiusSum) {
                console.log("CRITICAL HULL FAILURE: ASTEROID IMPACT");
                this.player.takeDamage(50); 
                if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(pPos);
                if (window.flux.spawnTechText) window.flux.spawnTechText("HULL IMPACT");
                
                // Bounce
                const normal = new THREE.Vector3().subVectors(pPos, asteroid.position).normalize();
                this.player.velocity.reflect(normal).multiplyScalar(0.5);
                this.player.mesh.position.add(normal.multiplyScalar(5.0));
                break;
            }
            
            // Check for Weapon Hits on Asteroid (Mission Logic)
            // This is usually handled in PlayerCombat, but we can check HP here if needed
            if (asteroid.userData.hp <= 0) {
                asteroid.userData.isDead = true;
                asteroid.visible = false;
                if (window.flux.spawnSpaceExplosion) window.flux.spawnSpaceExplosion(asteroid.position, 3.0);
                if (this.currentMission === 'ASTEROID') {
                    this.missionData.asteroidsDestroyed++;
                }
            }
        }
    }
    
    updateWarpEffect(dt) {
        if (!this.player || !this.starField) return;
        
        const isWarping = this.player.isBoosting && this.player.velocity.length() > 150;
        
        const targetScale = isWarping ? 5.0 : 1.0;
        this.starField.scale.z += (targetScale - this.starField.scale.z) * 2.0 * dt;
        
        if (isWarping && this.game.rgbShiftPass) {
            this.game.rgbShiftPass.uniforms['amount'].value = 0.003 + Math.sin(Date.now() * 0.02) * 0.001;
        }
    }
    
    updateVFX(dt) {
        if (this.speedLines && this.player) {
            this.speedLines.update(dt, this.player.mesh.position, this.player.velocity);
        }
        
        if (this.wingTrails.left && this.player.binderL) {
            const tipPos = _ssVec1.set(0, -0.8, 0); 
            this.player.binderL.updateWorldMatrix(true, false);
            const worldPos = tipPos.applyMatrix4(this.player.binderL.matrixWorld);
            this.wingTrails.left.update(worldPos, dt);
        }
        
        if (this.wingTrails.right && this.player.binderR) {
            const tipPos = _ssVec2.set(0, -0.8, 0);
            this.player.binderR.updateWorldMatrix(true, false);
            const worldPos = tipPos.applyMatrix4(this.player.binderR.matrixWorld);
            this.wingTrails.right.update(worldPos, dt);
        }
    }
    
    updateSpaceCamera(dt) {
        if (!this.player || !this.camera) return;

        if (this.player.isFirstPerson) {
            const cockpitOffset = _ssVec1.set(0, 0.8, -0.5); 
            cockpitOffset.applyQuaternion(this.player.mesh.quaternion);
            const camPos = this.player.mesh.position.clone().add(cockpitOffset);
            
            this.camera.position.copy(camPos);
            this.camera.quaternion.copy(this.player.mesh.quaternion);
            
            const targetFOV = this.player.isBoosting ? 110 : 90;
            this.camera.fov += (targetFOV - this.camera.fov) * 2.0 * dt;
            this.camera.updateProjectionMatrix();
            return;
        }

        const boostOffset = this.player.isBoosting ? 5.0 : 0;
        const offset = _ssVec1.set(0, 4, 12 + boostOffset);
        
        const roll = (this.game.input.moveVector.x || 0) * -0.5; 
        const quaternion = this.player.mesh.quaternion.clone();
        
        // Reuse quaternion for roll
        _ssQuat.setFromAxisAngle(_ssVec2.set(0,0,1), roll);
        quaternion.multiply(_ssQuat);
        
        offset.applyQuaternion(quaternion);
        
        const targetPos = this.player.mesh.position.clone().add(offset);
        
        const speed = this.player.velocity.length();
        if (speed > 100) {
            const shake = (speed - 100) * 0.005;
            targetPos.add(_ssVec3.set(
                (Math.random()-0.5)*shake,
                (Math.random()-0.5)*shake,
                (Math.random()-0.5)*shake
            ));
        }
        
        this.camera.position.lerp(targetPos, 5.0 * dt);
        
        const forward = _ssForward.set(0, 0, -1).applyQuaternion(quaternion);
        let lookTarget = this.player.mesh.position.clone().add(forward.multiplyScalar(20));
        
        if (this.player.targetEnemy && !this.player.targetEnemy.userData.isDead) {
             const enemyPos = this.player.targetEnemy.position;
             lookTarget.lerp(enemyPos, 0.5);
        }
        
        const playerUp = _ssUp.set(0, 1, 0).applyQuaternion(quaternion);
        this.camera.up.lerp(playerUp, 5.0 * dt);
        
        this.camera.lookAt(lookTarget);
        
        const targetFOV = this.player.isBoosting ? 110 : 75;
        this.camera.fov += (targetFOV - this.camera.fov) * 2.0 * dt;
        this.camera.updateProjectionMatrix();
    }
    
    updateSpaceDust(dt) {
        if (!this.dustParticles || !this.camera) return;
        
        const positions = this.dustParticles.geometry.attributes.position.array;
        const camPos = this.camera.position;
        const range = 50;
        
        // Use static vector for velocity
        _ssVec1.copy(this.player.velocity).multiplyScalar(dt * 0.5);
        
        for(let i=0; i<positions.length; i+=3) {
            positions[i] -= _ssVec1.x;
            positions[i+1] -= _ssVec1.y;
            positions[i+2] -= _ssVec1.z;
            
            if (positions[i] < camPos.x - range) positions[i] += range * 2;
            if (positions[i] > camPos.x + range) positions[i] -= range * 2;
            
            if (positions[i+1] < camPos.y - range) positions[i+1] += range * 2;
            if (positions[i+1] > camPos.y + range) positions[i+1] -= range * 2;
            
            if (positions[i+2] < camPos.z - range) positions[i+2] += range * 2;
            if (positions[i+2] > camPos.z + range) positions[i+2] -= range * 2;
        }
        
        this.dustParticles.geometry.attributes.position.needsUpdate = true;
    }
    
    updateThrusters(dt) {
        if (!this.player.binderL || !this.player.binderR) return;
        
        const thrusterL = this.player.binderL.userData.thruster;
        const thrusterR = this.player.binderR.userData.thruster;
        
        if (thrusterL && thrusterR) {
            let scale = 1.0 + (Math.random() * 0.2);
            
            if (this.player.isBoosting) {
                scale = 3.0 + (Math.random() * 0.5);
                if (thrusterL.material) thrusterL.material.color.setHex(0xffaa00);
            } else {
                if (thrusterL.material) thrusterL.material.color.setHex(0x00ffff);
            }
            
            thrusterL.scale.set(1, scale, 1);
            thrusterR.scale.set(1, scale, 1);
            if (thrusterL.material) thrusterL.material.opacity = 0.8 + (Math.random() * 0.2);
        }
    }
    
    updateLaunchSequence(dt) {
        this.launchTimer += dt;
        const t = this.launchTimer;
        
        if (typeof PlayerMesh !== 'undefined') {
            PlayerMesh.transform(this.player, 'JET', dt);
        }
        
        if (t < 2.0) {
            if (window.flux.shake) window.flux.shake(0.5 * t);
            this.player.mesh.position.y += dt * 0.5;
        }
        else if (t < 5.0) {
            const progress = (t - 2.0) / 3.0;
            const speed = 100 * progress * progress;
            this.player.mesh.position.y += speed * dt;
            
            if (window.flux.shake) window.flux.shake(2.0);
            
            this.camera.position.y = this.player.mesh.position.y - 10;
            this.camera.lookAt(this.player.mesh.position);
            
            this.scene.fog.density = 0.015 + (progress * 0.05);
            this.scene.fog.color.setHSL(0.6, 0.5, 0.1 + progress * 0.8);
        }
        else if (!this.active) {
            this.triggerAtmosphericBreach();
            this.enterSpace();
        }
    }
    
    triggerAtmosphericBreach() {
        const flashDiv = document.createElement('div');
        flashDiv.style.position = 'fixed';
        flashDiv.style.top = '0';
        flashDiv.style.left = '0';
        flashDiv.style.width = '100%';
        flashDiv.style.height = '100%';
        flashDiv.style.backgroundColor = 'white';
        flashDiv.style.zIndex = '9999';
        flashDiv.style.transition = 'opacity 1s ease-out';
        document.body.appendChild(flashDiv);
        
        setTimeout(() => {
            flashDiv.style.opacity = '0';
            setTimeout(() => document.body.removeChild(flashDiv), 1000);
        }, 100);
        
        if (window.flux.spawnShockwave) {
            for(let i=0; i<3; i++) {
                setTimeout(() => window.flux.spawnShockwave(this.player.mesh.position), i * 100);
            }
        }
    }
    
    enterSpace() {
        console.log("SpaceSystem: Orbit Achieved.");
        this.launching = false;
        this.active = true;
        
        this.game.staticGroup.visible = false;
        this.game.dustGroup.visible = false;
        this.spaceGroup.visible = true;
        
        this.player.isSpaceMode = true;
        this.player.velocity.set(0, 0, 50);
        this.player.mesh.position.set(0, 0, 0);
        this.player.mesh.rotation.set(0, 0, 0);
        
        this.player.enemyGroup = this.spaceEnemyGroup;
        window.flux.spaceEnemies = this.spaceEnemyGroup.children;
        
        this.scene.fog.density = 0.0;
        this.scene.background = new THREE.Color(0x000000);
        
        // --- MISSION INIT ---
        this.initMissions();
        this.beaconGroup.visible = true;
        
        // Spawn ambient asteroids (visual only)
        this.initAsteroids();
        
        // Spawn ambient enemies
        this.spawnSwarm(20);
        this.spawnInterceptors(5);
        
        if (window.flux.stopCinematic) window.flux.stopCinematic();
        if (window.flux.spawnTechText) window.flux.spawnTechText("ORBITAL INSERTION COMPLETE");
        
        if (window.flux.audio) window.flux.audio.playBGM('bgm_boss', 2.0);
        
        if (this.radarEl) this.radarEl.style.display = 'block';
        
        this.injectSpaceHUD();
        this.initObjectives(); 
        
        // Start Vector Puzzle Demo if needed, or just let player choose
        // this.startVectorPuzzle(); // Uncomment to force start
    }
    
    initObjectives() {
        const container = document.createElement('div');
        container.id = 'space-objectives';
        container.innerHTML = `
            <div class="objective-header">MISSION SELECT</div>
            <div class="objective-item active">FLY TO A BEACON</div>
        `;
        document.getElementById('ui-layer').appendChild(container);
        this.objectiveContainer = container;
    }
    
    updateObjectives() {
        if (!this.capitalShip || !this.objectiveContainer) return;
        
        let enginesDestroyed = 0;
        let bridgeDestroyed = 0;
        let coreDestroyed = 0;
        
        this.capitalShip.children.forEach(child => {
            if (!child.userData) return;
            if (child.userData.subsystemType === 'engine' && child.userData.isDead) enginesDestroyed++;
            if (child.userData.subsystemType === 'bridge' && child.userData.isDead) bridgeDestroyed++;
            if (child.userData.subsystemType === 'core' && child.userData.isDead) coreDestroyed++;
        });
        
        // Rebuild HTML if needed, or update classes
        // For simplicity, we just overwrite if it's the capital mission
        if (this.currentMission === 'CAPITAL') {
            this.objectiveContainer.innerHTML = `
                <div class="objective-header">MISSION: CAPITAL ASSAULT</div>
                <div id="obj-engines" class="objective-item ${enginesDestroyed>=2 ? 'done' : 'active'}">DESTROY ENGINES [${enginesDestroyed}/2]</div>
                <div id="obj-bridge" class="objective-item ${bridgeDestroyed>=1 ? 'done' : 'active'}">DESTROY BRIDGE [${bridgeDestroyed}/1]</div>
                <div id="obj-core" class="objective-item ${(enginesDestroyed>=2 && bridgeDestroyed>=1) ? 'active' : ''} ${coreDestroyed>=1 ? 'done' : ''}">DESTROY CORE [${coreDestroyed}/1]</div>
            `;
        }
    }
    
    injectSpaceHUD() {
        const overlay = document.createElement('div');
        overlay.id = 'space-hud-overlay';
        overlay.style.display = 'block';
        document.getElementById('ui-layer').appendChild(overlay);
        this.hudOverlay = overlay;

        const prograde = document.createElement('div');
        prograde.className = 'prograde-marker';
        overlay.appendChild(prograde);
        this.progradeMarker = prograde;

        const retrograde = document.createElement('div');
        retrograde.className = 'retrograde-marker';
        overlay.appendChild(retrograde);
        this.retrogradeMarker = retrograde;

        const mode = document.createElement('div');
        mode.className = 'flight-mode-indicator';
        mode.innerText = 'COUPLED';
        overlay.appendChild(mode);
        this.flightModeIndicator = mode;

        const hudRight = document.querySelector('.hud-top-right');
        if (hudRight && !document.getElementById('space-speed')) {
            const speedDisplay = document.createElement('div');
            speedDisplay.id = 'space-speed';
            speedDisplay.className = 'debug-row';
            speedDisplay.innerHTML = 'SPD <span id="val-speed">0</span> KM/S';
            hudRight.appendChild(speedDisplay);
        }
        
        for(let i=0; i<8; i++) {
            const ind = document.createElement('div');
            ind.className = 'space-lock-indicator';
            ind.style.display = 'none';
            overlay.appendChild(ind);
            this.lockIndicators.push(ind);
        }
    }
    
    updateHUD() {
        if (!this.active || !this.camera) return;

        const speedEl = document.getElementById('val-speed');
        if (speedEl) {
            // UPDATED: Scale by 100 to make "20,000" achievable visually
            const speed = Math.floor(this.player.velocity.length() * 100);
            speedEl.innerText = speed;
            if (this.player.isBoosting) speedEl.style.color = '#ffaa00';
            else speedEl.style.color = '#00f3ff';
        }

        if (this.flightModeIndicator) {
            this.flightModeIndicator.innerText = this.player.flightMode;
            if (this.player.flightMode === 'DECOUPLED') {
                this.flightModeIndicator.classList.add('decoupled');
            } else {
                this.flightModeIndicator.classList.remove('decoupled');
            }
        }

        if (this.progradeMarker && this.player.velocity.lengthSq() > 1.0) {
            this.updateMarker(this.progradeMarker, this.player.velocity.clone().normalize());
            this.updateMarker(this.retrogradeMarker, this.player.velocity.clone().normalize().negate());
        } else {
            if (this.progradeMarker) this.progradeMarker.style.display = 'none';
            if (this.retrogradeMarker) this.retrogradeMarker.style.display = 'none';
        }
        
        this.lockIndicators.forEach(el => el.style.display = 'none');
        
        if (this.player.spaceLocks && this.player.spaceLocks.length > 0) {
            this.player.spaceLocks.forEach((target, i) => {
                if (i >= this.lockIndicators.length) return;
                const el = this.lockIndicators[i];
                if (target.userData.isDead) return;
                
                // Reuse static vector
                _ssVec1.copy(target.position);
                target.updateWorldMatrix(true, false);
                target.getWorldPosition(_ssVec1);
                _ssVec1.project(this.camera);
                
                if (_ssVec1.z < 1) { 
                    el.style.display = 'block';
                    const x = (_ssVec1.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(_ssVec1.y * 0.5) + 0.5) * window.innerHeight;
                    el.style.left = `${x}px`;
                    el.style.top = `${y}px`;
                    el.classList.add('locked');
                    
                    // Rotate based on index to show stacking
                    el.style.transform = `translate(-50%, -50%) rotate(${i * 45}deg)`;
                }
            });
        }
        
        const lockCursor = document.getElementById('lock-cursor');
        if (lockCursor && this.player.targetEnemy && !this.player.targetEnemy.userData.isDead) {
            const target = this.player.targetEnemy;
            const pos = target.position.clone();
            pos.project(this.camera);
            
            if (pos.z < 1) {
                lockCursor.classList.remove('hidden');
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(pos.y * 0.5) + 0.5) * window.innerHeight;
                lockCursor.style.left = `${x}px`;
                lockCursor.style.top = `${y}px`;
                
                const dist = this.player.mesh.position.distanceTo(target.position).toFixed(0);
                const lockText = lockCursor.querySelector('.lock-text');
                if (lockText) lockText.innerText = `LOCK [${dist}m]`;
            } else {
                lockCursor.classList.add('hidden');
            }
        } else if (lockCursor) {
            lockCursor.classList.add('hidden');
        }
    }

    updateMarker(el, dir) {
        const targetPos = this.camera.position.clone().add(dir.multiplyScalar(100));
        targetPos.project(this.camera);
        if (targetPos.z > 1) {
            el.style.display = 'none';
            return;
        }
        el.style.display = 'block';
        const x = (targetPos.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(targetPos.y * 0.5) + 0.5) * window.innerHeight;
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
    }
    
    spawnTurrets(ship) {
        if (typeof SpaceTurret === 'undefined') return;
        
        const positions = [
            new THREE.Vector3(15, 8, 20),
            new THREE.Vector3(-15, 8, 20),
            new THREE.Vector3(15, 8, -20),
            new THREE.Vector3(-15, 8, -20),
            new THREE.Vector3(0, 10, 0)
        ];
        positions.forEach(pos => {
            const turret = new SpaceTurret(ship, pos, this.scene);
            this.turrets.push(turret);
        });
    }
    
    spawnSwarm(count, center = new THREE.Vector3(0,0,-400)) {
        if (typeof SpaceSwarmBoid === 'undefined') return;
        
        for(let i=0; i<count; i++) {
            const pos = center.clone().add(new THREE.Vector3(
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 200
            ));
            const boid = new SpaceSwarmBoid(this.scene, this.spaceEnemyGroup, pos);
            this.swarmBoids.push(boid);
        }
    }
    
    spawnInterceptors(count, center = new THREE.Vector3(0,0,-300)) {
        if (typeof SpaceInterceptor === 'undefined') return;
        
        for(let i=0; i<count; i++) {
            const pos = center.clone().add(new THREE.Vector3(
                (Math.random() - 0.5) * 400,
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 100
            ));
            const interceptor = new SpaceInterceptor(this.scene, this.spaceEnemyGroup, pos);
            this.interceptors.push(interceptor);
        }
    }
    
    updateSwarm(dt) {
        const playerPos = this.player.mesh.position;
        this.swarmBoids.forEach(boid => boid.update(dt, playerPos));
    }
    
    updateInterceptors(dt) {
        const playerPos = this.player.mesh.position;
        const playerVel = this.player.velocity;
        this.interceptors.forEach(i => i.update(dt, playerPos, playerVel));
    }
    
    updateTurrets(dt) {
        const playerPos = this.player.mesh.position;
        const playerVel = this.player.velocity;
        this.turrets.forEach(t => t.update(dt, playerPos, playerVel));
    }
    
    updateRadar() {
        if (!this.radarEl || !this.player) return;
        this.radarBlips.forEach(b => b.style.display = 'none');
        
        // Reuse static vectors
        _ssForward.set(0, 0, -1).applyQuaternion(this.player.mesh.quaternion);
        _ssUp.set(0, 1, 0).applyQuaternion(this.player.mesh.quaternion);
        _ssRight.crossVectors(_ssForward, _ssUp);
        
        let blipIdx = 0;
        const range = 2000; // Increased range for beacons
        
        // Show Beacons
        if (this.beaconGroup.visible) {
            this.beacons.forEach(b => {
                if (blipIdx >= this.radarBlips.length) return;
                this.updateBlip(b.position, range, _ssForward, _ssRight, this.radarBlips[blipIdx], false, true);
                blipIdx++;
            });
        }
        
        this.swarmBoids.forEach(boid => {
            if (blipIdx >= this.radarBlips.length || !boid.mesh.visible) return;
            this.updateBlip(boid.mesh.position, range, _ssForward, _ssRight, this.radarBlips[blipIdx]);
            blipIdx++;
        });
        
        this.interceptors.forEach(int => {
            if (blipIdx >= this.radarBlips.length || !int.mesh.visible) return;
            this.updateBlip(int.mesh.position, range, _ssForward, _ssRight, this.radarBlips[blipIdx]);
            blipIdx++;
        });
        
        this.turrets.forEach(turret => {
            if (blipIdx >= this.radarBlips.length || !turret.mesh.visible) return;
            // Static vector reuse
            _ssVec1.set(0,0,0);
            turret.mesh.getWorldPosition(_ssVec1);
            this.updateBlip(_ssVec1, range, _ssForward, _ssRight, this.radarBlips[blipIdx], true);
            blipIdx++;
        });
    }
    
    updateBlip(targetPos, range, fwd, right, blipEl, isCapital = false, isBeacon = false) {
        // Reuse vector for calculation
        _ssVec2.subVectors(targetPos, this.player.mesh.position);
        const dist = _ssVec2.length();
        if (dist > range) return;
        const localX = _ssVec2.dot(right);
        const localY = _ssVec2.dot(fwd);
        const scale = 60 / range;
        const screenX = localX * scale;
        const screenY = -localY * scale;
        blipEl.style.display = 'block';
        blipEl.style.left = `calc(50% + ${screenX}px)`;
        blipEl.style.top = `calc(50% + ${screenY}px)`;
        
        blipEl.className = 'radar-blip'; // Reset
        if (isCapital) blipEl.classList.add('capital');
        if (isBeacon) blipEl.classList.add('beacon');
    }
    
    updateSpaceEnvironment(dt) {
        if (this.earth) this.earth.rotation.y += dt * 0.01;
        if (this.moon) this.moon.rotation.y += dt * 0.005;
        if (this.mars) this.mars.rotation.y += dt * 0.008;
        if (this.jupiter) this.jupiter.rotation.y += dt * 0.02;
        if (this.saturn) this.saturn.rotation.y += dt * 0.02;
        if (this.mercury) this.mercury.rotation.y += dt * 0.04;
        if (this.venus) this.venus.rotation.y += dt * 0.01;
        if (this.uranus) this.uranus.rotation.y += dt * 0.015;
        if (this.neptune) this.neptune.rotation.y += dt * 0.015;
        
        if (this.capitalShip) this.capitalShip.rotation.z = Math.sin(Date.now() * 0.0005) * 0.05;
        if (this.starField && this.camera) this.starField.position.copy(this.camera.position);
        
        this.asteroids.forEach(a => {
            if (a.userData.rotVel) {
                a.rotation.x += a.userData.rotVel.x * dt;
                a.rotation.y += a.userData.rotVel.y * dt;
                a.rotation.z += a.userData.rotVel.z * dt;
            }
        });
    }

    updateCapitalShip(dt) {
        if (!this.capitalShip) return;
        if (this.victoryTriggered) return;
        
        let enginesAlive = false;
        let bridgeAlive = false;
        let core = null;
        
        this.updateMainCannon(dt);
        
        this.capitalShip.children.forEach(child => {
            if (!child.userData) return;
            
            if (child.userData.subsystemType === 'core') {
                core = child;
                if (child.userData.hp <= 0 && !child.userData.isDead) {
                    child.userData.isDead = true;
                    this.triggerVictory();
                }
            }
            
            if (child.userData.subsystemType === 'engine' && !child.userData.isDead) enginesAlive = true;
            if (child.userData.subsystemType === 'bridge' && !child.userData.isDead) bridgeAlive = true;
            
            if (child.userData.hp <= 0 && !child.userData.isDead && child.userData.subsystemType !== 'core') {
                child.userData.isDead = true;
                const pos = new THREE.Vector3();
                child.getWorldPosition(pos);
                if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(pos);
                
                if (child.userData.subsystemType === 'engine' && child.userData.flare) {
                    child.userData.flare.visible = false;
                    if (window.flux.spawnTechText) window.flux.spawnTechText("ENGINE DESTROYED");
                }
                if (child.userData.subsystemType === 'bridge') {
                    if (window.flux.spawnTechText) window.flux.spawnTechText("BRIDGE DESTROYED");
                    this.turrets.forEach(t => t.active = false);
                }
            }
        });
        
        if (!enginesAlive && !bridgeAlive && core && core.userData.invulnerable) {
            core.userData.invulnerable = false;
            if (core.userData.shieldMesh) core.userData.shieldMesh.visible = false;
            if (window.flux.spawnTechText) window.flux.spawnTechText("CORE SHIELD DOWN - ATTACK NOW");
            if (window.flux.audio) window.flux.audio.play('charge');
        }
    }
    
    updateMainCannon(dt) {
        if (!this.capitalShip.userData.mainCannon) return;
        
        const cannon = this.capitalShip.userData.mainCannon;
        const warningEl = document.getElementById('warning-msg');
        
        if (this.mainCannonState === 'IDLE') {
            this.mainCannonTimer += dt;
            if (this.mainCannonTimer > 10.0) { 
                this.mainCannonState = 'CHARGING';
                this.mainCannonTimer = 0;
                if (warningEl) warningEl.style.display = 'block';
                if (window.flux.audio) window.flux.audio.play('charge');
            }
        } else if (this.mainCannonState === 'CHARGING') {
            this.mainCannonTimer += dt;
            if (cannon.emitter) {
                const s = 1.5 + Math.sin(this.mainCannonTimer * 20) * 0.5;
                cannon.emitter.scale.set(s,s,s);
            }
            
            if (this.mainCannonTimer > 3.0) {
                this.mainCannonState = 'FIRING';
                this.mainCannonTimer = 0;
                this.fireMainCannon(cannon);
            }
        } else if (this.mainCannonState === 'FIRING') {
            this.mainCannonTimer += dt;
            if (this.mainCannonTimer > 1.5) { 
                this.mainCannonState = 'COOLDOWN';
                this.mainCannonTimer = 0;
                if (warningEl) warningEl.style.display = 'none';
            }
        } else if (this.mainCannonState === 'COOLDOWN') {
            this.mainCannonTimer += dt;
            if (this.mainCannonTimer > 5.0) {
                this.mainCannonState = 'IDLE';
                this.mainCannonTimer = 0;
            }
        }
    }
    
    fireMainCannon(cannon) {
        if (!window.flux.fireBossBeam) return;
        
        const startPos = new THREE.Vector3();
        cannon.emitter.getWorldPosition(startPos);
        
        const targetPos = this.player.mesh.position.clone();
        
        const dir = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
        const endPos = startPos.clone().add(dir.multiplyScalar(2000));
        
        window.flux.fireBossBeam(startPos, endPos, 1.5, 8.0); 
        
        if (window.flux.audio) window.flux.audio.play('laser_fire');
        if (window.flux.shake) window.flux.shake(2.0);
    }
    
    triggerVictory() {
        this.victoryTriggered = true;
        this.destructionTimer = 0;
        console.log("VICTORY!");
        
        if (window.flux.slowMotion) window.flux.slowMotion(3.0, 0.1);
        
        const msg = document.createElement('div');
        msg.id = 'mission-complete';
        msg.innerHTML = 'MISSION COMPLETE<div class="sub-text">CAPITAL SHIP NEUTRALIZED</div>';
        document.body.appendChild(msg);
        setTimeout(() => msg.classList.add('visible'), 100);
        
        if (window.flux.audio) window.flux.audio.play('massive_impact');
    }
    
    updateDestructionSequence(dt) {
        this.destructionTimer += dt;
        const shipPos = this.capitalShip.position.clone();
        
        if (Math.random() > 0.8 && window.flux.spawnSpaceExplosion) {
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 30,
                (Math.random() - 0.5) * 200
            );
            window.flux.spawnSpaceExplosion(shipPos.clone().add(offset), 5.0 + Math.random() * 5.0);
            if (window.flux.audio) window.flux.audio.play('drone_death');
        }
        
        if (this.destructionTimer > 3.0 && this.capitalShip.visible) {
            this.capitalShip.visible = false;
            if (window.flux.spawnSpaceExplosion) window.flux.spawnSpaceExplosion(shipPos, 30.0);
            if (window.flux.audio) window.flux.audio.play('massive_impact');
            if (window.flux.shake) window.flux.shake(3.0);
            
            // Return to Beacon Select
            setTimeout(() => {
                this.currentMission = null;
                this.victoryTriggered = false;
                this.beaconGroup.visible = true;
                const msg = document.getElementById('mission-complete');
                if (msg) msg.remove();
                if (window.flux.spawnTechText) window.flux.spawnTechText("RETURNING TO PATROL");
            }, 5000);
        }
    }
    
    initAsteroids() {
        // Ambient asteroids (visual only)
        if (typeof SpaceAssetFactory === 'undefined') return;
        
        const count = 100; 
        const beltCenter = new THREE.Vector3(0, 0, 0); 
        const beltRadius = 3000;
        
        for(let i=0; i<count; i++) {
            const size = 15 + Math.random() * 40; 
            const asteroid = SpaceAssetFactory.createAsteroid(size);
            
            const angle = Math.random() * Math.PI * 2;
            const dist = beltRadius + (Math.random() - 0.5) * 1000; 
            const height = (Math.random() - 0.5) * 1000;
            
            asteroid.position.set(
                beltCenter.x + Math.cos(angle) * dist,
                beltCenter.y + height,
                beltCenter.z + Math.sin(angle) * dist
            );
            
            asteroid.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            asteroid.userData = {
                rotVel: new THREE.Vector3(Math.random()*0.5, Math.random()*0.5, Math.random()*0.5),
                radius: size 
            };
            
            this.spaceGroup.add(asteroid);
            this.asteroids.push(asteroid);
        }
    }
}</script>

    <!-- NEW: Stage Dynamics -->
    <script>/**
 * STAGE DYNAMICS SYSTEM
 * Handles interactive and dynamic elements within the game world.
 * - Falling Hazards (Ice Spikes)
 * - Proximity Mines (Wasteland)
 * - Moving Anomalies (Void)
 * - Arena Barriers (Shader Updates)
 * - Glitch Zones (Kowloon Stack)
 * - Gravity Traps (Orbital Graveyard)
 * - AP Dampeners (Data Spire)
 * - Data Core (MacGuffin)
 */
class StageDynamics {
    constructor(scene, game) {
        this.scene = scene;
        this.game = game;
        this.dynamicObjects = [];
        this.activeHazards = []; // Projectiles/Falling objects
    }

    /**
     * Scans the provided group for objects tagged as dynamic/hazardous
     * Called after WorldGen builds the stage.
     */
    registerStageObjects(group) {
        this.dynamicObjects = [];
        this.activeHazards = []; // Clear old hazards
        
        group.traverse((obj) => {
            if (obj.userData) {
                if (obj.userData.dynamicType) {
                    // Initialize state for specific types
                    if (obj.userData.dynamicType === 'gravity_trap') {
                        obj.userData.active = true;
                        obj.userData.timer = 0;
                        obj.userData.cycle = 5.0; // 5 seconds cycle
                    }
                    this.dynamicObjects.push(obj);
                }
            }
        });
        
        console.log(`StageDynamics: Registered ${this.dynamicObjects.length} dynamic objects.`);
    }

    update(dt, player) {
        if (!player || player.isDead) return;

        let inGlitchZone = false;
        let inGravityTrap = false;
        let inApDampener = false;

        // 1. Update Registered Objects (Triggers)
        for (let i = this.dynamicObjects.length - 1; i >= 0; i--) {
            const obj = this.dynamicObjects[i];
            
            if (!obj.visible) continue;

            const distSq = player.mesh.position.distanceToSquared(obj.position);

            // LOGIC: ARENA BARRIER (Shader Update)
            if (obj.userData.dynamicType === 'arena_wall') {
                if (obj.material && obj.material.uniforms) {
                    obj.material.uniforms.uTime.value += dt;
                    obj.material.uniforms.uPlayerPos.value.copy(player.mesh.position);
                }
            }

            // LOGIC: GLITCH ZONE (Area Effect)
            else if (obj.userData.dynamicType === 'glitch_zone') {
                const radiusSq = (obj.userData.radius || 10) ** 2;
                if (distSq < radiusSq) {
                    inGlitchZone = true;
                    // Visual feedback
                    if (Math.random() > 0.9) {
                        if (document.body.classList) {
                            document.body.classList.add('hud-glitch');
                            setTimeout(() => document.body.classList.remove('hud-glitch'), 100);
                        }
                    }
                }
            }
            
            // LOGIC: GRAVITY TRAP (Orbital Graveyard - Intermittent)
            else if (obj.userData.dynamicType === 'gravity_trap') {
                // Update Cycle
                obj.userData.timer += dt;
                if (obj.userData.timer > obj.userData.cycle) {
                    obj.userData.timer = 0;
                    obj.userData.active = !obj.userData.active;
                    // Visual Cue for state change
                    if (obj.userData.active) {
                        if (window.flux.spawnTechText) window.flux.spawnTechText("GRAVITY SURGE ACTIVE");
                        if (window.flux.audio) window.flux.audio.play('charge');
                    }
                }

                if (obj.userData.active) {
                    const radiusSq = (obj.userData.radius || 15) ** 2;
                    if (distSq < radiusSq) {
                        inGravityTrap = true;
                    }
                    
                    // Visual Pulse (Active)
                    obj.rotation.y += dt * 5.0;
                    obj.rotation.x += dt * 2.0;
                    if (Math.random() > 0.8 && window.flux.spawnParticles) {
                        window.flux.spawnParticles(obj.position, 2, 0xaa00ff, 10);
                    }
                } else {
                    // Idle Visual
                    obj.rotation.y += dt * 0.5;
                }
            }
            
            // LOGIC: AP DAMPENER (Data Spire)
            else if (obj.userData.dynamicType === 'ap_dampener') {
                const radiusSq = (obj.userData.radius || 20) ** 2;
                if (distSq < radiusSq) {
                    inApDampener = true;
                }
            }
            
            // LOGIC: DATA CORE (MacGuffin)
            else if (obj.userData.dynamicType === 'data_core') {
                const radiusSq = 3.0 ** 2;
                if (distSq < radiusSq) {
                    this.triggerDataCorePickup(obj);
                }
                // Visual Spin
                obj.rotation.y += dt;
            }

            // LOGIC: ICE SPIKE (Falling Hazard)
            else if (obj.userData.dynamicType === 'ice_spike') {
                // Trigger if player is underneath
                if (!obj.userData.triggered && distSq < 100) { // 10m radius check
                    // Check horizontal distance specifically
                    const dx = Math.abs(player.mesh.position.x - obj.position.x);
                    const dz = Math.abs(player.mesh.position.z - obj.position.z);
                    
                    if (dx < 2.0 && dz < 2.0) {
                        this.triggerIceSpike(obj);
                    }
                }
            }
            
            // LOGIC: LAND MINE (Proximity)
            else if (obj.userData.dynamicType === 'land_mine') {
                if (distSq < 9.0) { // 3m radius
                    this.triggerLandMine(obj);
                }
                // Blink effect
                if (obj.material && obj.material.emissive) {
                    const blink = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                    obj.material.emissiveIntensity = blink * 2.0;
                }
            }
            
            // LOGIC: VOID ANOMALY (Rotate/Pulse)
            else if (obj.userData.dynamicType === 'void_anomaly') {
                obj.rotation.x += dt * 0.5;
                obj.rotation.y += dt * 0.3;
                if (distSq < 16.0) { // Contact
                    // Push player away
                    const dir = new THREE.Vector3().subVectors(player.mesh.position, obj.position).normalize();
                    player.velocity.add(dir.multiplyScalar(500 * dt));
                    player.takeDamage(1); // Chip damage
                    if (window.flux && window.flux.shake) window.flux.shake(0.1);
                }
            }
        }
        
        // Apply Glitch Effects to Player
        if (inGlitchZone) {
            if (player.ap > 0) player.ap -= 10 * dt; // Drain AP
            player.isShieldBroken = true; // Disable Shield
            if (window.flux && window.flux.spawnTechText && Math.random() > 0.95) {
                window.flux.spawnTechText("SYSTEM ERROR: AP DRAIN");
            }
        }
        
        // Apply Gravity Trap
        if (inGravityTrap) {
            // Apply massive downward force (simulating high gravity)
            player.velocity.y -= 150 * dt; // Increased force
            // Also pull towards center of trap? No, just down is more annoying for aerial combos
            if (window.flux && window.flux.spawnTechText && Math.random() > 0.95) {
                window.flux.spawnTechText("GRAVITY SURGE");
            }
        }
        
        // Apply AP Dampener
        if (inApDampener) {
            // Prevent AP Regen
            // Player.js naturally regens AP if < 50. We need to counteract it or drain it.
            // Let's drain it slowly to simulate "Leak"
            if (player.ap > 0) player.ap -= 5 * dt;
            
            // Disable Shield
            player.isShieldDisabled = true;
            
            if (window.flux && window.flux.spawnTechText && Math.random() > 0.98) {
                window.flux.spawnTechText("AP DAMPENED - SHIELD OFFLINE");
            }
        } else {
            player.isShieldDisabled = false;
        }

        // 2. Update Active Hazards (Physics objects)
        for (let i = this.activeHazards.length - 1; i >= 0; i--) {
            const hazard = this.activeHazards[i];
            
            if (hazard.userData.hazardType === 'falling_spike') {
                hazard.userData.velocity.y -= 40 * dt; // Gravity
                hazard.position.add(hazard.userData.velocity.clone().multiplyScalar(dt));
                
                // Collision with Player
                if (hazard.position.distanceTo(player.mesh.position) < 1.5) {
                    player.takeDamage(15);
                    if (window.flux.spawnParticles) window.flux.spawnParticles(hazard.position, 10, 0xaaddff, 10);
                    this.destroyHazard(hazard, i);
                    continue;
                }
                
                // Collision with Ground
                if (hazard.position.y < 0) {
                    if (window.flux.spawnParticles) window.flux.spawnParticles(hazard.position, 5, 0xaaddff, 5);
                    if (window.flux.audio) window.flux.audio.play('hit_wall');
                    this.destroyHazard(hazard, i);
                }
            }
        }
    }

    triggerIceSpike(obj) {
        obj.userData.triggered = true;
        // Detach from ceiling visually (or spawn a clone)
        // We'll hide the static one and spawn a physics one
        obj.visible = false;
        
        const fallingSpike = obj.clone();
        fallingSpike.visible = true;
        fallingSpike.position.copy(obj.position);
        fallingSpike.rotation.copy(obj.rotation);
        fallingSpike.userData = {
            hazardType: 'falling_spike',
            velocity: new THREE.Vector3(0, -5, 0) // Initial push
        };
        
        this.scene.add(fallingSpike);
        this.activeHazards.push(fallingSpike);
        
        if (window.flux.audio) window.flux.audio.play('ui_hover'); // Cracking sound placeholder
    }

    triggerLandMine(obj) {
        obj.visible = false;
        // Explosion
        if (window.flux.explode) window.flux.explode(obj.position);
        if (window.flux.audio) window.flux.audio.play('massive_impact');
        
        // Remove from dynamic list to stop checking
        const idx = this.dynamicObjects.indexOf(obj);
        if (idx > -1) this.dynamicObjects.splice(idx, 1);
    }
    
    triggerDataCorePickup(obj) {
        obj.visible = false; // Hide it
        
        if (window.flux.spawnTechText) window.flux.spawnTechText("CORE SECURED");
        if (window.flux.audio) window.flux.audio.play('charge');
        if (window.flux.slowMotion) window.flux.slowMotion(3.0, 0.1);
        
        // Victory Visuals
        if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(obj.position);
        
        // Remove from list
        const idx = this.dynamicObjects.indexOf(obj);
        if (idx > -1) this.dynamicObjects.splice(idx, 1);
        
        // Trigger "Win" UI
        const msg = document.createElement('div');
        msg.id = 'mission-complete';
        msg.innerHTML = 'DATA CORE SECURED<div class="sub-text">UPLOAD COMPLETE</div>';
        document.body.appendChild(msg);
        setTimeout(() => msg.classList.add('visible'), 100);
        
        // Trigger Launch Sequence automatically if in Data Spire
        setTimeout(() => {
            if (msg) msg.remove();
            if (window.flux.spawnSystem && window.flux.spawnSystem.forceStop) {
                window.flux.spawnSystem.forceStop(); // Stop enemies
            }
            // Optional: Auto-launch to space
            // if (window.game && window.game.spaceSystem) window.game.spaceSystem.triggerLaunch();
        }, 5000);
    }

    destroyHazard(obj, index) {
        this.scene.remove(obj);
        this.activeHazards.splice(index, 1);
        // Cleanup geometry/material if unique? 
        // Usually handled by garbage collector if no refs, but good practice to dispose if heavy.
    }
}</script>

    <!-- FLUX HELPERS & GAME -->
    <script>/**
 * FLUX HELPERS
 * Global helper functions for game events, UI, and VFX.
 * Extracted from game.js to reduce file size.
 * OPTIMIZED: Replaced 'new THREE.Vector3' with static reusable vectors to eliminate GC spikes.
 * OPTIMIZED: Uses Object Pools for VFX (Ghosts, Trails, Explosions).
 * UPDATED: Cinematic Camera fixed to show Swarm Landing from a wide angle.
 * UPDATED: Swarm Cinematic now uses Gravity Acceleration for realistic impact.
 * UPDATED: Global VFX Throttling implemented to prevent lag.
 * UPDATED: Aggressive Optimization for Mobile (Reduced Limits).
 * UPDATED: addCombo now supports 'quality' parameter for Efficiency Gate logic.
 * UPDATED: Added spawnPhaseShift for Perfect Dodge Juice.
 * UPDATED: Added awardXp helper function.
 * UPDATED: Restricted AI Voice to priority events only.
 */

// Static reusable vectors to prevent Garbage Collection spikes
const _fhVec = new THREE.Vector3();
const _fhDir = new THREE.Vector3();
const _fhPos = new THREE.Vector3();

// Cached Materials
let _cachedGhostMaterial = null;

// VFX THROTTLING STATE - AGGRESSIVE MOBILE OPTIMIZATION
const VFX_LIMITS = {
    particles: { count: 0, max: 20, resetTime: 0 }, // Reduced from 50
    sparks: { count: 0, max: 10, resetTime: 0 },    // Reduced from 20
    distortion: { count: 0, max: 3, resetTime: 0 }, // Reduced from 5
    trails: { count: 0, max: 5, resetTime: 0 }      // Reduced from 10
};

function checkVFXLimit(type) {
    const now = performance.now();
    const limit = VFX_LIMITS[type];
    
    if (now > limit.resetTime + 100) { // Reset every 100ms (10 frames at 60fps)
        limit.count = 0;
        limit.resetTime = now;
    }
    
    if (limit.count >= limit.max) return false;
    
    limit.count++;
    return true;
}

function initFluxHelpers(game) {
    // Cache ghost material once
    if (!_cachedGhostMaterial) {
        _cachedGhostMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.4,
            wireframe: true
        });
    }
    
    // Initialize Pools
    if (typeof ObjectPool !== 'undefined') {
        if (typeof DistortionWave !== 'undefined') {
            game.distortionPool = new ObjectPool(() => new DistortionWave(game.scene), 10);
        }
        // Initialize Ghost Pool
        if (typeof GhostPool !== 'undefined') {
            game.ghostPool = new GhostPool(game.scene, 5);
        }
        // Initialize Trail Mesh Pool
        if (typeof TrailMeshPool !== 'undefined') {
            game.trailMeshPool = new TrailMeshPool(game.scene, 20);
        }
    }

    window.flux.startCinematic = () => {
        game.cinematicActive = true;
        document.body.classList.add('cinematic-active');
    };
    
    window.flux.stopCinematic = () => {
        game.cinematicActive = false;
        document.body.classList.remove('cinematic-active');
    };

    // --- NEW: SCYTHER SWARM CINEMATIC ---
    window.flux.startSwarmCinematic = (onComplete, swarmSize = 'full') => {
        if (!game) return;
        
        game.cinematicActive = true;
        document.body.classList.add('cinematic-active');
        
        // Determine Count based on Size
        let count = 333; // Default Full
        let warningText = "INCOMING SWARM: MASSIVE";
        
        if (swarmSize === 'small') {
            count = 6;
            warningText = "INCOMING: SCOUT GROUP";
        } else if (swarmSize === 'medium') {
            count = 20;
            warningText = "INCOMING: BATTLE SQUADRON";
        } else {
            count = 60; // "Full" swarm visual cap for performance, logic handles waves
            warningText = "INCOMING: SWARM DETECTED";
        }
        
        // AI Voice Alert - PRIORITY TRUE
        if (window.flux.ai) {
            window.flux.ai.speak(warningText, true);
        }
        
        // Create a temporary "Silhouette" object using the HIGH FIDELITY baked geometry
        const silhouetteGroup = new THREE.Group();
        game.scene.add(silhouetteGroup);
        
        // Use the baked geometry from AssetFactory
        let geo;
        if (typeof AssetFactory !== 'undefined' && AssetFactory.getScytherInstancedGeometry) {
            geo = AssetFactory.getScytherInstancedGeometry();
        } else {
            geo = new THREE.ConeGeometry(0.5, 2.0, 3);
        }
        
        // Dark silhouette material - Starts invisible
        const mat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
        const swarmMesh = new THREE.InstancedMesh(geo, mat, count); 
        
        const dummy = new THREE.Object3D();
        const radius = 40; 
        const barrierRadius = 50; 
        
        // Store initial positions for animation
        const swarmPositions = [];
        
        for(let i=0; i<count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const r = radius + (Math.random() - 0.5) * 10;
            
            // Start HIGH in the sky
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const y = 120 + Math.random() * 60; // Higher start for better fall
            
            swarmPositions.push({ x, y, z, r, angle });
            
            dummy.position.set(x, y, z);
            dummy.lookAt(0, y, 0); // Look center
            
            const baseScale = 0.56;
            const s = baseScale + Math.random() * 0.1;
            dummy.scale.set(s,s,s);
            dummy.updateMatrix();
            swarmMesh.setMatrixAt(i, dummy.matrix);
        }
        silhouetteGroup.add(swarmMesh);
        
        // --- ARENA BARRIER (SHADER) ---
        const barrierGeo = new THREE.CylinderGeometry(barrierRadius, barrierRadius, 60, 32, 1, true);
        
        // Custom Shader for "Invisible until touch/shimmer"
        const barrierMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uPlayerPos: { value: new THREE.Vector3() },
                uCutscene: { value: 1.0 } // 1.0 during cutscene
            },
            vertexShader: `
                varying vec3 vWorldPos;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPos = worldPosition.xyz;
                    gl_Position = projectionMatrix * viewMatrix * worldPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 uPlayerPos;
                uniform float uTime;
                uniform float uCutscene;
                varying vec3 vWorldPos;
                varying vec2 vUv;

                void main() {
                    float dist = distance(vWorldPos, uPlayerPos);
                    float alpha = 0.0;
                    
                    // Battle Contact Logic (Glow when close)
                    float contactDist = 8.0;
                    if (dist < contactDist) {
                        float intensity = 1.0 - (dist / contactDist);
                        // Wireframe simulation using UVs
                        float grid = step(0.95, fract(vUv.x * 50.0)) + step(0.95, fract(vUv.y * 10.0));
                        alpha = intensity * (0.2 + 0.8 * grid);
                    }
                    
                    // Cutscene Shimmer
                    if (uCutscene > 0.0) {
                        float shimmer = sin(vUv.y * 20.0 - uTime * 5.0);
                        alpha = max(alpha, uCutscene * 0.2 * step(0.8, shimmer));
                    }
                    
                    vec3 color = vec3(0.0, 1.0, 0.8); // Cyan/Green
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const barrier = new THREE.Mesh(barrierGeo, barrierMat);
        barrier.position.y = 30;
        // Tag for removal later
        barrier.userData = { type: 'arena_wall', radius: barrierRadius, dynamicType: 'arena_wall', isSwarmBarrier: true };
        game.scene.add(barrier);
        
        // Animate
        let timer = 0;
        const duration = 7.0; 
        
        const animateCinematic = () => {
            timer += 0.016; // Approx dt
            barrierMat.uniforms.uTime.value += 0.016;
            
            // 1. Animate Swarm Falling
            // Fall from Y=100 to Y=0 between t=1.0 and t=4.0
            const fallProgress = Math.max(0, Math.min(1, (timer - 1.0) / 3.0));
            // Accelerating Fall (Gravity)
            const tFall = fallProgress * fallProgress; 
            
            for(let i=0; i<count; i++) {
                const pos = swarmPositions[i];
                const currentY = pos.y * (1 - tFall); // Lerp to 0
                
                dummy.position.set(pos.x, currentY, pos.z);
                dummy.lookAt(0, currentY, 0);
                
                const s = 0.56;
                dummy.scale.set(s,s,s);
                dummy.updateMatrix();
                swarmMesh.setMatrixAt(i, dummy.matrix);
            }
            swarmMesh.instanceMatrix.needsUpdate = true;
            
            // 2. Camera Logic - UPDATED FOR WIDE SHOT
            if (timer < 3.0) {
                // Wide shot from the side, looking up at the sky
                // Position: Back and High enough to see the arena
                game.camera.position.set(0, 15, 80); 
                
                // Look: Up at the incoming swarm (Y=100)
                game.camera.lookAt(0, 100, 0); 
                
                // Slight drift for cinematic feel
                game.camera.position.x = Math.sin(timer * 0.5) * 10;
                game.camera.rotation.z = 0; // Ensure no roll
                
            } else if (timer < 5.0) {
                // TRACKING SHOT: Follow them down to impact
                const tCam = (timer - 3.0) / 2.0; // 0 to 1
                
                // Move camera closer to the action
                const startPos = new THREE.Vector3(0, 15, 80);
                const endPos = new THREE.Vector3(0, 5, 40); // Closer, ground level
                
                // Interpolate position
                game.camera.position.lerpVectors(startPos, endPos, tCam);
                
                // Interpolate LookAt from Sky to Ground
                const lookY = THREE.MathUtils.lerp(100, 0, tCam);
                game.camera.lookAt(0, lookY, 0);
            }
            
            // 3. Fade in Swarm (Silhouette)
            if (timer < 2.0) {
                mat.opacity = Math.min(1.0, timer * 0.5);
            }
            
            // 4. Barrier Rise (Visual)
            if (timer > 4.0) {
                barrierMat.opacity = Math.min(0.3, (timer - 4.0) * 0.2);
                barrierMat.wireframe = Math.floor(timer * 10) % 2 === 0;
            }
            
            if (timer > 1.0 && timer < 1.1) {
                if (window.flux.spawnTechText) window.flux.spawnTechText(warningText);
                if (window.flux.audio) window.flux.audio.play('charge');
            }
            
            if (timer > 4.0 && timer < 4.1) {
                // Swarm "Activates" (Eyes glow green?)
                mat.color.setHex(0x00ff00); // Flash green
                if (window.flux.spawnMassiveImpact) window.flux.spawnMassiveImpact(new THREE.Vector3(0,0,0));
            }

            if (timer < duration) {
                requestAnimationFrame(animateCinematic);
            } else {
                // End
                game.cinematicActive = false;
                document.body.classList.remove('cinematic-active');
                game.scene.remove(silhouetteGroup);
                
                // Turn off cutscene mode in shader
                barrierMat.uniforms.uCutscene.value = 0.0;
                
                // Register with game for physics
                if (game.staticGroup) {
                    game.staticGroup.add(barrier);
                    // Ensure physics knows about it immediately
                    if (window.flux.player) window.flux.player.arenaRadius = barrierRadius;
                }
                
                mat.dispose();
                if (onComplete) onComplete();
            }
        };
        
        animateCinematic();
    };

    window.flux.shake = (amount) => {
        game.shakeIntensity = Math.max(game.shakeIntensity, amount);
        game.chromaticAberrationIntensity = Math.max(game.chromaticAberrationIntensity, amount * 0.05); 
    };
    
    window.flux.triggerZoom = (amount, duration) => {
        if (game) {
            game.cameraZoomTarget = amount;
            game.cameraZoomSpeed = 1.0 / duration;
        }
    };
    
    window.flux.impactStop = (duration) => {
        if (game) {
            game.timeScale = 0.001; 
            game.slowMoTimer = duration; 
            game.targetTimeScale = 1.0; 
        }
    };
    
    window.flux.slowMotion = (duration, scale) => {
        game.slowMoTimer = duration;
        game.targetTimeScale = scale;
    };

    window.flux.hitStop = (duration) => window.flux.slowMotion(duration, 0.05);
    
    // --- JUICE: PHASE SHIFT (PERFECT DODGE) ---
    window.flux.spawnPhaseShift = (pos) => {
        if (!pos) return;
        
        // 1. Cinematic/Disorienting VFX
        window.flux.spawnShockwave(pos);
        // Spawn black/white particles for energy drain
        window.flux.spawnParticles(pos, 20, 0xffffff, 50);
        window.flux.spawnParticles(pos, 20, 0x000000, 50);

        // 2. Global Glitch Effect (via RGB Shift)
        if (game.rgbShiftPass) {
            game.rgbShiftPass.uniforms['amount'].value = 0.05; // Intense Glitch
        }
        game.chromaticAberrationIntensity = 0.05;

        // 3. Slow Motion
        window.flux.slowMotion(0.3, 0.01); // Near Freeze Time

        // 4. Reset Glitch after delay
        setTimeout(() => {
            if (game.rgbShiftPass) game.rgbShiftPass.uniforms['amount'].value = 0.0005;
        }, 300);
    };

    // --- LEVELING: AWARD XP ---
    window.flux.awardXp = (amount) => {
        if (game.player && typeof game.player.addXp === 'function') {
            game.player.addXp(amount);
            // Visual number popup
            const pos = game.player.mesh ? game.player.mesh.position : new THREE.Vector3();
            // Assuming spawnFloatingText is available globally or via window
            if (typeof spawnFloatingText === 'function') {
                 spawnFloatingText(pos, `+${amount} DATA`, false, true); // Use Tech style text
            }
        }
    };

    window.flux.spawnParticles = (pos, count, color, speed) => {
        if (!pos || !game.cubeParticles) return;
        
        // THROTTLE CHECK
        if (!checkVFXLimit('particles')) return;

        // Reduce count if too many (Aggressive optimization for mobile)
        const safeCount = Math.min(count, 5); // Capped at 5 per burst
        
        for(let i=0; i<safeCount; i++) {
            _fhVec.set(
                (Math.random() - 0.5) * speed,
                (Math.random() * speed),
                (Math.random() - 0.5) * speed
            );
            const life = 0.3 + Math.random() * 0.3; // Shorter life
            game.cubeParticles.spawn(pos, _fhVec, color, life, 20, 1.0);
        }
    };

    window.flux.spawnHitParticles = (pos, dir) => {
        if (!pos || !game.sparkParticles) return;
        
        // THROTTLE CHECK
        if (!checkVFXLimit('sparks')) return;

        const baseDir = (dir && dir.isVector3) ? dir : _fhDir.set(0,1,0);
        
        // REDUCED SPARK COUNT (5 -> 2)
        for(let i=0; i<2; i++) { 
            _fhVec.copy(baseDir);
            _fhVec.x += (Math.random() - 0.5) * 1.5;
            _fhVec.y += (Math.random() - 0.5) * 1.5;
            _fhVec.z += (Math.random() - 0.5) * 1.5;
            _fhVec.normalize().multiplyScalar(15 + Math.random() * 25);
            
            game.sparkParticles.spawn(pos, _fhVec, 0xffaa00, 0.4 + Math.random() * 0.4, 45, 1.2, -1.0, 0.7, null, 1.5);
        }
        
        if (game.hitFlashPool) {
            const flash = game.hitFlashPool.get();
            flash.spawn(pos, game.camera.position);
        }
    };
    
    window.flux.spawnDistortion = (pos) => {
        // THROTTLE CHECK
        if (!checkVFXLimit('distortion')) return;

        if (game.distortionPool) {
            const wave = game.distortionPool.get();
            wave.spawn(pos);
        }
    };

    window.flux.spawnGhost = (meshGroup, isSilent) => {
        if (!meshGroup || !game.ghostPool) return;
        
        // THROTTLE GHOSTS
        if (game.ghostPool.active.length > 3) return; // Hard limit on active ghosts (3 for mobile)
        
        // Use the Pool
        const ghost = game.ghostPool.get(meshGroup);
        
        // Sync transforms
        game.ghostPool.copyTransforms(meshGroup, ghost);
        
        const ghostColor = isSilent ? 0x888888 : 0x00ffff;
        ghost.traverse((child) => { 
            if (child.isMesh && child.material) child.material.color.setHex(ghostColor); 
        });
        
        ghost.userData.life = 0.2; // Shorter life
    };
    
    window.flux.spawnVectorTrap = (pos) => {
        if (!game.vectorTrapGroup) return;
        const geo = new THREE.IcosahedronGeometry(1, 1);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.8 });
        const trap = new THREE.Mesh(geo, mat);
        trap.position.copy(pos);
        trap.userData = { life: 0.3, scaleSpeed: 15.0 };
        game.vectorTrapGroup.add(trap);
    };
    
    // UPDATED: Disable Debris Spawning
    window.flux.spawnDebris = (pos, count) => {
        return; // DEBRIS DISABLED PER USER REQUEST
    };

    window.flux.spawnShell = (pos, dir) => {
        if(!pos || !game.shellSystem) return;
        // Throttle shells (only 1 per 3 shots roughly)
        if (Math.random() > 0.3) return;

        _fhVec.copy(dir).multiplyScalar(-2);
        _fhVec.y += 4;
        _fhVec.x += (Math.random() - 0.5) * 2;
        _fhVec.z += (Math.random() - 0.5) * 2;
        
        _fhDir.set(Math.random()*20, Math.random()*20, 0); 
        
        game.shellSystem.spawn(pos, _fhVec, 0xffd700, 2.0, 20, 1.0, 0, 0.7, _fhDir);
    };
    
    window.flux.spawnChargeParticles = (pos) => {
        if (!pos || !game.cubeParticles) return;
        // Throttle
        if (!checkVFXLimit('particles')) return;

        const radius = 2.5;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        _fhPos.set(
            pos.x + radius * Math.sin(phi) * Math.cos(theta),
            pos.y + radius * Math.cos(phi),
            pos.z + radius * Math.sin(phi) * Math.sin(theta)
        );
        
        _fhDir.subVectors(pos, _fhPos).normalize().multiplyScalar(15);
        game.cubeParticles.spawn(_fhPos, _fhDir, 0xffaa00, 0.2, 0, 1.0);
    };
    
    window.flux.spawnMassiveImpact = (pos) => {
        if (!pos) return;
        window.flux.spawnShockwave(pos);
        // Reduced massive impact particle count (50 -> 20)
        window.flux.spawnParticles(pos, 20, 0xffaa00, 60); 
        // Removed spawnDebris call
        window.flux.shake(3.0); 
        game.camVelSpring.z -= 30; 
        window.flux.slowMotion(0.8, 0.2); 
        if(window.flux.audio) window.flux.audio.play('massive_impact');
    };

    window.flux.spawnBlockParticles = (pos) => {
        if(!pos) return;
        window.flux.spawnParticles(pos, 5, 0x00ffff, 25);
        if(window.flux.audio) window.flux.audio.play('block');
    };
    
    window.flux.spawnTrail = (start, end) => {
        if (!start || !end) return;
        // Throttle trails
        if (!checkVFXLimit('trails')) return;

        const len = start.distanceTo(end);
        if(len < 0.01) return; 
        
        const width = 0.2; 
        let color = 0xff00aa;
        if (game.comboCount > 15) color = 0x00f3ff;
        if (game.player && game.player.isOverdrive) color = 0xff0000;
        
        // Use Pool
        if (game.trailMeshPool) {
            game.trailMeshPool.spawn(start, end, width, color, 0.15);
        }
    };
    
    window.flux.spawnShockwave = (pos) => {
        if(!pos || !game.particleGroup) return;
        // Throttle shockwaves
        if (!checkVFXLimit('distortion')) return;

        const mat = game.shockwavePool[game.shockwavePoolIdx];
        game.shockwavePoolIdx = (game.shockwavePoolIdx + 1) % 30;
        mat.opacity = 0.8;
        mat.color.setHex(0xffffff);
        const wave = new THREE.Mesh(new THREE.RingGeometry(0.5, 1.0, 32), mat);
        wave.position.copy(pos);
        wave.lookAt(game.camera.position); 
        wave.userData = { life: 0.3, grow: 60.0, gravity: 0 }; // Faster fade
        game.particleGroup.add(wave); 
    };

    window.flux.spawnEnemyProjectile = (start, dir) => {
        if (!game.projectileGroup) return;
        let proj;
        if (game.projectilePool.length > 0) {
            proj = game.projectilePool.pop();
            proj.visible = true;
        } else {
            const geo = new THREE.BoxGeometry(0.6, 0.6, 6.0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            proj = new THREE.Mesh(geo, mat);
            game.projectileGroup.add(proj);
        }
        proj.position.copy(start);
        proj.lookAt(start.clone().add(dir));
        proj.userData = { velocity: dir.clone().multiplyScalar(30), life: 2.0 };
        game.enemyProjectiles.push(proj);
    };
    
    window.flux.spawnLaser = (start, end, target) => {
        if (game.laserSystem) game.laserSystem.spawn(start, end, target);
    };
    
    window.flux.spawnSpaceTracer = (pos, dir) => {
        if (game.tracerSystem) game.tracerSystem.spawn(pos, dir);
    };
    
    window.flux.fireBossBeam = (start, end, duration, width) => {
        if (game.deathRay) game.deathRay.fire(start, end, duration, width);
    };

    window.flux.firePlayerBeam = (start, end) => {
        if (game.playerBeam) game.playerBeam.fire(start, end, 0.2, 0.5);
    };
    
    window.flux.spawnAnubisBeam = (start, end) => {
        if (game.deathRay) game.deathRay.fire(start, end, 0.5, 1.0);
    };
    
    window.flux.spawnVoidSlash = (pos, quat, scale) => {
        if (game.slashEffect) game.slashEffect.spawn(pos, quat, scale);
    };
    
    window.flux.spawnJudgmentLaser = (pos) => {
        if (game.judgmentBeams) {
            const beam = game.judgmentBeams.find(b => !b.active);
            if (beam) beam.spawn(pos);
        }
    };

    window.flux.spawnTechText = (text) => {
        if (typeof spawnFloatingText === 'function' && game.player) {
            const pos = game.player.mesh.position.clone().add(new THREE.Vector3(0, 2.5, 0));
            spawnFloatingText(pos, text, false, true); 
        }
        // AI Voice Integration - Only speak if it's a priority message
        // We don't want to narrate every "RELOAD" or "STYLE CHANGE"
        // Let's assume spawnTechText is mostly for player feedback, not critical warnings.
        // Critical warnings call ai.speak directly in game logic.
    };
    
    window.flux.setCameraFocus = (targetPos, lerpSpeed) => {
        if (game.cameraProxyTarget) game.cameraProxyTarget.copy(targetPos);
    };
    
    window.flux.clearCameraFocus = () => {};

    window.flux.explode = (pos) => {
        if (!pos) return;
        window.flux.spawnMassiveImpact(pos); 
        const radius = 8.0;
        const damage = 120;
        if (game.enemies) {
            game.enemies.forEach(enemy => {
                if (!enemy.userData.isDead) {
                    const dist = enemy.position.distanceTo(pos);
                    if (dist < radius) {
                        enemy.userData.hp -= damage;
                        const dir = new THREE.Vector3().subVectors(enemy.position, pos).normalize();
                        dir.y = 0.5; 
                        enemy.userData.velocity.add(dir.multiplyScalar(40));
                        enemy.userData.onGround = false;
                        if (enemy.userData.hp <= 0) window.flux.killEnemy(enemy);
                        else if (typeof flashEnemy === 'function') flashEnemy(enemy);
                    }
                }
            });
        }
        if (game.player && !game.player.isDead) {
            const dist = game.player.mesh.position.distanceTo(pos);
            if (dist < radius) {
                game.player.takeDamage(30);
                const dir = new THREE.Vector3().subVectors(game.player.mesh.position, pos).normalize();
                dir.y = 0.5;
                game.player.velocity.add(dir.multiplyScalar(30));
                game.player.isKnockedDown = true;
            }
        }
    };

    window.flux.killEnemy = (enemy) => {
        if(!enemy) return;
        enemy.userData.isDead = true;
        enemy.userData.respawnTimer = 5.0;
        enemy.visible = false;
        const deathPos = enemy.position.clone();
        enemy.position.y = -500; 
        if(window.flux.audio) {
            window.flux.audio.play('drone_death');
            window.flux.audio.play('massive_impact');
        }
        if (game.sparkParticles) {
            // REDUCED KILL SPARK COUNT (8 -> 4)
            for(let i=0; i<4; i++) { 
                _fhVec.set(
                    (Math.random()-0.5), 
                    (Math.random()-0.5), 
                    (Math.random()-0.5)
                ).normalize().multiplyScalar(20 + Math.random()*30);
                
                game.sparkParticles.spawn(deathPos, _fhVec, 0xffaa00, 0.6, 30, 1.5, -1, 0.6, null, 2.0);
            }
        }
        
        window.flux.spawnShockwave(deathPos);
        
        if (game.hitFlashPool) {
            const flash = game.hitFlashPool.get();
            flash.spawn(deathPos, game.camera.position);
        }
        
        window.flux.shake(1.5);
        window.flux.impactStop(0.15); 
        window.flux.triggerZoom(0.85, 0.2); 
        
        let dropColor = null;
        if (game.player) {
            if (game.player.currentWeapon === game.player.WEAPON_MELEE) {
                dropColor = 0xff0055; 
            } else {
                dropColor = 0x00ffff;
            }
        }
        if (typeof spawnPlasmaOrbs === 'function') {
            spawnPlasmaOrbs(game.lootOrbs, deathPos, 10, dropColor); // Reduced orb count
        }
        window.flux.addCombo(1.0); // Standard Kill
        if(enemy.userData.velocity) enemy.userData.velocity.set(0,0,0);
    };
    
    // UPDATED: Support for Efficiency Gate (Quality Multiplier)
    window.flux.addCombo = (quality = 1.0) => {
        if (quality <= 0) return; // No combo for deflected hits
        
        game.comboCount++;
        window.flux.comboCount = game.comboCount;
        
        // Timer duration depends on quality
        // High quality = 2.5s, Low quality = 1.0s
        const duration = 1.0 + (1.5 * quality);
        game.comboTimeout = Math.max(game.comboTimeout, duration);
        
        if (typeof updateHUD === 'function') updateHUD(game.comboCount);
    };

    window.flux.showDamage = (pos, amount, isCrit) => {
        if(!pos) return;
        if (typeof spawnFloatingText === 'function') {
            spawnFloatingText(pos, amount, isCrit);
        }
    };
    
    window.flux.showParry = (pos) => {
        if (typeof spawnFloatingText === 'function') {
            spawnFloatingText(pos, "PARRY", false, false, true);
        }
    };

    window.flux.onPlayerDeath = () => {
        const screen = document.getElementById('game-over-screen');
        if(screen) screen.classList.remove('hidden');
        if(window.flux.audio) window.flux.audio.play('death');
        window.flux.slowMotion(2.0, 0.1); 
    };
    
    window.flux.spawnSpaceExplosion = (pos, scale) => {
        if (game.spaceExplosionPool) {
            const exp = game.spaceExplosionPool.get();
            exp.spawn(pos, scale);
        }
    };
}</script>
    <script>/**
 * MAIN GAME LOOP - OPTIMIZED & KINEMATIC
 * Implements Dynamic Resolution Scaling, Instanced Particles, and Herculean Camera
 * OPTIMIZED: Reduced DOM Thrashing in Update Loop.
 * OPTIMIZED: Implemented Static Vector Pooling to eliminate GC spikes.
 * OPTIMIZED: Implemented Object Pooling for VFX.
 * OPTIMIZED: Fixed Update Order (Physics -> Camera -> Animation) to prevent jitter.
 * CRITICAL FIX: Added NaN Safety Checks for Camera Vectors.
 * PERF FIX: Dynamic LOD (Level of Detail) for AI and Projectiles.
 * UPDATE: HERCULEAN CAMERA SYSTEM (Dynamic Framing, Trauma, Tilt).
 * CRITICAL FIX: Replaced Euler Angles with Quaternions to eliminate Gimbal Lock.
 * UPDATE: Smoothed Camera & Restored Lock-On Cursor.
 * UPDATE: Increased Camera Distance (Pulled Back).
 * UPDATE: Added Photon Network Manager for Multiplayer.
 * FIX: Added Photon SDK Wait Logic to prevent race conditions.
 * DEBUG: Added On-Screen Connection Diagnostics.
 * UPDATE: Added Room Code Input Logic.
 * UPDATE: Robust Offline Fallback for Mobile/Local environments.
 */

// --- STATIC REUSABLE VECTORS (GC OPTIMIZATION) ---
const _gVec1 = new THREE.Vector3();
const _gVec2 = new THREE.Vector3();
const _gVec3 = new THREE.Vector3();
const _gLookTarget = new THREE.Vector3();
const _gUp = new THREE.Vector3(0, 1, 0);
const _gCamForward = new THREE.Vector3();
const _gCamRight = new THREE.Vector3();
const _gCamDir = new THREE.Vector3();
const _gCamPos = new THREE.Vector3();
const _gProjRay = new THREE.Raycaster(); // Static raycaster for projectiles

// --- CAMERA MATH STATICS (QUATERNION FIX) ---
const _gCamMat = new THREE.Matrix4();
const _gCamQuat = new THREE.Quaternion();
const _gRollQuat = new THREE.Quaternion();
const _gPitchQuat = new THREE.Quaternion();
const _gYawQuat = new THREE.Quaternion();
const _gZAxis = new THREE.Vector3(0, 0, 1);
const _gXAxis = new THREE.Vector3(1, 0, 0);

// --- DYNAMIC LOD CONSTANTS ---
// Distances are squared to avoid expensive Math.sqrt() calls
const COMBAT_DISTANCE_SQ = 225;    // 15 units - Every frame (Smooth)
const CLOSE_DISTANCE_SQ = 900;     // 30 units - Every 2 frames
const MEDIUM_DISTANCE_SQ = 3600;   // 60 units - Every 3 frames
const FAR_DISTANCE_SQ = 10000;     // 100 units - Every 4 frames
// > 100 units - Every 6 frames

// --- HERCULEAN CAMERA CONFIGURATION (PULLED BACK) ---
// "Juicy" presets for different gameplay states
// UPDATED: Increased distance and height to prevent crowding the player
const CAM_CONFIG = {
    // Standard exploration: Balanced, slight lag for weight
    // Increased dist from 8.0 -> 12.0, height 3.5 -> 4.5
    DEFAULT: { dist: 12.0, height: 4.5, fov: 80, lookY: 2.0, lag: 0.1, tilt: 0.1, stiffness: 3.0 },
    
    // Combat: Pulled back slightly, higher up to see enemies, stiffer tracking
    // Increased dist from 9.5 -> 14.0, height 5.0 -> 6.0
    COMBAT:  { dist: 14.0, height: 6.0, fov: 85, lookY: 1.5, lag: 0.05, tilt: 0.1, stiffness: 5.0 },
    
    // Dash: Wide FOV, low to ground, heavy tilt for speed sensation
    // Increased dist from 10.0 -> 13.0
    DASH:    { dist: 13.0, height: 3.5, fov: 95, lookY: 1.5, lag: 0.2, tilt: 0.5, stiffness: 4.0 },
    
    // Aiming: Tight over-the-shoulder, very stiff (precision)
    // Kept relatively tight but adjusted height
    AIM:     { dist: 5.0, height: 2.0, fov: 60, lookY: 1.5, lag: 0.02, tilt: 0.0, stiffness: 10.0 },
    
    // Lock-on: Focused, keeps target in view
    // Increased dist from 9.0 -> 13.0
    LOCK:    { dist: 13.0, height: 5.0, fov: 85, lookY: 1.0, lag: 0.05, tilt: 0.1, stiffness: 6.0 },
    
    // Aerial: High angle to see landing spots
    // Increased dist from 10.0 -> 15.0
    AIR:     { dist: 15.0, height: 8.0, fov: 90, lookY: 0.0, lag: 0.15, tilt: 0.0, stiffness: 4.0 }
};

class FluxGame {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.composer = null;
        this.player = null;
        this.input = null;
        this.clock = new THREE.Clock();
        
        // State
        this.isPaused = false;
        this.cinematicActive = false;
        this.enablePostProcessing = true;
        this.currentStage = 'CITY';
        
        // Groups
        this.staticGroup = null;
        this.enemyGroup = null;
        this.vfxGroup = null;
        this.particleGroup = null;
        this.trailGroup = null;
        this.dustGroup = null;
        this.rainGroup = null;
        this.ghostGroup = null;
        this.projectileGroup = null;
        this.vectorTrapGroup = null;
        
        // Systems
        this.cubeParticles = null;
        this.sparkParticles = null;
        this.debrisSystem = null;
        this.shellSystem = null;
        this.laserSystem = null;
        this.spawnSystem = null;
        this.deathRay = null;
        this.playerBeam = null;
        this.lootOrbs = null;
        this.weatherSystem = null; 
        this.spaceSystem = null;
        this.tracerSystem = null;
        this.stageDynamics = null; 
        
        // VFX Pools
        this.spaceExplosionPool = null;
        this.hitFlashPool = null;
        this.distortionPool = null; 
        this.ghostPool = null; 
        this.trailMeshPool = null; 
        
        // Boss VFX
        this.slashEffect = null;
        this.judgmentBeams = [];
        
        // Post Processing
        this.bloomPass = null;
        this.rgbShiftPass = null;
        
        // Enemies
        this.enemies = []; // Shared Array
        this.enemyProjectiles = []; 
        this.projectilePool = [];   
        
        // Pools
        this.shockwavePool = [];
        this.shockwavePoolIdx = 0;
        this.indicatorPool = [];
        
        // --- HERCULEAN CAMERA STATE ---
        this.cameraProxyTarget = new THREE.Vector3(0, 10, 0); 
        this.camPosSpring = new THREE.Vector3(0, 10, 10);
        this.camVelSpring = new THREE.Vector3(0, 0, 0);
        this.camLookSpring = new THREE.Vector3(0, 0, 0);
        
        // Active Camera Settings (Interpolated)
        this.activeCamSettings = { ...CAM_CONFIG.DEFAULT };
        
        // Camera Noise (Perlin-ish)
        this.noiseOffset = 0;
        this.trauma = 0; // 0 to 1, decays linearly
        
        this.manualCamTimer = 0; 
        
        // Dynamic Zoom (Juice)
        this.cameraZoom = 1.0;
        this.cameraZoomTarget = 1.0;
        this.cameraZoomSpeed = 10.0;
        
        // Juice
        this.shakeIntensity = 0; // Legacy support
        this.chromaticAberrationIntensity = 0;
        this.timeScale = 1.0;
        this.slowMoTimer = 0;
        this.targetTimeScale = 1.0;
        
        // Combo
        this.comboCount = 0;
        this.comboTimeout = 0;
        
        // Audio Throttling
        this.orbSoundCooldown = 0;
        
        // Transparency
        this.fadedObjects = [];
        this.camRaycaster = new THREE.Raycaster();
        
        // Debug
        this.frameCount = 0;
        this.frameIndex = 0; // For staggered updates
        this.lastTime = 0;
        this.debugText = document.getElementById('fps-counter');
        this.debugLOD = false; // Toggle to visualize LOD zones
        
        // Bestiary State
        this.isBestiaryOpen = false;
        this.bestiaryScene = null;
        this.bestiaryCamera = null;
        this.bestiaryModel = null;
        this.bestiaryRenderer = null;
        this.bestiaryModels = [];
        this.currentBestiaryIndex = 0;

        // Multiplayer State
        this.network = null;
        this.remotePlayers = new Map(); // Store other players
    }

    init() {
        console.log("Flux Engine: Initializing Optimized Core...");
        
        const canvas = document.getElementById('game-canvas');

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x050510);
        this.scene.fog = new THREE.FogExp2(0x050510, 0.015);

        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100000); 
        this.camera.position.set(0, 10, 10);
        this.camera.lookAt(0, 0, 0);

        this.renderer = new THREE.WebGLRenderer({ 
            canvas: canvas, 
            antialias: false, 
            powerPreference: "high-performance",
            stencil: false,
            depth: true,
            logarithmicDepthBuffer: false 
        });
        
        this.renderer.setPixelRatio(0.5); 
        this.renderer.setSize(window.innerWidth, window.innerHeight, false);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.BasicShadowMap; 
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ReinhardToneMapping;
        this.renderer.toneMappingExposure = 2.5; 

        this.initPostProcessing(window.innerWidth, window.innerHeight);
        this.initLighting();
        this.initGroups();
        this.initSystems();
        
        this.loadStage('CITY');
        
        this.initIndicators();

        this.input = new InputSystem();
        
        if (typeof initFluxHelpers === 'function') {
            initFluxHelpers(this);
        }
        
        if (typeof initUI === 'function') {
            initUI(this); 
        }
        
        this.player = new Player(this.scene, this.staticGroup, this.enemyGroup);
        
        if (typeof SpaceSystem !== 'undefined') {
            this.spaceSystem = new SpaceSystem(this.scene, this.camera, this.player, this);
        }
        
        if (typeof StageDynamics !== 'undefined') {
            this.stageDynamics = new StageDynamics(this.scene, this);
            this.stageDynamics.registerStageObjects(this.staticGroup);
        }
        
        window.flux.player = this.player;

        // Initialize Multiplayer (Async)
        this.initMultiplayer();

        const gameOverScreen = document.getElementById('game-over-screen');
        if(gameOverScreen) {
            gameOverScreen.addEventListener('click', () => {
                if(this.player && this.player.isDead) {
                    this.player.reset();
                    gameOverScreen.classList.add('hidden');
                    if (window.flux.audio) window.flux.audio.play('startup');
                }
            });
        }
        
        window.addEventListener('keydown', (e) => {
            if (e.key === 'l' || e.key === 'L') {
                if (this.spaceSystem) this.spaceSystem.triggerLaunch();
            }
            // Debug toggle for LOD
            if (e.key === '0') {
                this.debugLOD = !this.debugLOD;
                console.log("LOD Debug:", this.debugLOD);
            }
        });
        
        const btnLaunch = document.getElementById('btn-launch');
        if (btnLaunch) {
            btnLaunch.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this.spaceSystem) this.spaceSystem.triggerLaunch();
                if (window.navigator && window.navigator.vibrate) window.navigator.vibrate(50);
            });
            
            btnLaunch.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this.spaceSystem) this.spaceSystem.triggerLaunch();
                if (window.navigator && window.navigator.vibrate) window.navigator.vibrate(50);
            }, { passive: false });
        }

        window.addEventListener('resize', () => this.onWindowResize(), false);
        this.onWindowResize();
        
        this.animate();
    }

    async waitForPhoton() {
        return new Promise((resolve) => {
            if (typeof Photon !== 'undefined') {
                resolve();
                return;
            }
            
            console.log("Waiting for Photon SDK...");
            const checkInterval = setInterval(() => {
                if (typeof Photon !== 'undefined') {
                    clearInterval(checkInterval);
                    console.log("Photon SDK loaded.");
                    resolve();
                }
            }, 100);
            
            // Timeout after 3 seconds (Reduced from 10s for faster offline fallback)
            setTimeout(() => {
                clearInterval(checkInterval);
                console.warn("Photon SDK load timeout.");
                resolve(); // Resolve anyway to allow offline mode
            }, 3000);
        });
    }

    async initMultiplayer() {
        // --- DEBUG OVERLAY UPDATE FUNCTION ---
        function updateDebug(status, room, players, myId) {
            const statusEl = document.getElementById('debug-status');
            const roomEl = document.getElementById('debug-room');
            const playersEl = document.getElementById('debug-players');
            const myIdEl = document.getElementById('debug-myid');
            
            if (statusEl) statusEl.textContent = status;
            if (roomEl) roomEl.textContent = room || '---';
            if (playersEl) playersEl.textContent = players;
            if (myIdEl) myIdEl.textContent = myId || '---';
        }

        // Initial state
        updateDebug('Connecting...', null, 0, null);

        // Wait for Photon SDK to load
        await this.waitForPhoton();

        if (typeof Photon === 'undefined') {
             console.warn("Photon SDK unavailable, running in offline mode");
             updateDebug('Offline Mode', null, 0, null);
             return;
        }

        if (typeof PhotonNetworkManager === 'undefined') {
            console.warn("PhotonNetworkManager not loaded.");
            updateDebug('Offline Mode', null, 0, null);
            return;
        }

        this.network = new PhotonNetworkManager("567c317e-4d83-483e-ab5c-a2cab64d54b4");
        
        this.network.onPlayerJoined = (actor) => {
            // Create mesh for remote player
            // r128 compatibility: Use Cylinder instead of Capsule
            const mesh = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16),
                new THREE.MeshStandardMaterial({color: 0xff0055})
            );
            mesh.position.y = 1; // Adjust height
            this.scene.add(mesh);
            this.remotePlayers.set(actor.actorNr, {mesh, targetPos: new THREE.Vector3()});
            
            if (window.flux.spawnTechText) window.flux.spawnTechText(`PLAYER ${actor.actorNr} JOINED`);
            
            // Update Debug
            const playerCount = this.remotePlayers.size + 1;
            updateDebug('Connected', this.network.roomName, playerCount, this.network.myActorNumber);
        };
        
        this.network.onPlayerLeft = (actor) => {
            const remote = this.remotePlayers.get(actor.actorNr);
            if (remote) {
                this.scene.remove(remote.mesh);
                this.remotePlayers.delete(actor.actorNr);
                if (window.flux.spawnTechText) window.flux.spawnTechText(`PLAYER ${actor.actorNr} LEFT`);
                
                // Update Debug
                const playerCount = this.remotePlayers.size + 1;
                updateDebug('Connected', this.network.roomName, playerCount, this.network.myActorNumber);
            }
        };
        
        this.network.onPlayerStateUpdate = (actorNr, data) => {
            const remote = this.remotePlayers.get(actorNr);
            if (remote) {
                remote.targetPos.set(data.x, data.y, data.z);
                remote.mesh.rotation.y = data.rotY;
            }
        };
        
        try {
            // GET ROOM CODE FROM INPUT
            const roomInput = document.getElementById('room-code-input');
            // Default to random room or test room if empty
            const roomCode = (roomInput && roomInput.value.trim().length > 0) 
                ? roomInput.value.trim().toUpperCase() 
                : "TEST_ROOM_123";

            await this.network.connect("Player" + Math.floor(Math.random() * 1000), roomCode);
            console.log("Multiplayer Connected to room:", roomCode);
            
            // Update Debug on success
            updateDebug('Connected', this.network.roomName, this.remotePlayers.size + 1, this.network.myActorNumber);
            
        } catch (e) {
            console.warn("Multiplayer connection failed:", e);
            updateDebug('Failed: ' + e.message, null, 0, null);
        }
    }
    
    loadStage(stageType) {
        console.log(`Game: Loading Stage ${stageType}`);
        this.currentStage = stageType;
        
        if (typeof buildWorld === 'function') {
            buildWorld(this.staticGroup, stageType);
        }
        
        if (this.stageDynamics) {
            this.stageDynamics.registerStageObjects(this.staticGroup);
        }
        
        this.enemies.forEach(e => {
            if (e.userData.controller) e.userData.controller.handleDeath();
            else e.visible = false;
        });
        
        this.enemies.length = 0; 
        this.enemyGroup.clear();
        
        if (typeof DroneSpawnSystem !== 'undefined') {
            this.spawnSystem = new DroneSpawnSystem(this.scene, this.enemyGroup, stageType);
        }
        
        if (this.weatherSystem) {
            if (stageType === 'ICE') this.weatherSystem.setMode('SNOW');
            else if (stageType === 'WASTELAND') this.weatherSystem.setMode('SAND');
            else if (stageType === 'VOID') this.weatherSystem.setMode('VOID');
            else if (stageType === 'CITY') this.weatherSystem.setMode('RAIN');
            else this.weatherSystem.setMode('SNOW'); 
        }
        
        if (window.flux.spawnTechText) {
            window.flux.spawnTechText(`STAGE: ${stageType}`);
        }
    }
    
    triggerReentry(stageType) {
        console.log(`Game: Triggering Re-entry to ${stageType}`);
        
        const flashDiv = document.createElement('div');
        flashDiv.style.position = 'fixed';
        flashDiv.style.top = '0';
        flashDiv.style.left = '0';
        flashDiv.style.width = '100%';
        flashDiv.style.height = '100%';
        flashDiv.style.backgroundColor = 'white';
        flashDiv.style.zIndex = '9999';
        flashDiv.style.transition = 'opacity 2s ease-out';
        document.body.appendChild(flashDiv);
        
        this.player.isSpaceMode = false;
        this.player.isBoosting = false;
        this.player.isFirstPerson = false; 
        this.player.camPitch = 0; 
        this.player.velocity.set(0, -50, 0); 
        this.player.mesh.position.set(0, 100, 0); 
        this.player.mesh.rotation.set(0, 0, 0);
        this.player.mesh.quaternion.identity(); 
        
        this.camera.up.set(0, 1, 0); 
        this.camera.position.set(0, 110, 20);
        this.camera.lookAt(0, 100, 0);
        this.camera.rotation.set(0, 0, 0); 
        this.camera.quaternion.setFromEuler(this.camera.rotation); 
        this.camera.fov = this.baseFOV;
        this.camera.updateProjectionMatrix();
        
        this.camPosSpring.copy(this.camera.position);
        this.camVelSpring.set(0, 0, 0);
        this.cameraProxyTarget.copy(this.player.mesh.position);
        
        if (this.spaceSystem) {
            this.spaceSystem.active = false;
            this.spaceSystem.spaceGroup.visible = false;
            if (this.spaceSystem.radarEl) this.spaceSystem.radarEl.style.display = 'none';
            if (this.spaceSystem.hudOverlay) this.spaceSystem.hudOverlay.style.display = 'none';
        }
        
        this.staticGroup.visible = true;
        this.dustGroup.visible = true;
        
        this.loadStage(stageType);
        
        if (window.flux.audio) {
            window.flux.audio.play('massive_impact');
            window.flux.audio.playBGM('bgm_standard', 2.0);
        }
        
        setTimeout(() => {
            flashDiv.style.opacity = '0';
            setTimeout(() => document.body.removeChild(flashDiv), 2000);
        }, 100);
    }
    
    initLighting() {
        const hemiLight = new THREE.HemisphereLight(0x111122, 0x000000, 0.4); 
        hemiLight.position.set(0, 50, 0);
        this.scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2.5); 
        dirLight.position.set(20, 40, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(512, 512); 
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -40;
        dirLight.shadow.camera.right = 40;
        dirLight.shadow.camera.top = 40;
        dirLight.shadow.camera.bottom = -40;
        dirLight.shadow.bias = -0.0005;
        this.scene.add(dirLight);
        
        const rimLight = new THREE.DirectionalLight(0x00f3ff, 4.0); 
        rimLight.position.set(-10, 20, -30);
        this.scene.add(rimLight);
        
        const fillLight = new THREE.DirectionalLight(0xff0055, 1.0);
        fillLight.position.set(-20, 10, 20);
        this.scene.add(fillLight);
    }
    
    initGroups() {
        this.staticGroup = new THREE.Group();
        this.staticGroup.matrixAutoUpdate = false; 
        this.scene.add(this.staticGroup);

        this.enemyGroup = new THREE.Group();
        this.scene.add(this.enemyGroup);

        this.vfxGroup = new THREE.Group();
        this.scene.add(this.vfxGroup);

        this.particleGroup = new THREE.Group(); 
        this.vfxGroup.add(this.particleGroup);
        this.trailGroup = new THREE.Group();
        this.vfxGroup.add(this.trailGroup);
        this.dustGroup = new THREE.Group();
        this.vfxGroup.add(this.dustGroup);
        this.rainGroup = new THREE.Group();
        this.vfxGroup.add(this.rainGroup);
        this.ghostGroup = new THREE.Group();
        this.vfxGroup.add(this.ghostGroup);
        this.projectileGroup = new THREE.Group();
        this.vfxGroup.add(this.projectileGroup);
        this.vectorTrapGroup = new THREE.Group();
        this.vfxGroup.add(this.vectorTrapGroup);
        
        window.flux.staticGroup = this.staticGroup;
        window.flux.enemies = this.enemies;
    }
    
    initSystems() {
        const cubeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
        const cubeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        this.cubeParticles = new InstancedParticleSystem(this.scene, 1500, cubeGeo, cubeMat); 
        this.cubeParticles.mesh.frustumCulled = false;

        const sparkGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8);
        const sparkMat = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false
        });
        this.sparkParticles = new InstancedParticleSystem(this.scene, 2000, sparkGeo, sparkMat); 
        this.sparkParticles.mesh.frustumCulled = false;

        const debrisGeo = new THREE.TetrahedronGeometry(0.2, 0); 
        const debrisMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8 });
        this.debrisSystem = new InstancedParticleSystem(this.scene, 500, debrisGeo, debrisMat);
        this.debrisSystem.mesh.frustumCulled = false;

        const shellGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8);
        shellGeo.rotateX(Math.PI/2); 
        const shellMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
        this.shellSystem = new InstancedParticleSystem(this.scene, 150, shellGeo, shellMat);
        this.shellSystem.mesh.frustumCulled = false;
        
        const orbGeo = new THREE.IcosahedronGeometry(0.25, 0);
        const orbMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 1.0,
            depthWrite: false
        });
        this.lootOrbs = new InstancedParticleSystem(this.particleGroup, 2000, orbGeo, orbMat);
        this.lootOrbs.mesh.frustumCulled = false;
        
        if (typeof WeatherSystem !== 'undefined') {
            this.weatherSystem = new WeatherSystem(this.scene, 1000); 
        }
        
        if (typeof HomingLaserSystem !== 'undefined') {
            this.laserSystem = new HomingLaserSystem(this.scene, 50); 
        }
        
        if (typeof TracerSystem !== 'undefined') {
            this.tracerSystem = new TracerSystem(this.scene, 30); 
        }
        
        if (typeof RibbonTrail !== 'undefined') {
            window.flux.trails = {
                wingL: new RibbonTrail(this.scene, 20, 0.15, 0xff0055),
                wingR: new RibbonTrail(this.scene, 20, 0.15, 0xff0055),
                footL: new RibbonTrail(this.scene, 15, 0.15, 0xff0055),
                footR: new RibbonTrail(this.scene, 15, 0.15, 0xff0055)
            };
        }
        
        if (typeof DeathRay !== 'undefined') {
            this.deathRay = new DeathRay(this.scene);
            this.playerBeam = new DeathRay(this.scene);
            this.playerBeam.mesh.material.color.setHex(0x00ffff);
        }
        
        if (typeof SlashEffect !== 'undefined') {
            this.slashEffect = new SlashEffect(this.scene);
        }
        
        if (typeof JudgmentBeam !== 'undefined') {
            for(let i=0; i<10; i++) {
                this.judgmentBeams.push(new JudgmentBeam(this.scene));
            }
        }
        
        if (typeof ObjectPool !== 'undefined' && typeof SpaceExplosion !== 'undefined') {
            this.spaceExplosionPool = new ObjectPool(() => new SpaceExplosion(this.scene), 10);
        }
        
        if (typeof ObjectPool !== 'undefined' && typeof HitFlash !== 'undefined') {
            this.hitFlashPool = new ObjectPool(() => new HitFlash(this.particleGroup), 15);
        }
        
        if (typeof ObjectPool !== 'undefined' && typeof DistortionWave !== 'undefined') {
            this.distortionPool = new ObjectPool(() => new DistortionWave(this.scene), 5);
        }
        
        const shockwaveGeo = new THREE.RingGeometry(0.5, 1.0, 16);
        const shockwaveMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.4, 
            side: THREE.DoubleSide, 
            depthWrite: false, 
            blending: THREE.AdditiveBlending
        });
        for(let i=0; i<30; i++) this.shockwavePool.push(shockwaveMat.clone());
    }
    
    initPostProcessing(width, height) {
        this.composer = new THREE.EffectComposer(this.renderer);
        const renderPass = new THREE.RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        this.bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(width/2, height/2), 0.6, 0.5, 0.8);
        this.composer.addPass(this.bloomPass);

        this.rgbShiftPass = new THREE.ShaderPass(THREE.RGBShiftShader);
        this.rgbShiftPass.uniforms['amount'].value = 0.0005; 
        this.composer.addPass(this.rgbShiftPass);
    }
    
    initIndicators() {
        const container = document.getElementById('offscreen-indicators');
        if (!container) return;
        for (let i = 0; i < 10; i++) {
            const el = document.createElement('div');
            el.className = 'indicator-arrow';
            el.style.display = 'none';
            container.appendChild(el);
            this.indicatorPool.push({ el: el, visible: false }); // Track visibility state
        }
    }

    onWindowResize() {
        this.renderer.setSize(window.innerWidth, window.innerHeight, false);
        this.composer.setSize(window.innerWidth, window.innerHeight);
        const aspect = window.innerWidth / window.innerHeight;
        let vFOV;
        if (aspect < 1.0) {
            vFOV = 85; 
        } else {
            vFOV = 2 * Math.atan( Math.tan( (this.TARGET_HORIZONTAL_FOV * Math.PI) / 360 ) / aspect ) * (180 / Math.PI);
        }
        this.baseFOV = vFOV; 
        this.camera.aspect = aspect;
        this.camera.fov = vFOV;
        this.camera.updateProjectionMatrix();
        if (this.bestiaryCamera) {
            this.bestiaryCamera.aspect = aspect;
            this.bestiaryCamera.updateProjectionMatrix();
        }
    }

    updateCameraTransparency(cam, targetMesh) {
        const dir = new THREE.Vector3().subVectors(targetMesh.position, cam.position);
        const dist = dir.length();
        dir.normalize();
        this.camRaycaster.set(cam.position, dir);
        this.camRaycaster.far = dist - 0.5; 
        const intersects = this.camRaycaster.intersectObjects(this.staticGroup.children, true);
        const objectsToFade = new Set();
        for (let hit of intersects) {
            let obj = hit.object;
            if (obj.isMesh && !obj.isInstancedMesh) objectsToFade.add(obj);
        }
        for (let i = this.fadedObjects.length - 1; i >= 0; i--) {
            let obj = this.fadedObjects[i];
            if (!objectsToFade.has(obj)) {
                if (obj.userData.originalMaterial) {
                    obj.material = obj.userData.originalMaterial;
                    delete obj.userData.originalMaterial;
                }
                this.fadedObjects.splice(i, 1);
            }
        }
        for (let obj of objectsToFade) {
            if (!this.fadedObjects.includes(obj)) {
                if (!obj.userData.originalMaterial) obj.userData.originalMaterial = obj.material;
                if (!Array.isArray(obj.material)) {
                    const newMat = obj.material.clone();
                    newMat.transparent = true;
                    newMat.opacity = 0.25;
                    newMat.depthWrite = false; 
                    obj.material = newMat;
                    this.fadedObjects.push(obj);
                }
            }
        }
    }

    setQuality(level) {
        if (level === 'low') {
            this.enablePostProcessing = false;
            this.renderer.shadowMap.enabled = false;
            console.log("Flux Engine: Quality set to LOW");
        } else {
            this.enablePostProcessing = true;
            this.renderer.shadowMap.enabled = true;
            console.log("Flux Engine: Quality set to HIGH");
        }
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        try {
            const rawDt = this.clock.getDelta();
            const avgDt = Math.min(rawDt, 0.1); 
            
            if (this.cinematicActive) {
                if (!document.body.classList.contains('cinematic-active')) document.body.classList.add('cinematic-active');
            } else {
                if (document.body.classList.contains('cinematic-active')) document.body.classList.remove('cinematic-active');
            }
            
            if (this.isBestiaryOpen && this.bestiaryScene && this.bestiaryCamera && this.bestiaryRenderer) {
                if (this.bestiaryModel) this.bestiaryModel.rotation.y += avgDt * 0.5;
                this.bestiaryRenderer.render(this.bestiaryScene, this.bestiaryCamera);
                return;
            }

            if (this.isPaused) return;
            
            this.frameCount++;
            this.frameIndex++; // PERF: Frame index for staggering
            const now = performance.now();
            if (now - this.lastTime >= 1000) {
                const fps = this.frameCount;
                if (this.debugText) this.debugText.innerText = fps;
                this.frameCount = 0;
                this.lastTime = now;
            }

            // UPDATE INPUT VISUALS (Decoupled from Event Loop)
            if (this.input && this.input.updateVisuals) this.input.updateVisuals();

            // UPDATE NETWORK
            if (this.network) {
                this.network.service();
                
                // Send your position every frame
                if (this.player && this.player.mesh) {
                    this.network.sendPosition(
                        this.player.mesh.position.x,
                        this.player.mesh.position.y,
                        this.player.mesh.position.z,
                        this.player.mesh.rotation.y
                    );
                }
                
                // Update remote player positions
                this.remotePlayers.forEach(remote => {
                    remote.mesh.position.lerp(remote.targetPos, 0.1);
                    remote.mesh.rotation.y = THREE.MathUtils.lerp(remote.mesh.rotation.y, remote.targetPos.rotY || 0, 0.1);
                });
            }

            if (this.slowMoTimer > 0) {
                this.slowMoTimer -= avgDt;
                this.timeScale += (this.targetTimeScale - this.timeScale) * 10 * avgDt;
            } else {
                this.timeScale += (1.0 - this.timeScale) * 5 * avgDt;
            }
            
            if (window.flux.audio) window.flux.audio.setSlowMo(this.timeScale);
            
            let gameDt = avgDt * this.timeScale;
            if (gameDt > 0.05) gameDt = 0.05; 

            if (this.comboTimeout > 0) {
                this.comboTimeout -= rawDt; 
                if (this.comboTimeout <= 0) {
                    const xpBonus = Math.floor(this.comboCount * 10 * (this.player.level || 1));
                    if (window.flux.awardXp) {
                        window.flux.awardXp(xpBonus);
                        if (typeof spawnFloatingText === 'function') {
                             spawnFloatingText(this.player.mesh.position, `COMBO BANK: ${xpBonus}`, true);
                        }
                    }
                    
                    this.comboCount = 0;
                    window.flux.comboCount = 0;
                    if (typeof updateHUD === 'function') updateHUD(0);
                }
            }
            
            if (this.orbSoundCooldown > 0) {
                this.orbSoundCooldown -= rawDt;
            }
            
            if (Math.abs(this.cameraZoom - this.cameraZoomTarget) > 0.001) {
                this.cameraZoom += (this.cameraZoomTarget - this.cameraZoom) * this.cameraZoomSpeed * gameDt;
            } else {
                this.cameraZoom = this.cameraZoomTarget;
            }
            
            if (this.cameraZoomTarget !== 1.0) {
                this.cameraZoomTarget += (1.0 - this.cameraZoomTarget) * 2.0 * gameDt;
            }

            if (this.spaceSystem) this.spaceSystem.update(gameDt);
            
            // --- UPDATED RENDER LOOP ORDER ---
            // 1. Physics & Logic (Moves Player Mesh)
            if (!this.cinematicActive) {
                if (this.player && this.input) this.player.update(gameDt, this.input, this.camera);
            }
            
            // 2. Camera Logic (Follows Player Mesh)
            if (this.player && this.player.mesh && !this.player.isSpaceMode && !this.spaceSystem.launching && !this.cinematicActive) {
                this.updateCameraLogic(gameDt);
            }
            
            // 3. Animation / IK (Depends on Camera Position)
            if (this.player && !this.cinematicActive) {
                // PERF: Only update IK every 2 frames unless attacking
                if (this.player.isAttacking || this.frameIndex % 2 === 0) {
                    this.player.updateAnimation(gameDt, this.camera);
                }
            }
            
            // 4. Update Lock-On Cursor (Ground Mode)
            if (this.player && !this.player.isSpaceMode && !this.cinematicActive) {
                this.updateLockOnCursor();
            }
            
            // --- END UPDATED ORDER ---
            
            // PERF: Staggered Spawn System update (every 10 frames)
            if (this.frameIndex % 10 === 0) {
                if (this.spawnSystem && this.player) this.spawnSystem.update(gameDt * 10, this.player);
            }
            
            if (this.deathRay) this.deathRay.update(gameDt);
            if (this.playerBeam) this.playerBeam.update(gameDt);
            if (this.slashEffect) this.slashEffect.update(gameDt);
            if (this.judgmentBeams) this.judgmentBeams.forEach(b => b.update(gameDt));
            if (this.tracerSystem) this.tracerSystem.update(gameDt); 
            if (this.stageDynamics) this.stageDynamics.update(gameDt, this.player); 
            
            // PERF: Staggered Particle Updates
            if (this.frameIndex % 2 === 0) {
                if (this.cubeParticles) this.cubeParticles.update(gameDt * 2);
                if (this.sparkParticles) this.sparkParticles.update(gameDt * 2);
                if (this.debrisSystem) this.debrisSystem.update(gameDt * 2);
                if (this.shellSystem) this.shellSystem.update(gameDt * 2);
                if (this.weatherSystem) this.weatherSystem.update(gameDt * 2, this.player ? this.player.mesh.position : null);
            }
            
            if (this.spaceExplosionPool) this.spaceExplosionPool.update(gameDt);
            if (this.hitFlashPool) this.hitFlashPool.update(gameDt);
            if (this.distortionPool) this.distortionPool.update(gameDt);
            if (this.ghostPool) this.ghostPool.update(gameDt); 
            if (this.trailMeshPool) this.trailMeshPool.update(gameDt); 

            // PERF: Swap-and-Pop for Trail Group
            if (this.trailGroup) {
                for(let i = this.trailGroup.children.length - 1; i >= 0; i--) {
                    const t = this.trailGroup.children[i];
                    if (t.userData.life !== undefined) {
                        t.userData.life -= gameDt;
                        if(t.material) t.material.opacity = t.userData.life * 4.0;
                        if(t.userData.life <= 0) {
                            this.trailGroup.remove(t);
                            if(t.geometry) t.geometry.dispose();
                            if(t.material) t.material.dispose();
                        }
                    }
                }
            }
            
            if (this.ghostGroup && this.ghostGroup.children.length > 0) {
                 this.ghostGroup.clear();
            }

            // PERF: Swap-and-Pop for Particle Group (Manual cleanup)
            if (this.particleGroup) {
                // Only clean up every few frames to save iteration
                if (this.frameIndex % 4 === 0) {
                    for(let i = this.particleGroup.children.length - 1; i >= 0; i--) {
                        const p = this.particleGroup.children[i];
                        if (p.isInstancedMesh) continue;
                        if (p.userData.life !== undefined) {
                            p.userData.life -= gameDt * 4; // compensate for skipped frames
                            if(p.userData.grow) p.scale.multiplyScalar(1.0 + (p.userData.grow * gameDt * 4));
                            if(p.material) p.material.opacity = p.userData.life * 2.0;
                            if(p.userData.life <= 0) {
                                this.particleGroup.remove(p);
                                if(p.geometry) p.geometry.dispose();
                                if(p.material) p.material.dispose();
                            }
                        }
                    }
                }
            }
            
            if (this.deathRay && this.deathRay.active && this.player && !this.player.isDead) {
                const p = this.player.mesh.position;
                const a = this.deathRay.startPos;
                const b = this.deathRay.endPos;
                _gVec1.subVectors(b, a); // ab
                _gVec2.subVectors(p, a); // ap
                const t = Math.max(0, Math.min(1, _gVec2.dot(_gVec1) / _gVec1.lengthSq()));
                _gVec3.copy(a).addScaledVector(_gVec1, t);
                const dist = p.distanceTo(_gVec3);
                const beamWidth = this.deathRay.mesh.scale.x; 
                if (dist < beamWidth + 1.0) { 
                    this.player.takeDamage(50 * gameDt); 
                    if (window.flux.spawnParticles) window.flux.spawnParticles(p, 2, 0xff00ff, 5);
                }
            }
            
            // PERF: DYNAMIC LOD FOR PROJECTILES
            if (this.enemyProjectiles && this.player) {
                const pPos = this.player.mesh.position;
                
                for (let i = this.enemyProjectiles.length - 1; i >= 0; i--) {
                    const proj = this.enemyProjectiles[i];
                    
                    // Calculate distance squared
                    const dx = proj.position.x - pPos.x;
                    const dy = proj.position.y - pPos.y;
                    const dz = proj.position.z - pPos.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    
                    let shouldUpdate = false;
                    let dtScale = 1;
                    
                    if (distSq < COMBAT_DISTANCE_SQ) { // Close - every frame
                        shouldUpdate = true;
                        dtScale = 1;
                    } else if (distSq < CLOSE_DISTANCE_SQ) { // Medium - every 2 frames
                        shouldUpdate = (this.frameIndex % 2 === 0);
                        dtScale = 2;
                    } else { // Far - every 3 frames
                        shouldUpdate = (this.frameIndex % 3 === 0);
                        dtScale = 3;
                    }
                    
                    if (shouldUpdate) {
                        const stepDt = gameDt * dtScale;
                        proj.position.add(proj.userData.velocity.clone().multiplyScalar(stepDt));
                        proj.userData.life -= stepDt;
                        
                        if (!this.player.isDead) {
                            // Hit Check (Simple distance)
                            // We use actual distance here for accuracy
                            const hitDist = proj.position.distanceTo(pPos);
                            if (hitDist < 1.5) {
                                this.player.takeDamage(15);
                                window.flux.spawnParticles(proj.position, 5, 0xff0000, 10);
                                proj.visible = false;
                                this.projectilePool.push(proj);
                                this.enemyProjectiles.splice(i, 1);
                                continue;
                            }
                        }
                        
                        if (this.staticGroup) {
                            // PERF: Use static raycaster
                            const dir = proj.userData.velocity.clone().normalize();
                            _gProjRay.set(proj.position, dir);
                            _gProjRay.far = 1.0;
                            
                            // PERF: Only check if close to something (simple height check)
                            if (proj.position.y < 10) {
                                const hits = _gProjRay.intersectObjects(this.staticGroup.children, true);
                                if (hits.length > 0) {
                                    window.flux.spawnParticles(hits[0].point, 5, 0xffaa00, 10);
                                    proj.visible = false;
                                    this.projectilePool.push(proj);
                                    this.enemyProjectiles.splice(i, 1);
                                    continue;
                                }
                            }
                        }
                        
                        if (proj.userData.life <= 0) {
                            proj.visible = false;
                            this.projectilePool.push(proj);
                            this.enemyProjectiles.splice(i, 1);
                        }
                    }
                }
            }

            if (this.laserSystem) this.laserSystem.update(gameDt);
            
            if (window.flux.trails && this.player && this.player.mesh) {
                const updateTrail = (trail, obj, offset) => {
                    if (!obj) return;
                    _gVec1.set(0,0,0);
                    // PERF: Only update matrix if needed?
                    obj.updateWorldMatrix(true, false);
                    obj.getWorldPosition(_gVec1);
                    if (offset) {
                        // PERF: Use static quaternion
                        const quat = new THREE.Quaternion(); // TODO: Make static in next pass or use obj.quaternion if world
                        obj.getWorldQuaternion(quat);
                        const offsetVec = offset.clone().applyQuaternion(quat);
                        _gVec1.add(offsetVec);
                    }
                    trail.update(_gVec1, gameDt);
                };
                if (this.player.binderL) updateTrail(window.flux.trails.wingL, this.player.binderL, new THREE.Vector3(0, 0.8, 0));
                if (this.player.binderR) updateTrail(window.flux.trails.wingR, this.player.binderR, new THREE.Vector3(0, 0.8, 0));
                if (this.player.legL && this.player.legL.foot) updateTrail(window.flux.trails.footL, this.player.legL.foot, new THREE.Vector3(0, -0.2, 0));
                if (this.player.legR && this.player.legR.foot) updateTrail(window.flux.trails.footR, this.player.legR.foot, new THREE.Vector3(0, -0.2, 0));
            }

            if (this.vectorTrapGroup) {
                // PERF: Swap-and-Pop
                for(let i = this.vectorTrapGroup.children.length - 1; i >= 0; i--) {
                    const trap = this.vectorTrapGroup.children[i];
                    trap.userData.life -= gameDt;
                    trap.scale.addScalar(trap.userData.scaleSpeed * gameDt);
                    trap.rotation.x += 2 * gameDt;
                    trap.rotation.y += 2 * gameDt;
                    if (trap.material) trap.material.opacity = trap.userData.life * 3;
                    if (trap.userData.life <= 0) {
                        this.vectorTrapGroup.remove(trap);
                        if(trap.geometry) trap.geometry.dispose();
                        if(trap.material) trap.material.dispose();
                    }
                }
            }
            
            // PERF: Loot Orbs Throttling (Every 2 frames)
            if (this.frameIndex % 2 === 0 && this.lootOrbs && this.player && this.player.mesh) {
                this.lootOrbs.update(gameDt * 2, this.player.mesh.position, (color, scale) => {
                    if (this.orbSoundCooldown <= 0) {
                        if (window.flux.audio) window.flux.audio.play('ui_hover'); 
                        this.orbSoundCooldown = 0.1; 
                    }
                    const hex = color.getHex();
                    if (hex === 0xff0055) {
                        if (this.player.hp < this.player.maxHp) this.player.hp = Math.min(this.player.maxHp, this.player.hp + 5);
                    } else if (hex === 0x00ffff) {
                        if (this.player.ammo < this.player.maxAmmo) this.player.ammo = Math.min(this.player.maxAmmo, this.player.ammo + 2);
                    } 
                    this.player.ap = Math.min(50, this.player.ap + 2);
                    if (typeof updateHUD === 'function') updateHUD();
                });
            }

            // PERF: DYNAMIC LOD FOR ENEMIES
            if (this.enemies && this.player) {
                const pPos = this.player.mesh.position;
                
                // DEBUG: Show LOD zones if enabled
                if (this.debugLOD) {
                    if (!this.debugHelpers) {
                        this.debugHelpers = new THREE.Group();
                        const combat = new THREE.Mesh(new THREE.RingGeometry(14.5, 15.5, 32), new THREE.MeshBasicMaterial({color: 0x00ff00}));
                        combat.rotation.x = -Math.PI/2; this.debugHelpers.add(combat);
                        const close = new THREE.Mesh(new THREE.RingGeometry(29.5, 30.5, 32), new THREE.MeshBasicMaterial({color: 0xffff00}));
                        close.rotation.x = -Math.PI/2; this.debugHelpers.add(close);
                        const med = new THREE.Mesh(new THREE.RingGeometry(59.5, 60.5, 32), new THREE.MeshBasicMaterial({color: 0xff8800}));
                        med.rotation.x = -Math.PI/2; this.debugHelpers.add(med);
                        this.scene.add(this.debugHelpers);
                    }
                    this.debugHelpers.position.copy(pPos);
                    this.debugHelpers.visible = true;
                } else if (this.debugHelpers) {
                    this.debugHelpers.visible = false;
                }

                for(let i = 0; i < this.enemies.length; i++) {
                    const enemy = this.enemies[i];
                    if (!enemy || !enemy.userData || enemy.userData.isDead) continue;

                    // Calculate squared distance
                    const dx = enemy.position.x - pPos.x;
                    const dy = enemy.position.y - pPos.y;
                    const dz = enemy.position.z - pPos.z;
                    const distSq = dx*dx + dy*dy + dz*dz;

                    let shouldUpdate = false;
                    let dtScale = 1;

                    if (distSq < COMBAT_DISTANCE_SQ) {
                        shouldUpdate = true; // Every frame
                        dtScale = 1;
                    } else if (distSq < CLOSE_DISTANCE_SQ) {
                        shouldUpdate = (this.frameIndex % 2 === 0);
                        dtScale = 2;
                    } else if (distSq < MEDIUM_DISTANCE_SQ) {
                        shouldUpdate = (this.frameIndex % 3 === 0);
                        dtScale = 3;
                    } else if (distSq < FAR_DISTANCE_SQ) {
                        shouldUpdate = (this.frameIndex % 4 === 0);
                        dtScale = 4;
                    } else {
                        shouldUpdate = (this.frameIndex % 6 === 0);
                        dtScale = 6;
                    }

                    if (shouldUpdate) {
                        if (enemy.userData.controller && typeof enemy.userData.controller.update === 'function') {
                            enemy.userData.controller.update(gameDt * dtScale, this.player);
                        }
                    }
                }
            }
            
            // PERF: Throttled Indicator Updates (Every 4 frames)
            if (this.frameIndex % 4 === 0) {
                this.updateOffscreenIndicators();
            }
            
            if (this.enablePostProcessing && this.composer) {
                this.composer.render();
            } else {
                this.renderer.render(this.scene, this.camera);
            }

        } catch (e) {
            console.error("RUNTIME ERROR:", e);
        }
    }
    
    updateCameraLogic(dt) {
        this.camera.up.set(0, 1, 0); 
        
        const pPos = this.player.mesh.position; 
        
        // Visibility Logic
        const fullBodyVisible = !this.player.isFirstPerson && !this.player.isDead;
        if (this.player.visualGroup) this.player.visualGroup.visible = fullBodyVisible;
        if (this.player.swordGroup) this.player.swordGroup.visible = fullBodyVisible && (this.player.currentWeapon === this.player.WEAPON_MELEE);
        if (this.player.gunGroup) this.player.gunGroup.visible = fullBodyVisible && (this.player.currentWeapon !== this.player.WEAPON_MELEE);

        // 1. DETERMINE TARGET CONFIGURATION
        let targetConfig = CAM_CONFIG.DEFAULT;
        
        if (this.player.isFirstPerson) {
            // FPS Mode overrides standard logic
            const headHeight = 1.5;
            _gCamPos.copy(pPos).add(_gVec1.set(0, headHeight, 0));
            
            // Apply Trauma Shake
            if (this.trauma > 0) {
                const shake = this.trauma * this.trauma * 0.5;
                _gCamPos.add(_gVec2.set(
                    (Math.random() - 0.5) * shake,
                    (Math.random() - 0.5) * shake,
                    (Math.random() - 0.5) * shake
                ));
                this.trauma = Math.max(0, this.trauma - dt * 2.0); // Decay
            }
            
            this.camera.position.copy(_gCamPos);
            
            // --- FPS QUATERNION LOGIC ---
            _gYawQuat.setFromAxisAngle(_gUp, this.player.mesh.rotation.y + Math.PI);
            _gPitchQuat.setFromAxisAngle(_gXAxis, this.player.camPitch);
            
            this.camera.quaternion.copy(_gYawQuat).multiply(_gPitchQuat);
            
            this.camera.fov = 90;
            this.camera.updateProjectionMatrix();
            return;
        }
        
        // TPS State Machine
        if (this.player.isDashing) {
            targetConfig = CAM_CONFIG.DASH;
        } else if (this.player.targetEnemy && !this.player.targetEnemy.userData.isDead) {
            targetConfig = CAM_CONFIG.LOCK;
        } else if (this.player.isAttacking) {
            targetConfig = CAM_CONFIG.COMBAT;
        } else if (!this.player.onGround) {
            targetConfig = CAM_CONFIG.AIR;
        } else if (this.player.currentWeapon !== this.player.WEAPON_MELEE && this.input.actions.attack) {
            targetConfig = CAM_CONFIG.AIM; // Firing gun
        }
        
        // 2. INTERPOLATE CONFIGURATION (Weighted Spring)
        // Use stiffness from config for the transition speed
        const lerpSpeed = targetConfig.stiffness * dt;
        
        // --- NEW: ASPECT RATIO COMPENSATION ---
        // If aspect ratio is low (Portrait), increase distance to keep player in frame
        let aspectMultiplier = 1.0;
        if (this.camera.aspect < 1.0) {
            // Keep horizontal FOV effective by pulling back
            aspectMultiplier = 1.0 / this.camera.aspect; 
            // Clamp to avoid extreme distances on very thin screens
            aspectMultiplier = Math.min(aspectMultiplier, 1.8);
        }
        
        this.activeCamSettings.dist = THREE.MathUtils.lerp(this.activeCamSettings.dist, targetConfig.dist * aspectMultiplier, lerpSpeed);
        this.activeCamSettings.height = THREE.MathUtils.lerp(this.activeCamSettings.height, targetConfig.height, lerpSpeed);
        this.activeCamSettings.fov = THREE.MathUtils.lerp(this.activeCamSettings.fov, targetConfig.fov, lerpSpeed);
        this.activeCamSettings.lookY = THREE.MathUtils.lerp(this.activeCamSettings.lookY, targetConfig.lookY, lerpSpeed);
        this.activeCamSettings.lag = THREE.MathUtils.lerp(this.activeCamSettings.lag, targetConfig.lag, lerpSpeed);
        this.activeCamSettings.tilt = THREE.MathUtils.lerp(this.activeCamSettings.tilt, targetConfig.tilt, lerpSpeed);

        // 3. MANUAL ORBIT CONTROL
        const isManualInput = (this.input.lookVector && Math.abs(this.input.lookVector.x) > 0.05);
        
        if (isManualInput) {
            this.manualCamTimer = 2.0; 
        } else if (this.manualCamTimer > 0) {
            this.manualCamTimer -= dt;
        }
        
        const moveVec = this.input.moveVector || {x:0, y:0};
        const isMoving = (Math.abs(moveVec.x) > 0.1 || Math.abs(moveVec.y) > 0.1);
        
        // Auto-Rotate behind player if moving and not manually controlling
        if (isMoving && this.manualCamTimer <= 0 && !this.player.targetEnemy) {
            const moveDir = this.player.velocity.clone().normalize(); 
            const moveAngle = Math.atan2(moveDir.x, moveDir.z);
            let angleDiff = moveAngle - this.player.camRotationY;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            if (Math.abs(angleDiff) < Math.PI / 2) {
                const autoRotateSpeed = 2.0 * dt; // Faster auto-align
                this.player.camRotationY += angleDiff * autoRotateSpeed;
            }
        }
        
        // 4. CALCULATE IDEAL POSITION
        const rotY = this.player.camRotationY;
        
        // Direction from player to camera
        _gVec1.set(Math.sin(rotY), 0, Math.cos(rotY)); 
        
        // Apply Tilt (Dutch Angle) based on strafe
        // If moving sideways relative to camera, tilt
        let tiltAngle = 0;
        if (isMoving) {
            // Calculate local velocity relative to camera
            const fwd = new THREE.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
            const right = new THREE.Vector3().crossVectors(fwd, _gUp);
            const velDir = this.player.velocity.clone().normalize();
            const strafeAmt = velDir.dot(right);
            
            // Dynamic Tilt: More tilt when moving fast
            const speedFactor = Math.min(1.0, this.player.velocity.length() / 20.0);
            tiltAngle = strafeAmt * this.activeCamSettings.tilt * speedFactor * 0.1; // Scale down to radians
        }
        
        // Offset calculation
        _gVec2.copy(_gVec1).multiplyScalar(-this.activeCamSettings.dist); 
        _gVec2.y = this.activeCamSettings.height;
        
        // Target World Position
        const targetWorldPos = pPos.clone().add(_gVec2);
        
        // 5. PHYSICS & LAG (Spring System)
        // Smoothly move current spring position to target
        // Lag factor determines stiffness (lower lag = stiffer)
        const stiffness = 15.0 * (1.0 - this.activeCamSettings.lag);
        const damping = 10.0;
        
        // Spring Physics Integration
        // Force = (Target - Current) * Stiffness - Velocity * Damping
        _gVec3.subVectors(targetWorldPos, this.camPosSpring).multiplyScalar(stiffness); // Spring Force
        _gVec3.sub(this.camVelSpring.clone().multiplyScalar(damping)); // Damping Force
        
        this.camVelSpring.add(_gVec3.multiplyScalar(dt));
        this.camPosSpring.add(this.camVelSpring.clone().multiplyScalar(dt));
        
        // 6. COLLISION RESOLUTION (Raycast from player to camera)
        // We want to ensure the camera doesn't clip through walls
        // Raycast from player head to ideal camera position
        const headPos = pPos.clone().add(_gVec1.set(0, 1.5, 0));
        const camDir = new THREE.Vector3().subVectors(this.camPosSpring, headPos);
        const distToCam = camDir.length();
        
        if (distToCam > 0.1) {
            camDir.normalize();
            
            // WHISKER CHECK: Cast wider rays to detect walls early
            // This prevents the camera from hugging walls too tightly
            const whiskerAngle = 0.2; // Radians
            const whiskerLeft = camDir.clone().applyAxisAngle(_gUp, whiskerAngle);
            const whiskerRight = camDir.clone().applyAxisAngle(_gUp, -whiskerAngle);
            
            // Main Ray
            this.camRaycaster.set(headPos, camDir);
            this.camRaycaster.far = distToCam;
            
            let hitDist = distToCam;
            let hitNormal = null;
            
            if (this.staticGroup) {
                const hits = this.camRaycaster.intersectObjects(this.staticGroup.children, true);
                if (hits.length > 0) {
                    hitDist = Math.max(0.5, hits[0].distance - 0.5); // Buffer
                    hitNormal = hits[0].face.normal;
                } else {
                    // Check Whiskers if main ray is clear
                    this.camRaycaster.set(headPos, whiskerLeft);
                    const hitsL = this.camRaycaster.intersectObjects(this.staticGroup.children, true);
                    if (hitsL.length > 0) {
                        // Push camera right
                        this.camPosSpring.add(_gCamRight.crossVectors(camDir, _gUp).multiplyScalar(0.1));
                    }
                    
                    this.camRaycaster.set(headPos, whiskerRight);
                    const hitsR = this.camRaycaster.intersectObjects(this.staticGroup.children, true);
                    if (hitsR.length > 0) {
                        // Push camera left
                        this.camPosSpring.add(_gCamRight.crossVectors(camDir, _gUp).multiplyScalar(-0.1));
                    }
                }
            }
            
            if (hitDist < distToCam) {
                // --- NEW: ANTI-CLIP LIFT ---
                // If camera is forced too close, move UP instead of zooming in
                const minSafeDist = 3.0; // Minimum distance before lifting
                
                if (hitDist < minSafeDist) {
                    const liftAmount = (minSafeDist - hitDist) * 2.0; // Lift factor
                    this.camPosSpring.y += liftAmount;
                    // Also push slightly forward to avoid clipping through ceiling if lifting
                    this.camPosSpring.copy(headPos).add(camDir.multiplyScalar(hitDist));
                } else {
                    this.camPosSpring.copy(headPos).add(camDir.multiplyScalar(hitDist));
                }
                
                // Kill velocity to prevent bouncing
                this.camVelSpring.set(0,0,0);
            }
        }
        
        // 7. LOOK AT LOGIC (QUATERNION FIX)
        // Calculate Look Target
        let lookTarget = pPos.clone().add(_gVec1.set(0, this.activeCamSettings.lookY, 0));
        
        // PREDICTIVE TRACKING: Look ahead based on player velocity
        const speed = this.player.velocity.length();
        if (speed > 1.0) {
            const lookAhead = this.player.velocity.clone().normalize().multiplyScalar(Math.min(speed * 0.1, 5.0));
            lookTarget.add(lookAhead);
        }
        
        // Lock-on Override with "Soft Lock" framing
        if (this.player.targetEnemy && !this.player.targetEnemy.userData.isDead) {
            const enemyPos = this.player.targetEnemy.position;
            const midpoint = new THREE.Vector3().lerpVectors(pPos, enemyPos, 0.5);
            midpoint.y += 1.0; // Look slightly up
            lookTarget.lerp(midpoint, 0.8); // Bias towards midpoint
        }
        
        // Smooth LookAt Position
        this.camLookSpring.lerp(lookTarget, 4.0 * dt); // Smoother lerp
        
        // --- QUATERNION ROTATION CALCULATION ---
        // Calculate Direction Vector
        _gCamDir.subVectors(this.camLookSpring, this.camera.position);
        
        // SINGULARITY FIX: Ensure horizontal component
        // If camera is directly above/below target, lookAt matrix becomes unstable.
        // We inject a horizontal offset based on player facing to maintain orientation.
        const hDist = Math.sqrt(_gCamDir.x * _gCamDir.x + _gCamDir.z * _gCamDir.z);
        if (hDist < 0.5) {
            const pRotY = this.player.mesh.rotation.y;
            _gCamDir.x += Math.sin(pRotY) * 0.5;
            _gCamDir.z += Math.cos(pRotY) * 0.5;
        }
        _gCamDir.normalize();
        
        // Create Look Rotation Matrix
        // Note: Matrix4.lookAt expects (eye, target, up)
        // We simulate this by looking from (0,0,0) to direction
        _gCamMat.lookAt(this.camera.position, this.camera.position.clone().add(_gCamDir), _gUp);
        _gCamQuat.setFromRotationMatrix(_gCamMat);
        
        // 8. APPLY TRAUMA (Shake)
        if (this.trauma > 0) {
            // Quadratic falloff for juice: shake = trauma^2
            const shake = this.trauma * this.trauma; 
            const maxOffset = 1.5; // Max shake distance
            const maxRoll = 0.1;   // Max shake rotation
            
            // Perlin-ish noise using sin/cos
            this.noiseOffset += dt * 20.0;
            const noiseX = Math.sin(this.noiseOffset) * shake * maxOffset;
            const noiseY = Math.cos(this.noiseOffset * 1.3) * shake * maxOffset;
            const noiseZ = Math.sin(this.noiseOffset * 0.7) * shake * maxOffset;
            
            this.camPosSpring.add(_gVec1.set(noiseX, noiseY, noiseZ));
            
            // Add roll shake
            tiltAngle += (Math.sin(this.noiseOffset * 2.0) * shake * maxRoll);
            
            // Decay trauma
            this.trauma = Math.max(0, this.trauma - dt * 1.5);
        }
        
        // 9. FINAL APPLICATION
        this.camera.position.copy(this.camPosSpring);
        
        // Apply Tilt (Roll) via Quaternion Multiplication
        if (Math.abs(tiltAngle) > 0.001) {
            _gRollQuat.setFromAxisAngle(_gZAxis, tiltAngle);
            _gCamQuat.multiply(_gRollQuat);
        }
        
        // Smoothly interpolate current rotation to target rotation
        this.camera.quaternion.slerp(_gCamQuat, 4.0 * dt); // Slower slerp for smoothness
        
        // Dynamic FOV (Speed Effect)
        let fov = this.activeCamSettings.fov;
        if (speed > 20) {
            fov += Math.min(15, (speed - 20) * 0.5);
        }
        fov *= this.cameraZoom;
        
        this.camera.fov = THREE.MathUtils.lerp(this.camera.fov, fov, dt * 5.0);
        this.camera.updateProjectionMatrix();
        
        // Post-Processing Hooks
        if (this.chromaticAberrationIntensity > 0.0015) {
            this.chromaticAberrationIntensity *= 0.9;
        } else {
            this.chromaticAberrationIntensity = 0.0015;
        }
        if (this.rgbShiftPass) this.rgbShiftPass.uniforms['amount'].value = this.chromaticAberrationIntensity;
        
        if (this.enablePostProcessing) {
            this.updateCameraTransparency(this.camera, this.player.mesh);
        }
        
        // Sync legacy shakeIntensity for other systems
        if (this.shakeIntensity > 0) {
            this.trauma = Math.min(1.0, this.trauma + this.shakeIntensity);
            this.shakeIntensity = 0; // Consumed
        }
    }
    
    // NEW: GROUND LOCK-ON CURSOR UPDATE
    updateLockOnCursor() {
        const lockCursor = document.getElementById('lock-cursor');
        if (!lockCursor) return;

        if (this.player && this.player.targetEnemy && !this.player.targetEnemy.userData.isDead) {
            const target = this.player.targetEnemy;
            
            // Reuse static vector
            _gVec1.copy(target.position);
            // Aim at center of mass (approx)
            _gVec1.y += 1.0; 
            
            _gVec1.project(this.camera);

            // Check if in front of camera
            if (_gVec1.z < 1) {
                const x = (_gVec1.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(_gVec1.y * 0.5) + 0.5) * window.innerHeight;

                lockCursor.style.left = `${x}px`;
                lockCursor.style.top = `${y}px`;
                lockCursor.classList.remove('hidden');
                
                // Update text distance
                const dist = this.player.mesh.position.distanceTo(target.position).toFixed(0);
                const textEl = lockCursor.querySelector('.lock-text');
                if (textEl) textEl.innerText = `TARGET [${dist}m]`;
                
            } else {
                lockCursor.classList.add('hidden');
            }
        } else {
            lockCursor.classList.add('hidden');
        }
    }
    
    updateOffscreenIndicators() {
        if (!this.player || !this.camera || !this.enemies) return;
        
        // OPTIMIZATION: Only update if enemies exist and player is alive
        if (this.enemies.length === 0 || this.player.isDead) {
            this.indicatorPool.forEach(item => {
                if(item.visible) {
                    item.el.style.display = 'none';
                    item.visible = false;
                }
            });
            return;
        }

        let activeIdx = 0;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const center = new THREE.Vector2(width / 2, height / 2);
        
        this.enemies.forEach(enemy => {
            if (enemy.userData.isDead || activeIdx >= 10) return;
            
            _gVec1.copy(enemy.position).add(_gUp); 
            _gVec1.project(this.camera);
            
            const isOffScreen = (_gVec1.x < -1 || _gVec1.x > 1 || _gVec1.y < -1 || _gVec1.y > 1 || _gVec1.z > 1);
            
            if (isOffScreen) {
                const item = this.indicatorPool[activeIdx];
                if (!item.visible) {
                    item.el.style.display = 'block';
                    item.visible = true;
                }
                
                let screenX = _gVec1.x;
                let screenY = _gVec1.y;
                if (_gVec1.z > 1) {
                    screenX = -screenX;
                    screenY = -screenY;
                }
                const angle = Math.atan2(screenY, screenX);
                const deg = -angle * (180 / Math.PI) + 90; 
                const padding = 30;
                const w = width / 2 - padding;
                const h = height / 2 - padding;
                let x = Math.cos(angle) * w * 2; 
                let y = Math.sin(angle) * h * 2;
                if (Math.abs(x) > w) {
                    x = Math.sign(x) * w;
                    y = x * Math.tan(angle);
                }
                if (Math.abs(y) > h) {
                    y = Math.sign(y) * h;
                    x = y / Math.tan(angle);
                }
                item.el.style.transform = `translate(${center.x + x}px, ${center.y - y}px) rotate(${deg}deg)`;
                activeIdx++;
            }
        });
        
        // Hide unused indicators
        for (let i = activeIdx; i < this.indicatorPool.length; i++) {
            const item = this.indicatorPool[i];
            if (item.visible) {
                item.el.style.display = 'none';
                item.visible = false;
            }
        }
    }
}

window.flux = window.flux || {};

window.addEventListener('DOMContentLoaded', () => {
    try {
        const loader = document.getElementById('loading-screen');
        const loadingText = loader.querySelector('.loading-text');
        
        const startHandler = async () => {
            document.removeEventListener('touchstart', startHandler);
            document.removeEventListener('click', startHandler);
            document.removeEventListener('keydown', startHandler);
            if (loader) {
                loader.removeEventListener('click', startHandler);
                loader.removeEventListener('touchstart', startHandler);
            }

            console.log("User interaction detected. Starting Engine.");
            
            if(loadingText) loadingText.innerText = "INITIALIZING...";
            
            try {
                if (typeof AudioSystem !== 'undefined') {
                    window.flux.audio = new AudioSystem();
                    if(loadingText) loadingText.innerText = "LOADING AUDIO...";
                    const audioInitPromise = window.flux.audio.init((loaded, total) => {
                         if(loadingText) loadingText.innerText = `LOADING AUDIO... ${Math.floor((loaded/total)*100)}%`;
                    });
                    const timeoutPromise = new Promise(resolve => setTimeout(resolve, 4000));
                    await Promise.race([audioInitPromise, timeoutPromise]);
                    if (window.flux.audio.enabled) {
                        window.flux.audio.playBGM('bgm_standard', 2.0);
                    }
                }
            } catch (err) {
                console.warn("Audio initialization failed, proceeding without audio.", err);
            }

            if (loader) loader.style.display = 'none';
            
            try {
                if (!window.game) {
                    window.game = new FluxGame();
                    window.game.init();
                }
            } catch (gameErr) {
                console.error("Game Init Failed:", gameErr);
                if (loader) loader.style.display = 'none';
            }
        };

        document.addEventListener('touchstart', startHandler, {once:true});
        document.addEventListener('click', startHandler, {once:true});
        document.addEventListener('keydown', startHandler, {once:true});
        
        if (loader) {
            loader.addEventListener('click', startHandler, {once:true});
            loader.addEventListener('touchstart', startHandler, {once:true});
        }

        // --- NEW: Prevent Input Click from Starting Game ---
        const input = document.getElementById('room-code-input');
        if (input) {
            const stopProp = (e) => e.stopPropagation();
            input.addEventListener('click', stopProp);
            input.addEventListener('touchstart', stopProp);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    // Lock in and start
                    e.preventDefault();
                    input.blur(); // Remove focus
                    startHandler(); // Trigger game start
                } else {
                    e.stopPropagation(); // Allow typing, prevent global start handler
                }
            }); 
        }

    } catch (e) {
        console.error("CRITICAL INIT FAILURE:", e);
        const loader = document.getElementById('loading-screen');
        if (loader) loader.style.display = 'none';
    }
});</script>

</body></html>
